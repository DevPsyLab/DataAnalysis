<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>EEG and ERP Processing and Analysis</title>

<script src="site_libs/header-attrs-2.29/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TYR0QMREEW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TYR0QMREEW');
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="includes/custom.css" type="text/css" />
<link rel="stylesheet" href="font/css/roboto.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Data Analysis Guides for the Developmental Psychopathology Lab</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Guides
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="bayesian.html">Bayesian Analysis</a>
    </li>
    <li>
      <a href="dataManagement.html">Data Management</a>
    </li>
    <li>
      <a href="developmentalScaling.html">Developmental Scaling</a>
    </li>
    <li>
      <a href="dags.html">Directed Acyclic Graphs</a>
    </li>
    <li>
      <a href="eegERP.html">Electroencaphalography/Event-Related Potentials</a>
    </li>
    <li>
      <a href="eda.html">Exploratory Data Analysis</a>
    </li>
    <li>
      <a href="factorAnalysis.html">Factor Analysis</a>
    </li>
    <li>
      <a href="figures.html">Figures</a>
    </li>
    <li>
      <a href="git.html">Git, GitLab, and GitHub</a>
    </li>
    <li>
      <a href="hlm.html">Hierarchical Linear Modeling</a>
    </li>
    <li>
      <a href="hpc.html">High-Performance Computing</a>
    </li>
    <li>
      <a href="irt.html">Item Response Theory</a>
    </li>
    <li>
      <a href="jamovi.html">jamovi</a>
    </li>
    <li>
      <a href="jatos.html">JATOS (Just Another Tool for Online Studies)</a>
    </li>
    <li>
      <a href="jsPsych.html">jsPsych</a>
    </li>
    <li>
      <a href="lamp.html">LAMP (Linux, Apache, MySQL, PHP)</a>
    </li>
    <li>
      <a href="lda.html">Longitudinal Data Analysis</a>
    </li>
    <li>
      <a href="markdown.html">Markdown</a>
    </li>
    <li>
      <a href="sem.html#mediation">Mediation</a>
    </li>
    <li>
      <a href="regression.html#moderation">Moderation/Interaction</a>
    </li>
    <li>
      <a href="mplus.html">Mplus</a>
    </li>
    <li>
      <a href="multipleImputation.html">Multiple Imputation</a>
    </li>
    <li>
      <a href="osf.html">Open Science Framework</a>
    </li>
    <li>
      <a href="pca.html">Principal Component Analysis</a>
    </li>
    <li>
      <a href="https://devpsylab.github.io/pythonDataAnalysisGuides">Python</a>
    </li>
    <li>
      <a href="R.html">R</a>
    </li>
    <li>
      <a href="regression.html">Regression</a>
    </li>
    <li>
      <a href="SPSS.html">SPSS</a>
    </li>
    <li>
      <a href="statistics.html">Statistics</a>
    </li>
    <li>
      <a href="sem.html">Structural Equation Modeling</a>
    </li>
  </ul>
</li>
<li>
  <a href="about.html">About</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://devpsylab.github.io/LabWiki">Lab Wiki</a>
</li>
<li>
  <a href="https://developmental-psychopathology.lab.uiowa.edu">Lab Website</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">EEG and ERP Processing and Analysis</h1>

</div>


<div id="happe" class="section level1" number="1">
<h1><span class="header-section-number">1</span> ERP Processing Pipeline
using HAPPE</h1>
<div id="initial" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Inital Set-up</h2>
<ol style="list-style-type: decimal">
<li>Download MATLAB: <a href="https://its.uiowa.edu/matlab"
class="uri">https://its.uiowa.edu/matlab</a>
<ul>
<li>Click <code>How to Install MatLab</code> and follow the relevant
instructions</li>
<li>Create a <code>MatLab</code> folder in your local directory. You
will keep all of your MatLab related files in this folder.</li>
</ul></li>
<li>Install the HAPPE pipeline: <a
href="https://github.com/PINE-Lab/HAPPE"
class="uri">https://github.com/PINE-Lab/HAPPE</a>
<ul>
<li>Clone the HAPPE repository to your <code>GitHub</code> account</li>
<li>Open the <code>HAPPE</code> folder</li>
<li>Open the <code>HAPPE User Guide</code> document</li>
<li>Read through the <code>HAPPE User Guide</code></li>
<li>Navigate to the <code>Setting up HAPPE</code> section in the user
guide and follow the instructions for setting up the HAPPE pipeline,
including installation of add-ons and eeglab</li>
</ul></li>
<li>Install EP Toolkit: <a
href="https://sourceforge.net/projects/erppcatoolkit/"
class="uri">https://sourceforge.net/projects/erppcatoolkit/</a>
<ul>
<li>After downloading, copy the <code>EP_Toolkit</code> folder to your
<code>Matlab</code> folder (in your local directory)</li>
<li>In the <code>EP_toolkit</code> folder:
<ul>
<li>Open <code>EP_Toolkit</code></li>
<li>Open <code>Documentation</code></li>
<li>Open <code>tutorial</code></li>
</ul></li>
<li>In the <code>tutorial</code> document, navigate to the
<code>Set Up</code> section and follow the instructions for installing
and setting up EP Toolkit and FieldTrip. Do <strong>NOT</strong> follow
instructions for setting up EEGLAB. You have already set up your path to
EEGLAB when you set up the HAPPE pipeline.</li>
<li>You should have the following subfolders in your <code>MatLab</code>
folder:
<ul>
<li><code>EP_Toolkit</code></li>
<li><code>Fieldtrip-[version number]</code></li>
</ul></li>
</ul></li>
</ol>
</div>
<div id="matlabScripts" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> MATLAB Scripts to
Manage HAPPE Files</h2>
<p>We have scripts for each task that can prepare files for the HAPPE
Pipeline and/or manage the files outputted from HAPPE. These actions can
be done manually as well, but the MATLAB scripts make the process more
efficient. The scripts will also generate a “log” of all of the files
processed through HAPPE to facilitate tracking of EEG data processing.
The sections below detail the code used to perform these actions as well
as the instructions for using the current scripts.</p>
<p>Note: Before using the scripts/code detailed below, ensure that all
filepaths used are in your MATLAB path collection. These may
include:</p>
<ul>
<li>The location where the automatic scripts are stored (for our lab,
this is under <code>/Data Processing/6. MATLAB EEG Pipeline</code>)</li>
<li>The location where the HAPPE pre-processing script is stored</li>
<li>The location of the raw data (to be processed)</li>
<li>The location(s) of any intermediate files for processing (e.g., the
updated .mff files that contain accuracy information in FishShark)</li>
<li>The location(s) for any files outputted by HAPPE and/or places you
wish to use the script to move them to</li>
</ul>
</div>
<div id="oddball-processing-pipeline" class="section level2"
number="1.3">
<h2><span class="header-section-number">1.3</span> Oddball Processing
Pipeline</h2>
<div id="matlab-script" class="section level3" number="1.3.1">
<h3><span class="header-section-number">1.3.1</span> MATLAB Script</h3>
<p>The following section describes the MATLAB scripts used to manage
HAPPE output files for the Oddball task data. If you are running HAPPE
manually (i.e., without integrating these scripts), skip to the <a
href="#inputOddballHAPPE">Oddball HAPPE inputs</a> section.</p>
<ol style="list-style-type: decimal">
<li>Open the <code>eegProccessingOddball.m</code> file (stored here:
<code>/Data Processing/6. MATLAB EEG Pipeline/</code>; accessible via
Git <a
href="https://research-git.uiowa.edu/PetersenLab/SRS/SRS-DataProcessing/-/blob/master/6.%20MATLAB%20EEG%20Pipeline/eegProcessingOddball.m">here</a>)
in MATLAB</li>
<li>Update all thresholds and filepaths in script file (must be done
BEFORE running the script)
<ul>
<li>In the second section of our script file, we set our “threshold” for
the minimum number of trials that need to be retained after
pre-processing for a subject’s data to be eligible for PCA. Additional
thresholds can also be set for things like number of channels retained,
but these are not currently in use.</li>
</ul>
<pre><code>% Set quality threshold parameters
trialCutoff = 10;</code></pre>
<ul>
<li>We also set environment variables with all of the filepaths that are
relevant for managing HAPPE output files and tracking processed data.
The following paths should be checked and updated as necessary to
reflect the organization of processing on your computer.
<ul>
<li><code>passPath</code> is the location you wish to have files that
meet or exceed the above-defined thresholds to be saved</li>
<li><code>allPath</code> is the location you wish to have ALL files
outputted from HAPPE saved to (regardless of whether threshold is met or
not)</li>
<li><code>failPath</code> is the location you wish to have files that do
not meet the above-defined thresholds to be copied to
<ul>
<li>.mff files that do not meet threshold will be copied here as an
indication that they should be processed manually to see if they meet
threshold afterward</li>
</ul></li>
<li><code>summPath</code> is the location you wish to save the file that
lists all files processed through HAPPE in the current batch
<ul>
<li>We currently use this to save the “processing log” to a location
that all team members/computers have access to so it is easier to
determine which files require processing when EEG data are not stored on
a shared server</li>
</ul></li>
</ul></li>
</ul>
<pre><code>% Set paths for file sorting
passPath = &#39;V:\Processing-Repo\Folder Structure\3 - Files for PCA&#39;; %location for .txt output files
allPath = &#39;V:\Processing-Repo\Folder Structure\2 - Processed Files&#39;; %location for all processed files to end up
failPath = &#39;V:\Processing-Repo\Folder Structure\1b - Manual Processing&#39;; %location to copy unsuccessful .mff to for manual process

% Set path for processing summary
summPath = &#39;Z:\Shared Server\Study Folder\Data Processing\6. MATLAB EEG Pipeline\Processed Data Logs&#39;;</code></pre></li>
<li>Run the HAPPE Pipeline
<ul>
<li>This first section is designed to rely on user input. Click “Run” on
the MATLAB editor window with the file open to begin the process.</li>
<li>A message will appear in the console prompting you to enter the
filepath to the location of the HAPPE pre-processing file you wish to
run</li>
<li>Once the path is entered, MATLAB will run the file</li>
</ul>
<pre><code>% Set path to HAPPE pre-processing script
happeRun = input(&#39;Enter the full path to the HAPPE pre-processing file:\n&gt; &#39;,&#39;s&#39;) ;

% Call and run HAPPE pre-processing script
run(happeRun);</code></pre></li>
<li>Enter HAPPE inputs
<ul>
<li>See the following section for HAPPE user inputs for Oddball</li>
</ul></li>
</ol>
<p>After the HAPPE inputs are entered, no more user interaction is
required for the script to do its job. The HAPPE pipeline will run, and
the remaining MATLAB code in the script file will evaluate the files
outputted by HAPPE and move them to the appropriate locations based on
this evaluation. See <a href="#oddballPost">Oddball Post-HAPPE Steps</a>
for a detailed explanation of the code used to accomplish this.</p>
</div>
<div id="inputOddballHAPPE" class="section level3" number="1.3.2">
<h3><span class="header-section-number">1.3.2</span> HAPPE Inputs</h3>
<ol style="list-style-type: decimal">
<li>If you are not using the MATLAB scripts described above, you must
first open the HAPPE pipeline V4 script in MATLAB and click “Run”
<ul>
<li>This will be stored in the location to which you mapped the HAPPE
Git repo
(e.g. <code>Documents/GitHub/HAPPE/1. pre-process/HAPPE_v4.m</code>)</li>
</ul></li>
<li>User Inputs
<ul>
<li>Enter the path to the folder containing the dataset.</li>
<li>Select <code>raw</code></li>
<li>Load pre-existing set of input parameter:
<ul>
<li><code>N</code> if this is your first time running data through the
pipeline.</li>
<li><code>Y</code> if you have decided on a set of parameters. Enter the
path to the folder containing the input parameters.</li>
</ul></li>
<li>Low density data: <code>N</code></li>
<li>Data type: <code>task</code></li>
<li>Performing event-related potential (ERP) analysis:
<code>Y</code></li>
<li>Enter the task onset tags
<ul>
<li>Target: <code>tgt+</code></li>
<li>Frequent: <code>frq+</code></li>
<li><code>done</code></li>
</ul></li>
<li>Do multiple onset tags belong to a single condition?
<code>N</code></li>
<li>File format: <code>5</code></li>
<li>Acquisition layout type: <code>2</code></li>
<li>Number of channels: <code>128</code></li>
<li>Do you have additional type fields besides “code”?
<code>N</code></li>
<li>Select channels of interest: <code>all</code></li>
<li>Frequency of electrical noise in Hz: <code>60</code></li>
<li>Are there any additional frequencies, (e.g., harmonics) to reduce?
<code>N</code></li>
<li>Line Noise reduction method: <code>notch</code>
<ul>
<li>Low cutoff: <code>59</code></li>
<li>high cutoff: <code>61</code></li>
</ul></li>
<li>Resample: <code>N</code></li>
<li>Filter
<ul>
<li>Low Pass Cutoff: <code>30</code></li>
<li>High Pass Cutoff: <code>.1</code></li>
</ul></li>
<li>Choose a filter: <code>fir</code></li>
<li>Bad Channel Detection: <code>Y</code>
<ul>
<li><code>after</code> wavelet thresholding</li>
</ul></li>
<li>ECGone: <code>N</code></li>
<li>Wavelet Thresholding
<ul>
<li><code>default</code></li>
<li>Threshold rule: <code>hard</code></li>
</ul></li>
<li>MuscIL: <code>N</code></li>
<li>Segmentation: <code>Y</code>
<ul>
<li>Starting parameter for stimulus: <code>-200</code></li>
<li>Ending parameter for stimulus: <code>1000</code></li>
<li>Task offset: <code>2</code></li>
</ul></li>
<li>Baseline Correction: <code>Y</code>
<ul>
<li>Baseline Correction start: <code>-200</code></li>
<li>Baseline Correction end: <code>0</code></li>
</ul></li>
<li>Interpolation: <code>Y</code></li>
<li>Segment Rejection: <code>Y</code>
<ul>
<li>Segment Rejection Method: <code>amplitude</code>
<ul>
<li>minimum segment rejection threshold: <code>-150</code></li>
<li>maximum segment rejection threshold: <code>150</code></li>
<li>segment rejection based on all channels or ROI:
<code>all</code></li>
</ul></li>
</ul></li>
<li>Re-referencing: <code>Y</code>
<ul>
<li>Does your data contain a flatline or all zero reference channel?
<code>N</code></li>
<li>re-referencing method: <code>average</code></li>
</ul></li>
<li>Save format: <code>1</code></li>
<li>Visualizations: <code>N</code></li>
<li>Parameter file save name: <code>default</code></li>
</ul></li>
</ol>
</div>
<div id="oddballPost" class="section level3" number="1.3.3">
<h3><span class="header-section-number">1.3.3</span> Oddball Post-HAPPE
Steps</h3>
<p>This section details the actions performed by the MATLAB scripts once
HAPPE is completed. These actions will take place automatically upon
completion of the HAPPE pipeline. <strong>No user inputs or actions are
necessary at this stage.</strong></p>
<ol style="list-style-type: decimal">
<li><p>Exclude files that don’t have any output data from the dataset
(containing filename and quality reports from HAPPE pipeline) that will
be used to assess file quality</p>
<ul>
<li>This step is important because “empty” files don’t play nicely with
the code used to evaluate files that have some data in them (even if the
data do not meet threshold)</li>
<li>This code relies on HAPPE’s quality data that remains in the MATLAB
environment after the pipeline has finished.</li>
</ul>
<pre><code>% Create a list of files that received some kind of error message
noTags = any(strcmp(dataQC, &#39;NO_TAGS&#39;), 2);
oneRej = any(strcmp(dataQC, &#39;REJ_ONE_SEG&#39;), 2);
allRej = any(strcmp(dataQC, &#39;ALL_SEG_REJ&#39;), 2);
error = any(strcmp(dataQC, &#39;ERROR&#39;), 2);
loadFail = any(strcmp(dataQC, &#39;LOAD_FAIL&#39;), 2);

% Combine filenames with quality data (for some reason, they are not automatically connected by HAPPE)
dataQCNew = [FileNames&#39;, dataQC];

% Remove all files in the above lists (those receiving errors) from the quality data
dataQCNew(noTags | allRej | error | loadFail | oneRej, :) = [];

% Create list of variable names for quality data
dataQCnamesNew = [&quot;File&quot;, dataQCnames];

% Save the data as a table for ease of use in subsequent steps
qcTable = cell2table(dataQCNew, &#39;VariableNames&#39;, dataQCnamesNew);</code></pre></li>
<li><p>Identify the files that meet (or don’t meet) the threshold</p>
<pre><code>% Create a list of files (i.e., rows in the table) that meet threshold
thresholdTest = qcTable.(&quot;Number_tgt+_Segs_Post-Seg_Rej&quot;) &gt;= trialCutoff &amp; qcTable.(&quot;Number_frq+_Segs_Post-Seg_Rej&quot;) &gt;= trialCutoff;

% Add a variable to the quality data table that include whether or not the file meet threshold
qcTable.Test = thresholdTest;</code></pre></li>
<li><p>Add an identifying variable to be used for data joining down the
line</p>
<ul>
<li>This variable is generated using its expected location in the file
name (i.e., how many text characters “in” it is)</li>
</ul>
<pre><code>% Generate IDs based on File variable
idWaveQC = extractBefore(qcTable.File, 8);

% Append ID variable to quality data
qcTable.idWave = idWaveQC;</code></pre></li>
<li><p>Create a subsetted dataset conataining only the
<code>idWave</code>, file name, and “test results” (i.e., whether a
given file meets the specified cutoff threshold for inclusion)
variables</p>
<pre><code>% Subset to ID and threshold information
testInfo = qcTable(:, [&quot;idWave&quot;, &quot;File&quot;, &quot;Test&quot;]);

fprintf(&#39;Assessment Complete \n&#39;);</code></pre></li>
<li><p>Generate a list of files outputted by HAPPE</p>
<pre><code>% Generate path for HAPPE pre-processing output (using the HAPPE environment variable from user&#39;s input of location of raw data for processing)
inputPath = strcat(srcDir, &quot;\5 - processed&quot;);

% Read in list of files outputted from HAPPE 
preprocessingOutput = dir(inputPath);

% Remove &quot;empty&quot; rows 
preprocessingOutput = preprocessingOutput(~ismember({preprocessingOutput.name}, {&#39;.&#39;, &#39;..&#39;}));

% Save data as a table for ease of later use
preprocessingOutput = struct2table(preprocessingOutput);

% Subset to file info
fileInfo = preprocessingOutput(:, [&quot;name&quot;, &quot;folder&quot;]);</code></pre></li>
<li><p>Select only desired files to be moved/copied</p>
<ul>
<li>Currently, we don’t do anything with the “Individual Trial” files
outputted by HAPPE. These files are quite large and take a long time to
move, so it is more efficient to just remove them from the data and not
worry about moving them anywhere.</li>
</ul>
<pre><code>% Subset to desired files (AveOverTrial)
fileSubset = fileInfo(contains(fileInfo.name, &quot;AveOverTrials&quot;), :);</code></pre></li>
<li><p>Add condition, ID, and threshold-related variables to the file
data</p>
<ul>
<li>NOTE: The value for <code>Condition</code> variable (i.e., “Target”
or “Frequent”) should match the name of the condition-specific folders
you wish the files to save to within the processing repo.</li>
</ul>
<pre><code>% Generate list of IDs based on file name variable
idWaveFS = extractBefore(fileSubset.name, 8);

% Add ID list to file data
fileSubset.idWave = idWaveFS;

% Generate list of files belonging to each condition based on file name variable
target = contains(fileSubset.name, &quot;tgt+&quot;);
frequent = contains(fileSubset.name, &quot;frq+&quot;);

% Create empty variable for condition
fileSubset.cond = cell(size(fileSubset, 1), 1);

% Fill in condition variable based on the lists generated above
fileSubset.cond(target) = {&#39;Target&#39;};
fileSubset.cond(frequent) = {&#39;Frequent&#39;};
fileSubset.cond(~target &amp; ~frequent) = {&#39;All&#39;};

% Join threshold test information
fileTest = join(fileSubset, testInfo);</code></pre></li>
<li><p>Prepare data table with information about files that met the
threshold</p>
<ul>
<li>The data generated here are preparing to copy the .txt files
outputted by HAPPE into a folder containing all files that are suitable
for PCA</li>
</ul>
<pre><code>% Create a separate table for only files that meet threshold
movingInfo = fileTest(fileTest.Test, :);

% Create empty columns for filepath variables
movingInfo.destination = cell(size(movingInfo, 1), 1);
movingInfo.origin = cell(size(movingInfo, 1), 1);
movingInfo.processedTo = cell(size(movingInfo, 1), 1);
movingInfo.processedFrom = cell(size(movingInfo, 1), 1);

% Generate file paths based on condition 
movingInfo.destination = strcat({passPath}, &quot;\&quot;, movingInfo.cond, &quot;\&quot;, movingInfo.name);
movingInfo.origin = strcat(movingInfo.folder, &quot;\&quot;, movingInfo.name);
movingInfo.processedTo = strcat({allPath}, &quot;\&quot;, movingInfo.name);
movingInfo.processedFrom = strcat(movingInfo.folder, &quot;\&quot;, movingInfo.name);</code></pre></li>
<li><p>Prepare data table with information about files that do NOT meet
the threshold</p>
<ul>
<li>The data generated here are preparing to copy .mff files from the
location of the raw files into a folder indicating the need for manual
processing</li>
</ul>
<pre><code>% Create a separate table for only files that did not meet threshold
failFiles = fileTest(~fileTest.Test, [&quot;File&quot;, &quot;folder&quot;, &quot;name&quot;]);

% Create empty columns for filepath variables
failFiles.destination = cell(size(failFiles, 1), 1);
failFiles.origin = cell(size(failFiles, 1), 1);
failFiles.processedTo = cell(size(failFiles, 1), 1);
failFiles.processedFrom = cell(size(failFiles, 1), 1);

% Generate filepaths based on ID and task
failFiles.destination = strcat({failPath}, &quot;\&quot;, failFiles.File);
failFiles.origin = strcat({srcDir}, &quot;\&quot;, failFiles.File);
failFiles.processedFrom = strcat(failFiles.folder, &quot;\&quot;, failFiles.name);
failFiles.processedTo = strcat({allPath}, &quot;\&quot;, failFiles.name);
</code></pre></li>
<li><p>Generate environment variables that correspond to the column
index of relevant variables for file sorting</p>
<ul>
<li>Note that the very last line of this code defines the varaible(s) to
exclude from the HAPPE outputted files. This variable must be stripped
from the data before saving them, because the presence of the extra
variable makes the file incompatible with EP Toolkit’s PCA process.</li>
</ul>
<pre><code>% Define column locations for each filepath variable

% For files that meet threshold:
toCol = find(strcmp(movingInfo.Properties.VariableNames, &quot;destination&quot;));
fromCol = find(strcmp(movingInfo.Properties.VariableNames, &quot;origin&quot;));
procColto = find(strcmp(movingInfo.Properties.VariableNames, &quot;processedTo&quot;));
procColfrom = find(strcmp(movingInfo.Properties.VariableNames, &quot;processedFrom&quot;));

% For files that do not meet threshold
rawCol = find(strcmp(failFiles.Properties.VariableNames, &quot;origin&quot;));
manCol = find(strcmp(failFiles.Properties.VariableNames, &quot;destination&quot;));
failProcColto = find(strcmp(failFiles.Properties.VariableNames, &quot;processedTo&quot;));
failProcColFrom = find(strcmp(failFiles.Properties.VariableNames, &quot;processedFrom&quot;));

% Define variable to exclude
extraVar = &#39;Time&#39;;</code></pre></li>
<li><p>Use a loop to process all files that met threshold</p>
<ul>
<li>For each row in the “movingInfo” dataset, the loop will:
<ul>
<li>Identify the origin and destination paths</li>
<li>Read in the HAPPE output file</li>
<li>Remove the extra variable</li>
<li>Save the “cleaned” data in the appropriate folder (without variable
names, as required by EP Toolkit)</li>
</ul></li>
</ul>
<pre><code>for row = 1:height(movingInfo)
    % Specify path info
    pathFrom = movingInfo{row, fromCol};
    pathTo = movingInfo{row, toCol};
    % Read in the data
    rawTable = readtable(pathFrom);
    % Remove extra column (Time)
    cleanTable = rawTable{:, ~strcmp(rawTable.Properties.VariableNames, extraVar)};
    % Save without headers
    writematrix(cleanTable, pathTo, &#39;Delimiter&#39;, &#39;\t&#39;)
end
</code></pre></li>
<li><p>Use a loop to copy raw (.mff) files into a location that stores
files requiring manual processing</p>
<pre><code>for row = 1:height(failFiles)
    % Specify path info
    pathFrom = failFiles{row, rawCol};
    pathTo = failFiles{row, manCol};
    % Copy file 
    copyfile(pathFrom, pathTo)
end</code></pre></li>
<li><p>Use a set of loops to copy all HAPPE output files into a folder
intended to house all output (whether threshold is met or not)</p>
<pre><code>for row = 1:height(movingInfo)
    % Specify path info
    pathFrom = movingInfo{row, procColfrom};
    pathTo = movingInfo{row, procColto};
    % Copy file
    copyfile(pathFrom, pathTo);
end

for row = 1:height(failFiles)
    % Specify path info
    pathFrom = failFiles{row, failProcColFrom};
    pathTo = failFiles{row, failProcColto};
    % Copy file
    copyfile(pathFrom, pathTo);
end</code></pre></li>
<li><p>Generate a .txt file listing all processed .mff files</p>
<ul>
<li>This file will contain a list of all raw files (e.g.,
<code>1111_22_oddball.mff</code>) and save the list to the specified
location (“summPath”)</li>
<li>The file will have the current date and time appended to the end so
that it will be distinguishable from past logs</li>
<li>The list of processed files is generated using an environment
variable (<code>FileNames</code>) that the HAPPE pipeline creates that
lists all files inputted to the pipeline</li>
</ul>
<pre><code>% Create a table from HAPPE FileNames cell array
processedList = cell2table(FileNames(:));

% Rename file variable from default
processedList = renamevars(processedList, {&#39;Var1&#39;}, {&#39;File&#39;});

% Save current date as a string variable 
today = string(date());

% Save time as a string variable, replacing &quot;:&quot; with &quot;_&quot; so that file can be written 
time = strrep(datestr(now, &#39;HH:MM:SS:FFF&#39;), &#39;:&#39;, &quot;_&quot;);

% Generate file name to include current date and time 
listFile = strcat(&quot;\oddballProcessed_&quot;, today, &quot;_&quot;, time);

% Generate full path including file name
summPathFull = strcat(summPath, listFile);

% Write table to specified location
writetable(processedList, summPathFull);</code></pre></li>
</ol>
</div>
</div>
<div id="fishshark-processing-pipeline" class="section level2"
number="1.4">
<h2><span class="header-section-number">1.4</span> Fish/Shark Processing
Pipeline</h2>
<div id="matlab-script-1" class="section level3" number="1.4.1">
<h3><span class="header-section-number">1.4.1</span> MATLAB Script</h3>
<p>The following section describes the MATLAB scripts used to manage
HAPPE input and output files for the Fish/Shark task data. If you are
running HAPPE manually (i.e., without integrating these scripts), skip
to the <a href="#inputFishSharkHAPPE">Fish/Shark HAPPE inputs</a>
section.</p>
<p><strong>The first two steps dsescribed in this section are the same
as those described for Oddball processing.</strong> <strong>Processing
actions specific to FishSharks task begin in Step 3</strong></p>
<ol style="list-style-type: decimal">
<li><p>Open the <code>eegProccessingFishshark.m</code> file (stored
here: <code>/Data Processing/6. MATLAB EEG Pipeline/</code>; accessible
via Git <a
href="https://research-git.uiowa.edu/PetersenLab/SRS/SRS-DataProcessing/-/blob/master/6.%20MATLAB%20EEG%20Pipeline/eegProcessingFishshark.m">here</a>)
in MATLAB</p></li>
<li><p>Update all thresholds and filepaths in script file (must be done
BEFORE running the script)</p>
<ul>
<li>In the fifth section of our script file, we set our “threshold” for
the minimum number of trials that need to be retained after
pre-processing for a subject’s data to be eligible for PCA. Additional
thresholds can also be set for things like number of channels retained,
but these are not currently in use.</li>
<li>Note that setting these parameters occurs later in the FishSharks
script than the one for Oddball; this is because FishSharks files
require additional processing before they are ready for HAPPE (see step
2 for details)</li>
</ul>
<pre><code>% Set quality threshold parameters
trialCutoff = 10;</code></pre>
<ul>
<li>We also set environment variables with all of the filepaths that are
relevant for managing HAPPE output files and tracking processed data.
The following paths should be checked and updated as necessary to
reflect the organization of processing on your computer.
<ul>
<li><code>passPath</code> is the location you wish to have files that
meet or exceed the above-defined thresholds to be saved</li>
<li><code>allPath</code> is the location you wish to have ALL files
outputted from HAPPE saved to (regardless of whether threshold is met or
not)</li>
<li><code>failPath</code> is the location you wish to have files that do
not meet the above-defined thresholds to be copied to
<ul>
<li>.mff files that do not meet threshold will be copied here as an
indication that they should be processed manually to see if they meet
threshold afterward</li>
</ul></li>
<li><code>summPath</code> is the location you wish to save the file that
lists all files processed through HAPPE in the current batch
<ul>
<li>We currently use this to save the “processing log” to a location
that all team members/computers have access to so it is easier to
determine which files require processing when EEG data are not stored on
a shared server</li>
</ul></li>
</ul></li>
</ul>
<pre><code>% Set paths for file sorting
passPath = &#39;V:\Processing-Repo\Folder Structure\3 - Files for PCA&#39;; %location for .txt output files
allPath = &#39;V:\Processing-Repo\Folder Structure\2 - Processed Files&#39;; %location for all processed files to end up
failPath = &#39;V:\Processing-Repo\Folder Structure\1b - Manual Processing&#39;; %location to copy unsuccessful .mff to for manual process

% Set path for processing summary
summPath = &#39;Z:\Shared Server\Study Folder\Data Processing\6. MATLAB EEG Pipeline\Processed Data Logs&#39;;</code></pre></li>
<li><p>Update raw (.mff) files’ condition tags with accuracy
information</p>
<ul>
<li>Unlike the Passive Oddball task, FishSharks trials can be either
correct or incorrect. Whether or not a trial was “responded to”
correctly is relevant to the nature of the extracted ERP. Because the
event tags in our .mff files do not inherently contain information about
whether each trial was responded to correctly, we need to add it
ourselves. This process can be done manually in NetStation, but it can
also be automated using the MATLAB code detailed below.</li>
<li>NOTE: This code requires eeglab. Before running the code, open
eeglab in your MATLAB session by typing <code>eeglab</code> into the
console. You can close it as soon as it opens, but this step ensures
that eeglab is loaded into your current session and helps prevent the
subsequent code from erroring out.</li>
</ul>
<ol style="list-style-type: decimal">
<li><p>Set the filepaths for raw and updated .mff files</p>
<ul>
<li>This section is set to rely on user inputs. Click “Run” in the
MATLAB editor to start the processing.</li>
<li>A message will appear in the console prompting you to enter two
filepaths: the first is the location of the raw .mff files, and the
second is the location you would like the updated files to save in.</li>
</ul>
<pre><code>% User input for location of raw files
pathRaw = input(&#39;Enter the full path to the folder containing the raw files:\n&gt; &#39;,&#39;s&#39;);

% User input for destination of subsetted files
pathSub = input(&#39;Enter the full path to the folder in which to save the subsetted files:\n&gt; &#39;,&#39;s&#39;);</code></pre>
<p>At this point, there will be no user input/actions necessary until
all of the .mff files in the “pathRaw” directory have been updated and
saved into the “pathSub” directory. The code that asks the user for the
path to HAPPE will run when that process has finished. The following
section will describe the code used to automate the process of updated
.mff event tags to include accuracy information at the trial level. Move
on to Step 3 when the process has completed.</p></li>
<li><p>Gather and manage information from the directory housing the raw
(.mff) files</p>
<pre><code>% Have MATLAB gather a list of raw files housed in specified location (pathRaw)
dirInfo = struct2table(dir(pathRaw));

% Remove blank rows
noName = strcmp(dirInfo.name, &#39;.&#39;) | strcmp(dirInfo.name, &#39;..&#39;);
dirInfo(noName, :) = [];</code></pre></li>
<li><p>Generate variables necessary for managing raw and updated
files</p>
<ul>
<li>This code will generate the full filepaths (including file name)
necessary for reading in and saving each .mff file and its updated
counterpart</li>
<li>It will also generate an ID variable for joining purposes based on
the expected location of the subject name in the name of each file</li>
</ul>
<pre><code>% Generate ID variable
dataFiles = dirInfo(:, &quot;name&quot;);

% Add ID variable to file data
dataFiles.ID = extractBefore(dataFiles.name, 8);

% Generate path to read raw data
rawPaths = dataFiles;
rawPaths.path = strcat({pathRaw}, &quot;/&quot;, dirInfo.name);
rawPaths = rawPaths(:, [&quot;ID&quot;, &quot;path&quot;]);

% Generate path to save updated versions of the data (containing accuracy info at trial level)
subPaths = dataFiles;
subPaths.path = strcat({pathSub}, &quot;/&quot;, subPaths.ID, &quot;_sub_fishshark.mff&quot;);
subPaths = subPaths(:, [&quot;ID&quot;, &quot;path&quot;]);

% Join filepath datatables
mergePaths = join(rawPaths, subPaths, &#39;Keys&#39;, {&#39;ID&#39;})</code></pre></li>
<li><p>Use a loop to update the event tags in each .mff file to reflect
accuracy of response</p>
<ul>
<li>For every file included in the “mergePaths” dataset, MATLAB will
perform the following actions:
<ul>
<li>Set environment variables representing the path to read in the
original .mff file and save its updated counterpart (updates with each
iteration of the loop)</li>
<li>Read in the .mff file</li>
<li>Extract the “event” information from the .mff file</li>
<li>Evaluate whether there is usable data in the file
<ul>
<li>This step prevents the code from erroring out if a subject did not
make it past the practice trials</li>
<li>If the evaluation determines that there is NOT usable data in the
present file, the loop will jump to the next file</li>
</ul></li>
<li>Create a table containing response information (response vs no
response and reaction time) and condition information (go vs no-go) at
the trial level</li>
<li>Evaluate each trial to determine whether the response was correct or
incorrect
<ul>
<li>For No-Go trials, responses are CORRECT if there was no response
(incorrect if subject did respond)</li>
<li>For Go trials, responses are CORRECT if there was a response AND
subject’s reaction time was at least 200 ms (incorrect if subject did
not respond OR if subject responded too quickly for response to be
considered “valid”)</li>
</ul></li>
<li>Update the event tags in the .mff file to contain a “c” for correct
trials and an “x” for incorrect trials
<ul>
<li>The c/x indicator will be appended to the front of the existing
event tag (e.g., <code>Go++</code> will become <code>cGo++</code>)</li>
</ul></li>
<li>Export an updated version of the .mff file with accuracy information
to the specified location (“pathSub”)</li>
</ul></li>
</ul></li>
</ol>
<p><strong>NOTE: When exporting EEG data from MATLAB, it is absolutely
necessary for the data to be organized in order of event
latency.</strong> <strong>If the rows are out of order, latency errors
may be introduced.</strong></p>
<ul>
<li>Correct row order can be achieved in .mff filetypes by sorting
according to either the <code>latency</code> column or the
<code>urevent</code> column (as shown below)</li>
</ul>
<pre><code>```
for row = 1:height(mergePaths)
    % Specify paths
    rawFolder = mergePaths{row, &quot;path_rawPaths&quot;}
    subFolder = mergePaths{row, &quot;path_subPaths&quot;}

    % Read in EEG data
    EEGraw = pop_mffimport(char(rawFolder), &#39;code&#39;)

    % Create table from &quot;event&quot; field of raw data
    EEGevent = struct2table(EEGraw.event)

    % Check for the existence of usable rows
    checkVars = strcmp(EEGevent.Properties.VariableNames, &#39;mffkey_cel&#39;)

    % Skip files without necessary variables
    if max(checkVars) == 0
        continue
    end

    % Create table without practice/training trials
    keepRows = strcmp(EEGevent.mffkey_cel, &#39;4&#39;)
    EEGsub  = EEGevent(keepRows, :)

    % Check for the existence of usable rows
    checkRows = max(keepRows)

    % Skip files with no usable rows
    if checkRows == 0
        continue
    end

    % Get response info at trial level
    EEGresp = table(EEGsub.mffkey_obs, EEGsub.mffkey_eval, EEGsub.mffkey_rtim)
    EEGresp = rmmissing(EEGresp)
    EEGresp = renamevars(EEGresp, [&quot;Var1&quot;, &quot;Var2&quot;, &quot;Var3&quot;], [&quot;Trial&quot;, &quot;Eval&quot;, &quot;RTime&quot;])

    % Get condition info at trial level
    EEGconds = table(EEGsub.mffkey_obs, EEGsub.type)
    EEGconds = renamevars(EEGconds, [&quot;Var1&quot;, &quot;Var2&quot;], [&quot;Trial&quot;, &quot;Cond&quot;])
    keepConds = strcmp(EEGconds.Cond, &#39;Go++&#39;) | strcmp(EEGconds.Cond, &#39;NG++&#39;)
    EEGcond = EEGconds(keepConds, :)

    % Merge datasets
    EEGtrials = join(EEGcond, EEGresp)

    EEGtrials.RTime = cellfun(@str2num, EEGtrials.RTime)
    % Evaluate trials for correct-ness of response
    correct = strcmp(EEGtrials.Cond, &#39;Go++&#39;) &amp; strcmp(EEGtrials.Eval, &#39;1&#39;) &amp; EEGtrials.RTime &gt; 200 | strcmp(EEGtrials.Cond, &#39;NG++&#39;) &amp; strcmp(EEGtrials.Eval, &#39;0&#39;)
    EEGtrials.Acc = correct


    % Create new code tags including accuracy information
    EEGtrials.newCode(EEGtrials.Acc &amp; strcmp(EEGtrials.Cond, &#39;Go++&#39;)) = {&#39;cGo++&#39;}
    EEGtrials.newCode(~EEGtrials.Acc &amp; strcmp(EEGtrials.Cond, &#39;Go++&#39;)) = {&#39;xGo++&#39;}
    EEGtrials.newCode(EEGtrials.Acc &amp; strcmp(EEGtrials.Cond, &#39;NG++&#39;)) = {&#39;cNG++&#39;}
    EEGtrials.newCode(~EEGtrials.Acc &amp; strcmp(EEGtrials.Cond, &#39;NG++&#39;)) = {&#39;xNG++&#39;}

    % Subset information for merge
    EEGmerge = EEGtrials(:, {&#39;Trial&#39;, &#39;Cond&#39;, &#39;newCode&#39;})

    % Prep key in original data
    EEGevent.key = strcat(EEGevent.mffkey_obs, EEGevent.type)

    % Prep key in merge data
    EEGmerge.key = strcat(EEGmerge.Trial, EEGmerge.Cond)
    EEGmerge = EEGmerge(:, {&#39;key&#39;, &#39;newCode&#39;})

    % Merge new codes with event table
    EEGnew = outerjoin(EEGevent, EEGmerge)

    % Replace codes where new code is needed
    EEGnew.code(~strcmp(EEGnew.newCode, &#39;&#39;)) = EEGnew.newCode(~strcmp(EEGnew.newCode, &#39;&#39;))
    EEGnew.type(~strcmp(EEGnew.newCode, &#39;&#39;)) = EEGnew.newCode(~strcmp(EEGnew.newCode, &#39;&#39;))

    % Arrange table in order of event (CRUCIAL for correct export)
    EEGnew = sortrows(EEGnew, &#39;urevent&#39;)

    % Convert table back to struct and restore original dimensions
    EEGnew = table2struct(EEGnew(:, 1:29))
    EEGnew = reshape(EEGnew, [1, height(EEGnew)])

    % Replace event table(s) in original struct
    EEGraw.event = EEGnew
    EEGraw.urevent = table2struct(struct2table(EEGnew(:, 1:28)))

    % Export updated file
    pop_mffexport(EEGraw, char(subFolder))
end 
```</code></pre></li>
<li><p>Run the HAPPE Pipeline</p>
<ul>
<li>This section is designed to rely on user input.</li>
<li>When the prior steps have finsihed, a message will appear in the
console prompting you to enter the filepath to the location of the HAPPE
pre-processing file you wish to run</li>
<li>Once the path is entered, MATLAB will run the file</li>
</ul>
<pre><code>% Set path to HAPPE pre-processing script
happeRun = input(&#39;Enter the full path to the HAPPE pre-processing file:\n&gt; &#39;,&#39;s&#39;) ;

% Call and run HAPPE pre-processing script
run(happeRun);</code></pre></li>
<li><p>Enter HAPPE inputs</p>
<ul>
<li>See the following section for HAPPE inputs for the Fish/Shark
task</li>
</ul></li>
</ol>
<p>After the HAPPE inputs are entered, no more user interaction is
required for the script to do its job. The HAPPE pipeline will run, and
the remaining MATLAB code in the script file will evaluate the files
outputted by HAPPE and move them to the appropriate locations based on
this evaluation. See <a href="#FishSharkPost">Fish/Shark Post-HAPPE
Steps</a> for a detailed explanation of the code used to accomplish
this.</p>
</div>
<div id="inputFishSharkHAPPE" class="section level3" number="1.4.2">
<h3><span class="header-section-number">1.4.2</span> HAPPE Inputs</h3>
<ol style="list-style-type: decimal">
<li>If you are not using the MATLAB scripts described above, you must
first open the HAPPE pipeline V4 script in MATLAB and click “Run”
<ul>
<li>This will be stored in the location to which you mapped the HAPPE
Git repo
(e.g. <code>Documents/GitHub/HAPPE/1. pre-process/HAPPE_v4.m</code>)</li>
</ul></li>
<li>User Inputs
<ul>
<li>Enter the path to the folder containing the dataset.</li>
<li>Select <code>raw</code></li>
<li>Load pre-existing set of input parameter:
<ul>
<li><code>N</code> if this is your first time running data through the
pipeline.</li>
<li><code>Y</code> if you have decided on a set of parameters. Enter the
path to the folder containing the input parameters.</li>
</ul></li>
<li>Low density data: <code>N</code></li>
<li>Data type: <code>task</code></li>
<li>Performing event-related potential (ERP) analysis:
<code>Y</code></li>
<li>Enter the task onset tags
<ul>
<li>Correct Go: <code>cGo++</code></li>
<li>Incorrect Go: <code>xGo++</code></li>
<li>Correct NoGo: <code>cNG++</code></li>
<li>Incorrect NoGo: <code>xNG++</code></li>
<li><code>done</code></li>
</ul></li>
<li>Do multiple onset tags belong to a single condition?
<code>N</code></li>
<li>File format: <code>5</code></li>
<li>Acquisition layout type: <code>2</code></li>
<li>Number of channels: <code>128</code></li>
<li>Do you have additional type fields besides “code”?
<code>N</code></li>
<li>Select channels of interest: <code>all</code></li>
<li>Frequency of electrical noice in Hz: <code>60</code></li>
<li>Are there any additional frequencies, (e.g., harmonics) to reduce?
<code>N</code></li>
<li>Line Noise reduction method: <code>notch</code>
<ul>
<li>Low cutoff: <code>59</code></li>
<li>high cutoff: <code>61</code></li>
</ul></li>
<li>Resample: <code>N</code></li>
<li>Filter
<ul>
<li>Low Pass Cutoff: <code>30</code></li>
<li>High Pass Cutoff: <code>.1</code></li>
</ul></li>
<li>Choose a filter: <code>fir</code></li>
<li>Bad Channel Detection: <code>Y</code>
<ul>
<li><code>after</code> wavelet thresholding</li>
</ul></li>
<li>ECGone: <code>N</code></li>
<li>Wavelet Thresholding
<ul>
<li><code>default</code></li>
<li>Threshold rule: <code>hard</code></li>
</ul></li>
<li>MuscIL: <code>N</code></li>
<li>Segmentation: <code>Y</code>
<ul>
<li>Starting parameter for stimulus: <code>-200</code></li>
<li>Ending parameter for stimulus: <code>1000</code></li>
<li>Task offset: <code>17</code></li>
</ul></li>
<li>Baseline Correction: <code>Y</code>
<ul>
<li>Baseline Correction start: <code>-200</code></li>
<li>Baseline Correction end: <code>0</code></li>
</ul></li>
<li>Interpolation: <code>Y</code></li>
<li>Segment Rejection: <code>Y</code>
<ul>
<li>Segment Rejection Method: <code>amplitude</code>
<ul>
<li>minimum segment rejection threshold: <code>-150</code></li>
<li>maximum segment rejection threshold: <code>150</code></li>
<li>segment rejection based on all channels or ROI:
<code>all</code></li>
</ul></li>
</ul></li>
<li>Re-referencing: <code>Y</code>
<ul>
<li>Does your data contain a flatline or all zero reference channel?
<code>N</code></li>
<li>re-referencing method: <code>average</code></li>
</ul></li>
<li>Save format: <code>1</code></li>
<li>Visualizations: <code>N</code></li>
<li>Parameter file save name: <code>default</code></li>
</ul></li>
</ol>
</div>
<div id="fishSharkPost" class="section level3" number="1.4.3">
<h3><span class="header-section-number">1.4.3</span> Fish/Shark
Post-HAPPE Steps</h3>
<p>This section details the actions performed by the MATLAB scripts once
HAPPE is completed. These actions will take place automatically upon
completion of the HAPPE pipeline. <strong>No user inputs or actions are
necessary at this stage.</strong></p>
<ol style="list-style-type: decimal">
<li><p>Exclude files that don’t have any output data from the dataset
(containing filename and quality reports from HAPPE pipeline) that will
be used to assess file quality</p>
<ul>
<li>This step is important because “empty” files don’t play nicely with
the code used to evaluate files that have some data in them (even if the
data do not meet threshold)</li>
<li>This code relies on HAPPE’s quality data that remains in the MATLAB
environment after the pipeline has finished.</li>
</ul>
<pre><code>% Create a list of files that received some kind of error message
noTags = any(strcmp(dataQC, &#39;NO_TAGS&#39;), 2);
allRej = any(strcmp(dataQC, &#39;ALL_SEG_REJ&#39;), 2);
oneRej = any(strcmp(dataQC, &#39;REJ_ONE_SEG&#39;), 2);
error = any(strcmp(dataQC, &#39;ERROR&#39;), 2);
loadFail = any(strcmp(dataQC, &#39;LOAD_FAIL&#39;), 2);

% Combine filenames with quality data (for some reason, they are not automatically connected by HAPPE)
dataQCNew = [FileNames&#39;, dataQC];

% Remove all files in the above lists (those receiving errors) from the quality data
dataQCNew(noTags | allRej | error | loadFail | oneRej, :) = [];

% Create list of variable names for quality data
dataQCnamesNew = [&quot;File&quot;, dataQCnames];

% Save the data as a table for ease of use in subsequent steps
qcTable = cell2table(dataQCNew, &#39;VariableNames&#39;, dataQCnamesNew);

% Subset to ID and threshold information
testInfo = qcTable(:, [&quot;idWave&quot;, &quot;File&quot;, &quot;Test&quot;]);</code></pre></li>
<li><p>Identify the files that meet (or don’t meet) the threshold</p>
<pre><code>% Create a list of files (i.e., rows in the table) that meet threshold
thresholdTest = qcTable.(&quot;Number_cNG++_Segs_Post-Seg_Rej&quot;) &gt;= trialCutoff &amp; qcTable.(&quot;Number_cGo++_Segs_Post-Seg_Rej&quot;) &gt;= trialCutoff;

% Add a variable to the quality data table that include whether or not the file meet threshold
qcTable.Test = thresholdTest;</code></pre></li>
<li><p>Add an identifying variable to be used for data joining down the
line</p>
<ul>
<li>This variable is generated using its expected location in the file
name (i.e., how many text characters “in” it is)</li>
</ul>
<pre><code>% Generate IDs based on File variable
idWaveQC = extractBefore(qcTable.File, 8);

% Append ID variable to quality data
qcTable.idWave = idWaveQC;</code></pre></li>
<li><p>Create a subsetted dataset conataining only the
<code>idWave</code>, file name, and “test” results (i.e., whether a
given file meets the specified cutoff threshold for inclusion)</p>
<pre><code>% Subset to ID and threshold information
testInfo = qcTable(:, [&quot;idWave&quot;, &quot;File&quot;, &quot;Test&quot;]);

fprintf(&#39;Assessment Complete \n&#39;);</code></pre></li>
<li><p>Generate a list of files outputted by HAPPE</p>
<pre><code>% Generate path for HAPPE pre-processing output (using the HAPPE environment variable from user&#39;s input of location of raw data for processing)
inputPath = strcat(srcDir, &quot;\5 - processed&quot;);

% Read in list of files outputted from HAPPE 
preprocessingOutput = dir(inputPath);

% Remove &quot;empty&quot; rows 
preprocessingOutput = preprocessingOutput(~ismember({preprocessingOutput.name}, {&#39;.&#39;, &#39;..&#39;}));

% Save data as a table for ease of later use
preprocessingOutput = struct2table(preprocessingOutput);

% Subset to file info
fileInfo = preprocessingOutput(:, [&quot;name&quot;, &quot;folder&quot;]);</code></pre></li>
<li><p>Select only desired files to be moved/copied</p>
<ul>
<li>Currently, we don’t do anything with the “Individual Trial” files
outputted by HAPPE. These files are quite large and take a long time to
move, so it is more efficient to just remove them from the data and not
worry about moving them anywhere.</li>
</ul>
<pre><code>% Subset to desired files (AveOverTrial)
fileSubset = fileInfo(contains(fileInfo.name, &quot;AveOverTrials&quot;), :);</code></pre></li>
<li><p>Add condition, ID, and threshold-related variables to the file
data</p>
<ul>
<li>NOTE: The value for <code>Condition</code> variable (i.e., “cGo” or
“cNoGo”) should match the name of the condition-specific folders you
wish the files to save to within the processing repo.</li>
</ul>
<pre><code>% Generate list of IDs based on file name variable
idWaveFS = extractBefore(fileSubset.name, 8);

% Add ID list to file data
fileSubset.idWave = idWaveFS;

% Generate list of files belonging to each condition based on file name variable
cGo = contains(fileSubset.name, &quot;cGo++&quot;);
cNoGo = contains(fileSubset.name, &quot;cNG++&quot;);
xGo = contains(fileSubset.name, &quot;xGo++&quot;);
xNoGo = contains(fileSubset.name, &quot;xNG++&quot;);

% Create empty variable for condition
fileSubset.cond = cell(size(fileSubset, 1), 1);

% Fill in condition variable based on the lists generated above
fileSubset.cond(cGo) = {&#39;cGo&#39;};
fileSubset.cond(cNoGo) = {&#39;cNoGo&#39;};
fileSubset.cond(xGo) = {&#39;xGo&#39;};
fileSubset.cond(xNoGo) = {&#39;xNoGo&#39;};
fileSubset.cond(~cGo &amp; ~cNoGo &amp; ~xGo &amp; ~xNoGo) = {&#39;All&#39;};

% Join threshold test information
fileTest = join(fileSubset, testInfo);</code></pre></li>
<li><p>Prepare data table with information about files that met the
threshold</p>
<ul>
<li>The data generated here are preparing to copy the .txt files
outputted by HAPPE into a folder containing all files that are suitable
for PCA</li>
</ul>
<pre><code>% Create a separate table for only files that meet threshold
movingInfo = fileTest(fileTest.Test, :);

% Create empty columns for filepath variables
movingInfo.destination = cell(size(movingInfo, 1), 1);
movingInfo.origin = cell(size(movingInfo, 1), 1);
movingInfo.processedTo = cell(size(movingInfo, 1), 1);
movingInfo.processedFrom = cell(size(movingInfo, 1), 1);

% Generate file paths based on condition 
movingInfo.destination = strcat({passPath}, &quot;\&quot;, movingInfo.cond, &quot;\&quot;, movingInfo.name);
movingInfo.origin = strcat(movingInfo.folder, &quot;\&quot;, movingInfo.name);
movingInfo.processedTo = strcat({allPath}, &quot;\&quot;, movingInfo.name);
movingInfo.processedFrom = strcat(movingInfo.folder, &quot;\&quot;, movingInfo.name);</code></pre></li>
<li><p>Prepare data table with information about files that do NOT meet
the threshold</p>
<ul>
<li>The data generated here are preparing to copy .mff files from the
location of the raw files into a folder indicating the need for manual
processing</li>
</ul>
<pre><code>% Create a separate table for only files that did not meet threshold
failFiles = fileTest(~fileTest.Test, [&quot;File&quot;, &quot;folder&quot;, &quot;name&quot;]);

% Create empty columns for filepath variables
failFiles.destination = cell(size(failFiles, 1), 1);
failFiles.origin = cell(size(failFiles, 1), 1);
failFiles.processedTo = cell(size(failFiles, 1), 1);
failFiles.processedFrom = cell(size(failFiles, 1), 1);

% Generate filepaths based on ID and task
failFiles.destination = strcat({failPath}, &quot;\&quot;, failFiles.File);
failFiles.origin = strcat({srcDir}, &quot;\&quot;, failFiles.File);
failFiles.processedFrom = strcat(failFiles.folder, &quot;\&quot;, failFiles.name);
failFiles.processedTo = strcat({allPath}, &quot;\&quot;, failFiles.name);
</code></pre></li>
<li><p>Generate environment variables that correspond to the column
index of relevant variables for file sorting</p>
<ul>
<li>Note that the very last line of this code defines the varaible(s) to
exclude from the HAPPE outputted files. This variable must be stripped
from the data before saving them, because the presence of the extra
variable makes the file incompatible with EP Toolkit’s PCA process.</li>
</ul>
<pre><code>% Define column locations for each filepath variable

% For files that meet threshold:
toCol = find(strcmp(movingInfo.Properties.VariableNames, &quot;destination&quot;));
fromCol = find(strcmp(movingInfo.Properties.VariableNames, &quot;origin&quot;));
procColto = find(strcmp(movingInfo.Properties.VariableNames, &quot;processedTo&quot;));
procColfrom = find(strcmp(movingInfo.Properties.VariableNames, &quot;processedFrom&quot;));

% For files that do not meet threshold
rawCol = find(strcmp(failFiles.Properties.VariableNames, &quot;origin&quot;));
manCol = find(strcmp(failFiles.Properties.VariableNames, &quot;destination&quot;));
failProcColto = find(strcmp(failFiles.Properties.VariableNames, &quot;processedTo&quot;));
failProcColFrom = find(strcmp(failFiles.Properties.VariableNames, &quot;processedFrom&quot;));

% Define variable to exclude
extraVar = &#39;Time&#39;;</code></pre></li>
<li><p>Use a loop to process all files that met threshold</p>
<ul>
<li>For each row in the “movingInfo” dataset, the loop will:
<ul>
<li>Identify the origin and destination paths</li>
<li>Read in the HAPPE output file</li>
<li>Remove the extra variable</li>
<li>Save the “cleaned” data in the appropriate folder (without variable
names, as required by EP Toolkit)</li>
</ul></li>
</ul>
<pre><code>for row = 1:height(movingInfo)
    % Specify path info
    pathFrom = movingInfo{row, fromCol};
    pathTo = movingInfo{row, toCol};
    % Read in the data
    rawTable = readtable(pathFrom);
    % Remove extra column (Time)
    cleanTable = rawTable{:, ~strcmp(rawTable.Properties.VariableNames, extraVar)};
    % Save without headers
    writematrix(cleanTable, pathTo, &#39;Delimiter&#39;, &#39;\t&#39;)
end
</code></pre></li>
<li><p>Use a loop to copy raw (.mff) files into a location that stores
files requiring manual processing</p>
<pre><code>for row = 1:height(failFiles)
    % Specify path info
    pathFrom = failFiles{row, rawCol};
    pathTo = failFiles{row, manCol};
    % Copy file 
    copyfile(pathFrom, pathTo)
end</code></pre></li>
<li><p>Use a set of loops to copy all HAPPE output files into a folder
intended to house all output (whether threshold is met or not)</p>
<pre><code>for row = 1:height(movingInfo)
    % Specify path info
    pathFrom = movingInfo{row, procColfrom};
    pathTo = movingInfo{row, procColto};
    % Copy file
    copyfile(pathFrom, pathTo);
end

for row = 1:height(failFiles)
    % Specify path info
    pathFrom = failFiles{row, failProcColFrom};
    pathTo = failFiles{row, failProcColto};
    % Copy file
    copyfile(pathFrom, pathTo);
end</code></pre></li>
<li><p>Generate a .txt file listing all processed .mff files</p>
<ul>
<li>This file will contain a list of all raw files (e.g.,
<code>1111_22_fishshark.mff</code>) and save the list to the specified
location (“summPath”)</li>
<li>The file will have the current date and time appended to the end so
that it will be distinguishable from past logs</li>
<li>The list of processed files is generated using an environment
variable that the HAPPE pipeline creates that lists all files inputted
to the pipeline</li>
</ul>
<pre><code>% Create a table from HAPPE FileNames cell array
processedList = cell2table(FileNames(:));

% Rename file variable from default
processedList = renamevars(processedList, {&#39;Var1&#39;}, {&#39;File&#39;});

% Save current date as a string variable 
today = string(date());

% Save time as a string variable, replacing &quot;:&quot; with &quot;_&quot; so that file can be written 
time = strrep(datestr(now, &#39;HH:MM:SS:FFF&#39;), &#39;:&#39;, &quot;_&quot;);

% Generate file name to include current date and time 
listFile = strcat(&quot;\oddballProcessed_&quot;, today, &quot;_&quot;, time);

% Generate full path including file name
summPathFull = strcat(summPath, listFile);

% Write table to specified location
writetable(processedList, summPathFull);</code></pre></li>
</ol>
</div>
</div>
<div id="stop-signal-processing-pipeline" class="section level2"
number="1.5">
<h2><span class="header-section-number">1.5</span> Stop-Signal
Processing Pipeline</h2>
</div>
</div>
<div id="eptPCA" class="section level1" number="2">
<h1><span class="header-section-number">2</span> ERP PCA (EP)
Toolkit</h1>
<div id="average" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Reading Text Files
into EP Toolkit</h2>
<ol style="list-style-type: decimal">
<li>Open MATLAB with “Run as Administrator”</li>
<li>Open ERP PCA Toolkit in MATLAB
<ul>
<li>Type <code>ep</code> in command prompt</li>
</ul></li>
<li>Click <code>Read</code> to import files</li>
<li>Use the following options
<ul>
<li>Format = <code>text (.txt)</code></li>
<li>Type = <code>average</code></li>
<li>Mont = <code>Adult Hydrocel 128-channel 1.0</code></li>
</ul></li>
<li>Select <code>Single File Mode</code>.
<ul>
<li>Single file mode will use the filename to assign the task condition
and participant ID for each file. Thus, <strong>it is critical to use a
standard naming convention to name the files</strong>.
<ul>
<li>For example, an oddball file could be named:
<code>1001_36_oddball_processed_AveOverTrials_tgt+.txt</code></li>
<li>A FishSharks file meanwhile could be named:
<code>1004_36_oddball_processed_AveOverTrials_cGo++.txt</code></li>
<li><em>Note: The filename examples above reflect the automated naming
convention of the files outputted by the HAPPE pipeline.</em> <em>If
another processing pipeline is used or if the naming conventions become
unstandardized, it is <strong>crucial</strong> that standardization of
filenames is implemented</em></li>
</ul></li>
</ul></li>
<li>In the <code>Single File Mode</code> menu use the
<code>Subject</code> field to denote which characters in the filename
name will determine the participant ID.
<ul>
<li>For the above example <code>1:7</code> would correspond to
<code>1001_36</code> in a file called
<code>1001_36_oddball_processed_AveOverTrials_tgt+.txt</code> (outputted
by HAPPE)</li>
</ul></li>
<li>Next, In the <code>Single File Mode</code> menu use the
<code>Cell</code> field to denote which characters in the file name will
determine the task condition.
<ul>
<li>For the below example <code>41:43</code> would correspond to
<code>frq</code> or <code>tgt</code> in a file called
<code>1001_36_oddball_processed_AveOverTrials_tgt+.txt</code></li>
<li>For FishSharks files, it might be <code>47:49</code> that correspond
to <code>cgo</code> or <code>cng</code>.</li>
<li><div class="float">
<img src="images/readTextFile2024.png" alt="image" />
<div class="figcaption">image</div>
</div></li>
</ul></li>
<li>Select <code>Read</code>. You will be asked to name the aggregate
file created by importing and combining the single files. Use the
convention “task_condition_age” to name the file (e.g.,
<code>ob_tgt_54</code>)</li>
<li>A new window will open prompting you to select the files you wish to
import. Navigate to the folder housing the data to be imported (e.g.,
<code>3 - Files for PCA\Target</code>) and use <code>Ctrl + A</code> to
select all files in that folder. Click <code>Open</code> once all
desired files are selected</li>
<li>Select the <code>2_9AverageNet128.ced</code> file when prompted by
another popup. This file corresponds to the electrode template
associated with the participant age range and type of net represented in
the data
<ul>
<li>For our study using a 128-channel net on children aged 3-7, the
<code>2_9AverageNet128.ced</code> template is most appropriate <img
src="images/netTemplateFile.png" alt="image" /></li>
</ul></li>
<li>The new file will have the participant ID and will combine the
conditions for each participant.
<ul>
<li>Subject Names:
<ul>
<li><div class="float">
<img src="images/subjectCombinedNames.png" alt="image" />
<div class="figcaption">image</div>
</div></li>
</ul></li>
<li>Task Conditions
<ul>
<li><div class="float">
<img src="images/conditionCombinedNames.png" alt="image" />
<div class="figcaption">image</div>
</div></li>
</ul></li>
</ul></li>
</ol>
</div>
<div id="update-file-with-experiment-information" class="section level2"
number="2.2">
<h2><span class="header-section-number">2.2</span> Update File with
Experiment Information</h2>
<ol style="list-style-type: decimal">
<li>Go to <code>Main</code> and click <code>Edit</code></li>
<li>Click on the file you imported</li>
<li>In <code>Overview</code>, add the following information:
<ul>
<li>Experiment Name: <code>Oddball</code>, <code>FishShark</code>, or
<code>StopSignal</code></li>
<li>Reference Type: change to <code>average reference</code></li>
<li>Prestimulus period: change to <code>200</code></li>
<li>Nominal sampling rate: change to <code>1000</code></li>
</ul></li>
<li>Click <code>Done</code></li>
<li>Go to <code>Main</code> and click <code>Save</code>
<ul>
<li>Save the combined file as an <code>.ept</code> file in the
<code>4-EPT Averages</code> folder using the following naming
convention: “task_condition_age”. For example, if you were working on
the target condition of oddball for all age groups, you would save the
file as <code>ob_tgt_all</code></li>
</ul></li>
</ol>
</div>
<div id="generating-grand-average-waveforms" class="section level2"
number="2.3">
<h2><span class="header-section-number">2.3</span> Generating Grand
Average Waveforms</h2>
<ol style="list-style-type: decimal">
<li>If the EPT average file (e.g., <code>ob_tgt_all</code>) is not
already in the working environment, read it in using the steps below
<ul>
<li>Go to <code>Read</code></li>
<li>Format = <code>EP (.ept)</code></li>
<li>Click <code>Read</code></li>
<li>Navigate to the <code>4 - EPT Averages</code> folder and select
desired file(s)</li>
<li>Click <code>Open</code> in the browser window to read the
file(s)</li>
<li>Click <code>Main</code> to return to main menu</li>
</ul></li>
<li>Select <code>Edit</code></li>
<li>When the editor window opens, navigate to the <code>Subjects</code>
pane</li>
<li>Select <code>All</code> from among the many options along the
lefthand pane of the editor
<ul>
<li>This will select all of the subjects included in the file and assign
them a weight of 1</li>
</ul></li>
<li>Confirm that all subjects have been selected (look for a checked box
in the subject row) and that all weights have been set to 1</li>
<li>Click <code>Add</code></li>
<li>A new “subject” should have now been added to the bottom of the
subjects list
<ul>
<li>This subject is called <code>gave</code> and represents the grand
average across all subjects</li>
</ul></li>
<li>Click <code>Done</code> to exit the editor window, then
<code>Main</code> to return to the EP Toolkit home</li>
</ol>
</div>
<div id="tPCA" class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> Temporal PCA</h2>
<ol style="list-style-type: decimal">
<li>Go to <code>Main</code> and click <code>PCA</code></li>
<li>Input the following:
<ul>
<li>Mode: <code>temporal</code></li>
<li>Rotation: <code>promax</code></li>
<li>Factors: <code>0</code></li>
<li>Title: tPCA_experimentname (example:
<code>tPCA_ob_tgt_all</code>)</li>
</ul></li>
<li>Click the appropriate file (e.g., <code>ob_tgt_all</code>)</li>
<li>Determine how many factors to retain using the scree plot (keep the
number of factors where the blue line is above the red line)</li>
<li>Determine the percent variance accounted for by the number of
factors retained by changing the “minimum % age accounted for
criterion”. Record the number of factors retained and % variance
accounted for by that number of factors.</li>
<li>Re-run the temporal PCA using the above inputs, <strong>but change
the number of factors to the number of factors retained from the above
step</strong></li>
<li>Return to <code>Main</code> and click <code>Save</code>. Save the
tPCA file in the <code>5-PCA</code> folder</li>
</ol>
</div>
<div id="spatial-pca" class="section level2" number="2.5">
<h2><span class="header-section-number">2.5</span> Spatial PCA</h2>
<ol style="list-style-type: decimal">
<li>Go to <code>Main</code> and click <code>PCA</code></li>
<li>Change the PCA type, using the following inputs:
<ul>
<li>Mode: <code>spatial</code></li>
<li>Rotation: <code>infomax</code></li>
<li>Factors: <code>0</code></li>
<li>Title: sPCA_experimentname (e.g., <code>sPCA_ob_tgt_all</code>)</li>
</ul></li>
<li>Click the appropriate file (e.g., <code>ob_tgt_all</code>)</li>
<li>Determine how many factors to retain using the scree plot (keep the
number of factors where the blue line is above the red line)</li>
<li>Determine the percent variance accounted for by the number of
factors retained by changing the “minimum % age accounted for
criterion”. Record the number of factors retained and % variance
accounted for by that number of factors.</li>
<li>Re-run the spatial PCA using the above inputs, <strong>but change
the number of factors to the number of factors retained from the above
step</strong></li>
<li>Return to <code>Main</code> and click <code>Save</code>. Save the
sPCA file in the <code>5-PCA</code> folder</li>
</ol>
</div>
<div id="temporospatial-pca" class="section level2" number="2.6">
<h2><span class="header-section-number">2.6</span> Temporospatial
PCA</h2>
<ol style="list-style-type: decimal">
<li>Go to <code>Main</code> and click <code>PCA</code></li>
<li>Change the PCA type, using the following inputs:
<ul>
<li>Mode: <code>spatial</code></li>
<li>Rotation: <code>infomax</code></li>
<li>Factors: <code>0</code></li>
<li>Title: tsPCA_experimentname (e.g.,
<code>tsPCA_ob_tgt_all</code>)</li>
</ul></li>
<li>Click the <code>tPCA</code> file (created in the previous step)</li>
<li>Determine how many factors to retain using the scree plot (keep the
number of factors where the blue line is above the red line)</li>
<li>Determine the percent variance accounted for by the number of
factors retained by changing the “minimum % age accounted for
criterion”. Record the number of factors retained and % variance
accounted for by that number of factors.</li>
<li>Re-run the spatial PCA using the above inputs, <strong>but change
the number of factors to the number of factors retained from the above
step</strong></li>
<li>Return to <code>Main</code> and click <code>Save</code>. Save the
tsPCA file in the <code>5-PCA</code> folder.</li>
</ol>
</div>
<div id="extract" class="section level2" number="2.7">
<h2><span class="header-section-number">2.7</span> PCA Component
Selection and Extraction</h2>
<p>Here, the goal is to select the PCA component that corresponds to the
ERP component of interest, and the extraction that supports the intended
interpretability of the component.</p>
<ol style="list-style-type: decimal">
<li>Go to <code>View</code> to begin the process of selecting the PCA
component that corresponds to the ERP of interest.
<ul>
<li>Iteratively select and view each temporospatial PCA component to
identify the PCA component (“factor”) that corresponds to the ERP of
interest (e.g., N2 or P3). Select the temporospatial PCA component that
corresponds to the ERP of interest based on the timing, spatial
location, morphology, and (as relevant) any condition- or age-related
differences of the component based on prior work.</li>
</ul></li>
<li>Generate tsPCA components. Go to <code>Window</code> and input the
following:
<ul>
<li>select the tsPCA file</li>
<li>select among <code>mean</code>, <code>maxPeak</code>, or other
options. (According to Joe Dien), when using amplitudes from PCA
components, it does not matter which option you select—all the different
methods result in comparable <em>p</em>-values when dealing with PCA
components. So, select a method that makes sense for the story you want
to tell. The methods will yield different results when dealing with the
raw waveforms.</li>
<li>select <code>AutoPCA</code> or <code>Window</code> to select
channels. If the peak amplitude is where you expect temporally and
spatially, then use the autoPCA function, and if it is not, then window
to where you expect it to be. This will allow you to report results that
are more interpretable. As Joe Dien described, the way that PCA data are
stored internally in the toolkit are as factor scores (i.e., component
scores). When you extract amplitudes from a PCA component, you are
extracting the factor scores multiplied by a constant (some scaling
factor, representing the electrode where you extract it from). Thus,
according to Joe Dien, the <em>p</em>-values should be the same
regardless of whether you use AutoPCA, or extract from a single
electrode or multiple electrodes (it would be good to verify this). What
is changing is merely the scaling factor (i.e., the constant that is
multiplied by all factor scores). When you select multiple electrodes,
it is computing the PCA-estimated amplitude at each electrode and
performing a simple average across those electrodes. The AutoPCA
extracts the PCA-estimated amplitude at the peak channel and the peak
timepoint. If the waveform is negative-going at the peak channel, and
you are interested in the positive-going dipole, you would select the
peak positive channel to identify the PCA-estimated amplitude of the
positive-going waveform on that PCA component. Nevertheless, even though
you are selecting the PCA-estimated amplitude for a given channel at a
given electrode, there are now “virtual channels”; the estimates include
the contributions of all channels and all timepoints <u>to the extent
that</u> they load onto the PCA component of interest. Thus, even if you
select to window a PCA component from only 1 channel at 1 timepoint, it
is using ALL channels and timepoints in the estimation—this is not the
case if windowing the raw ERP waveforms.</li>
<li>Save the files generated from the AutoPCA in the
<code>6 - PCA Components</code> folder using the following naming
convention: “erp_task_condition_age_component”
(e.g.,<code>erp_ob_tgt_all_P3</code>).</li>
</ul></li>
<li>To view all of the tsPCA components, click <code>View</code> and
input the following
<ul>
<li>select the appropriate file (e.g., <code>ob_tgt_all</code>)</li>
<li>select <code>gave</code></li>
<li>select <code>none</code></li>
<li>click <code>Waves</code></li>
</ul></li>
<li>It is good practice to check to make sure that components are
comparable across different age ranges
<ul>
<li>You can check this in one of two ways:
<ul>
<li>Visually examine grand averages between age ranges</li>
<li>Apply the PCA from one age group and apply it to another age group
and examine whether the results hold up using cross-validation in
EPToolkit</li>
</ul></li>
</ul></li>
<li>It is generally useful to keep track of the extraction process for
each PCA component. Our current procedure for doing so is keeping a
<code>PCA_ComponentInfo.txt</code> file in the
<code>6-PCA Components</code> folder.
<ul>
<li>Relevant information may include the timing used to window a
component and the electrodes that load onto the component of interest at
a given threshold</li>
</ul></li>
</ol>
</div>
<div id="identifying-electrodes-that-load-onto-pca-component"
class="section level2" number="2.8">
<h2><span class="header-section-number">2.8</span> Identifying
Electrodes that Load Onto PCA Component</h2>
<ol style="list-style-type: decimal">
<li>Go to <code>Window</code></li>
<li>Select the PCA file of interest (e.g.,
<code>tsPCA_ob_tgt_all</code>)</li>
<li>Click the <code>Channels</code> button (about halfway down the
<code>Window</code> window)</li>
<li>Click <code>Factor</code>
<ul>
<li>From the dropdown, select the PCA file of interest (e.g.,
<code>tsPCA_ob_tgt_all</code>)</li>
<li>Enter the threshold in the space below (e.g., 0.5)
<ul>
<li>This sets the minumum factor loading value for an electrode to be
“included” in the component-related cluster</li>
</ul></li>
<li>Depending on whenther you are interested in positive or negative
factor loadings, select the appropriate sign (<code>+</code>,
<code>-</code>, or <code>+/-</code>)</li>
<li>A popup window with PCA factors will appear. Select the component(s)
you wish to identify spatially (e.g., <code>TF01SF01</code>)</li>
</ul></li>
<li>When prompted, give the electrode cluster a name</li>
<li>The channels that change color are those which load onto the
selected component at or above the threshold value</li>
</ol>
</div>
<div id="exporting-grand-average-data" class="section level2"
number="2.9">
<h2><span class="header-section-number">2.9</span> Exporting Grand
Average Data</h2>
<p>If you are only interested in the grand average data and not
individual subjects, these instructions will allow you to export a .txt
file containing only the grand average data.</p>
<ol style="list-style-type: decimal">
<li>From EP Toolkit home (<code>Main</code> screen), select
<code>Edit</code></li>
<li>Select the .ept averages file (e.g., <code>ob_tgt_all</code>) that
contains a “subject” representing the grand average
<ul>
<li>If the file does NOT contain a grand average subject, follow the
steps in the above section to generate it</li>
</ul></li>
<li>Rename the file
<ul>
<li>For example, <code>ob_tgt_all</code> could be renamed to
<code>ob_tgt_gav</code></li>
<li>Renaming the file will prompt EP Toolkit to ask whether you want to
generate a new file with this new name, or overwrite the existing
datafile once your changes are complete</li>
</ul></li>
<li>Select <code>Subjects</code> from the options at the top of the
editor window</li>
<li>Click <code>All</code> from among the options on the lefthand side
of the <code>Subjects</code> window
<ul>
<li>This will select all of the subjects</li>
</ul></li>
<li>Scroll to the bottom of the list of subjects and
<strong>deselect</strong> the subject labeled <code>grand average</code>
<ul>
<li>Essentially, the goal here is to create a dataset that includes ONLY
the grand average information, rather than each individual subject</li>
</ul></li>
<li>Once everything EXCEPT for the grand average subject is selected,
click <code>Delete</code> on the lefthand side of the editor window
<ul>
<li>This will remove the individual subject data from the dataset and
leave the grand average information</li>
</ul></li>
<li>Click <code>Done</code></li>
<li>If you renamed the datafile, EP Toolkit should generate a popup
message asking whether you would like to rename your dataset OR generate
a new dataset using the new name (leaving the original dataset
untouched). From the options presented, click <code>New</code> to
generate a new file and preserve the original</li>
<li>The editor window should close, returning you to the EP Toolkit pane
that asks you to select a dataset to edit. From here, click
<code>Main</code> to return to EP Toolkit “home”</li>
<li>Once in the main window, click <code>Save</code>
<ul>
<li>Set the save format to <code>Text (.txt)</code></li>
<li>Click the grand average data (e.g., <code>ob_tgt_gav</code>) to save
it</li>
<li>A file explorer window should open, prompting you to select the
appropriate save location and give your file a name</li>
</ul></li>
</ol>
</div>
</div>
<div id="generating-erp-composite-datafiles" class="section level1"
number="3">
<h1><span class="header-section-number">3</span> Generating ERP
Composite Datafiles</h1>
<ol style="list-style-type: decimal">
<li>Save a copy of all extracted PCA component files (e.g.,
<code>erp_ob_tgt_all_P3</code>) in the following location on the Lab
Drive: <code>[...]/Data/LV2/PCA Components</code> under the appropriate
task (i.e., Oddball, Fishshark, or Stop Signal)</li>
<li>Use the following R Code to combine all components into a single
composites datafile. The following example is taken from the
<code>erpOddball.R</code> composite script located in
<code>[...]Data Processing/3. Composites</code> and available via Git <a
href="https://research-git.uiowa.edu/PetersenLab/SRS/SRS-DataProcessing/-/blob/master/3.%20Composites/erpOddball.R">here</a>.
Comparable scripts have also been created for FishShark and Stop Signal
tasks.
<ol style="list-style-type: decimal">
<li><p>Create a list of all PCA component files in the specified
directory. This list will contain the full filepaths to each component
file which are used to read the data into R.</p>
<pre class="r fold-show"><code>oddballFilePaths &lt;- list.files(
 path = &quot;Z:/Shared Server/Study Folder/Data/LV2/ERP/PCA Components/Oddball&quot;, 
 pattern = &quot;*.txt&quot;,
 recursive = FALSE,
 full.names = TRUE)</code></pre></li>
<li><p>Generate a list of the names of each PCA component file in the
specified directory. This list will be used to rename columns in the
final composite dataset according to the name of the component file. For
this reason, the naming convention of each component files is crucial;
this will determine how the corresponding column of the composite
datafile is named.</p>
<pre class="r fold-show"><code>oddballFiles &lt;- list.files(
 path = &quot;Z:/Shared Server/Study Folder/Data/LV2/ERP/PCA Components/Oddball&quot;,
 pattern = &quot;*.txt&quot;,
 recursive = FALSE)</code></pre></li>
<li><p>Read in each component file, skipping the rows containing summary
information about the extracted component (the first 7 rows in this
example).</p>
<pre class="r fold-show"><code>oddballData &lt;- lapply(oddballFilePaths, function(x) read_delim(x, delim = &quot;\t&quot;, skip = 7)) </code></pre></li>
<li><p>“Clean” the list of component file names by removing the file
extension (in this case, <code>.txt</code>).</p>
<pre class="r fold-show"><code>componentNames &lt;- oddballFiles %&gt;% str_remove(&quot;.txt&quot;)</code></pre></li>
<li><p>Give <code>ID</code> variable a proper name.</p>
<pre class="r fold-show"><code>oddballData &lt;- lapply(oddballData, function(x){
 names(x)[length(names(x))] &lt;- &quot;ID&quot;
 return(x)
 })</code></pre></li>
<li><p>At this stage, the ERP component data are nested within a list of
separate data objects. We must therefore merge them into a single
dataframe object.</p>
<pre class="r fold-show"><code>oddballDataMerged &lt;- oddballData %&gt;%
   reduce(full_join, by = c(&quot;ID&quot;))</code></pre></li>
<li><p>Organize the combined data. The code below performs the following
operations (in order of appearance):</p>
<ul>
<li>Create <code>tcid</code> variable by extracting the first four
characters of existing <code>ID</code> variable</li>
<li>Create <code>wave</code> variable by extracting the 6th and 7th
characters of existing <code>ID</code> variable</li>
<li>Re-order the data so that <code>tcid</code> and <code>wave</code>
appear as the first two columns while all other columns retain their
order in the dataset</li>
<li>Remove the <code>ID</code> variable now that it has been separated
into <code>tcid</code> and <code>wave</code></li>
<li>Convert all values to numeric</li>
</ul>
<pre class="r fold-show"><code>oddballDataClean &lt;- oddballDataMerged %&gt;%
   mutate(tcid = substr(ID, 1, 4),
          wave = substr(ID, 6, 7)) %&gt;%
   select(tcid, wave, everything()) %&gt;%
   select(-ID) %&gt;% 
   type_convert()</code></pre></li>
<li><p>Update column names of merged data according to the list of PCA
component files.</p>
<pre class="r fold-show"><code>names(oddballDataClean) &lt;- c(&quot;tcid&quot;, &quot;wave&quot;, componentNames)</code></pre></li>
<li><p>Save composite data to desired location.</p>
<pre class="r fold-show"><code>write_csv(oddballDataClean, file = &quot;Z:/Shared Server/Study Folder/Data/REDCap/Composites/erpOddball.csv&quot;)</code></pre></li>
</ol></li>
</ol>
</div>
<div id="visualizations-in-r" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Visualizations in
R</h1>
<div id="r-code-for-grand-average-waveform-plot" class="section level2"
number="4.1">
<h2><span class="header-section-number">4.1</span> R Code for Grand
Average Waveform Plot</h2>
<ol style="list-style-type: decimal">
<li><p>Read in the grand average waveform data exported from EP
Toolkit.</p>
<ul>
<li>We currently process the conditions within a given task separately,
so each condition should have its own grand average file.</li>
</ul>
<pre class="r fold-show"><code>obTgt &lt;- read.table(&quot;V:/SRS-ERP-Oddball/Hard/All/4 - EPT Averages/2024-11-05/gave/ob_tgt_gav.txt&quot;)
obFrq &lt;- read.table(&quot;V:/SRS-ERP-Oddball/Hard/All/4 - EPT Averages/2024-11-05/gave/ob_frq_gav.txt&quot;)</code></pre></li>
<li><p>Create a subset of data that only includes those electrodes that
are part of the clusters identified in EP Toolkit.</p>
<ul>
<li>The grand average data does not have row or column labels, but the
columns represent the EEG net channels in numerical order (1-129). We
can therefore use their column index values to select the desired
electrodes; so, the list containing the channel numbers should include
ONLY numbers. The code that selects these channels out of the full
dataset will rely on numerical input.</li>
</ul>
<pre class="r fold-show"><code># Set electrode clusters
obElectrodes &lt;- c(58, 59, 64, 65, 66, 67, 69, 70, 71, 72, 73, 74, 75, 76, 77, 81, 82, 83, 84, 89, 80, 91, 95, 96, 101)

# Subset to desired electrodes
obTgt_sub &lt;- obTgt[, obElectrodes]
obFrq_sub &lt;- obFrq[, obElectrodes]</code></pre></li>
<li><p>Compute averages and create labels for conditions</p>
<ul>
<li>Once the data have been subsetted down to include only the electrode
channels of interest, all that remains is to compute the average
amplitude across all of those channels</li>
<li>Adding a condition label will allow us to combine the two
condition-specific datasets into one that can be used for visualizations
<ul>
<li>For ease of plotting, name the conditions the way that you would
like them to appear on the figure (i.e., “Target” instead of “tgt”)</li>
</ul></li>
</ul>
<pre class="r fold-show"><code># Compute averages 
obTgt_sub$amplitude &lt;- rowMeans(obTgt_sub)
obFrq_sub$amplitude &lt;- rowMeans(obFrq_sub)

# Remove raw values and add condition labels
obTgt_amps &lt;- obTgt_sub %&gt;% select(amplitude) %&gt;% mutate(condition = &quot;Target&quot;)
obFrq_amps &lt;- obFrq_sub %&gt;% select(amplitude) %&gt;% mutate(condition = &quot;Frequent&quot;)</code></pre></li>
<li><p>Add timing-related information to the data</p>
<ul>
<li>EP Toolkit exports ERP data without timestamps, but arranges it in
order of timing</li>
<li>We can create a template with the appropriate timestamps and append
this column to the amplitude data</li>
</ul>
<pre class="r fold-show"><code># Create template
erpTemplate &lt;- data.frame(
  time = -199:1000
)

# Merge template with amplitude data
obTgtTimes &lt;- cbind(erpTemplate, obTgt_amps)
obFrqTimes &lt;- cbind(erpTemplate, obFrq_amps)</code></pre></li>
<li><p>Combine all conditions into a single data object to be used for
plotting</p>
<pre class="r fold-show"><code>oddball &lt;- rbind(obTgtTimes, obFrqTimes) %&gt;% 
           select(time, condition, amplitude) %&gt;% 
           arrange(time)</code></pre></li>
<li><p>Generate the waveform figures</p>
<pre class="r fold-show"><code>ggplot(
  data = oddball,
  aes(
    x = time,
    y = amplitude,
    group = condition,
    color = condition
  )
) +
  geom_line(linewidth = 1.5) +
  scale_x_continuous(
    name = &quot;Time Relative to Stimulus Onset (ms)&quot;,
    limits = c(-200, 1000),
    breaks = seq(from = -200, to = 1000, by = 200)) +
  scale_y_continuous(
    name = &quot;Voltage (microvolts)&quot;,
    limits = c(-4, 10),
    breaks = seq(from = -10, to = 15, by = 2)) +
  scale_color_viridis_d()+
  theme_classic(base_size = 18) +
  theme(
    legend.position = c(.7, .9),
    legend.title = element_blank())</code></pre></li>
</ol>
</div>
</div>
<div id="appendix" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Appendix</h1>
<div id="troubleshooting" class="section level2" number="5.1">
<h2><span class="header-section-number">5.1</span> Troubleshooting</h2>
<ol style="list-style-type: decimal">
<li>Running out of space on EP Toolkit? You can navigate to your folder
(maybe under Documents/MATLAB/EPwork) and delete everything except for
EPprefs to refresh your workspace. NOTE: This will delete everything
stored in EP Toolkit, so remember to back up files that you need to
save.</li>
<li>If you get an error or a warning from Git when trying to commit
and/or push ERP files up to the repo, you may need to initialize Git
LFS. The instructions for initializing Git LFS can be found <a
href="https://devpsylab.github.io/DataAnalysis/git.html#gitLfs">here</a>.
<ul>
<li>The filetypes that commonly cause such errors in our current ERP
processing pipeline are:
<ul>
<li><code>.txt</code> files</li>
<li><code>.ept</code> files</li>
<li><code>.set</code> files</li>
</ul></li>
</ul></li>
</ol>
</div>
<div id="to-do" class="section level2" number="5.2">
<h2><span class="header-section-number">5.2</span> To-do</h2>
<ul>
<li>Better describe the missingness for files
<ul>
<li>We need a systematic way to identify new ways to process the
missingness</li>
<li>Find a way to best describe and report the ways of missingness</li>
</ul></li>
<li>Go through the maxmem edits on the clean_rawData question. We want a
standardized value on the machines</li>
<li>Look at the warning messages for the automatic script updates
<ul>
<li>automatic cleaning of files problems</li>
</ul></li>
<li>Integrate ERPLAB with our existing EEGLab Functions including:
<ul>
<li>Adding an event list:
<ul>
<li>Currently, some code for this is updated in the script on the lab
drive</li>
<li>Documentation is <a
href="https://github.com/lucklab/erplab/wiki/Creating-an-EventList:-ERPLAB-Functions:-Tutorial">here</a></li>
</ul></li>
<li>Figure out how to average epochs and export to the EP Toolkit</li>
</ul></li>
<li>Evaluate the semi-automated pipelines from:
<ul>
<li><a
href="https://onlinelibrary.wiley.com/doi/full/10.1111/psyp.13580">Debnath
et al. (2020)</a></li>
<li><a
href="https://www.sciencedirect.com/science/article/pii/S0165027020303848">Desjardins
et al. (2021)</a></li>
<li><a
href="https://www.sciencedirect.com/science/article/pii/S1878929322000214">Flo
et al. (2022)</a></li>
<li><a
href="https://www.frontiersin.org/articles/10.3389/fnins.2018.00097/full">Gabar-Durnam
et al. (2018)</a></li>
<li><a
href="https://www.sciencedirect.com/science/article/pii/S1878929321001146">Haresign
et al. (2021)</a></li>
<li><a
href="https://www.sciencedirect.com/science/article/pii/S1878929322000123">Kumaravel
et al. (2022)</a></li>
</ul></li>
</ul>
</div>
<div id="eeglab-processing-steps" class="section level2" number="5.3">
<h2><span class="header-section-number">5.3</span> EEGLab Processing
Steps</h2>
<p><a href="https://eeglab.org/tutorials/"
class="uri">https://eeglab.org/tutorials/</a></p>
<ol style="list-style-type: decimal">
<li>Filtering</li>
<li>Average Referencing</li>
<li>Artifact Rejection
<ol style="list-style-type: decimal">
<li>Automated artifact rejection (save intermediate file)</li>
<li>Manual selection of bad channels</li>
<li>Manual selection of bad time periods (save intermediate file)</li>
<li>Removal of manually selected bad channels</li>
<li>Removal of manually selected bad time periods (save intermediate
file)</li>
<li><a href="#ica">Independent Component Analysis</a> (ICA)
<ol style="list-style-type: decimal">
<li>Run ICA</li>
<li>Automated removal of bad ICA components</li>
<li>Re-run ICA (save intermediate file)</li>
<li>Manual selection of bad ICA components (save intermediate file)</li>
<li>Removal of manually selected bad ICA components</li>
</ol></li>
</ol></li>
<li>Interpolation of Bad Channels</li>
<li>Average Referencing</li>
<li>Segmentation</li>
<li>Baseline Correction (save final file)</li>
</ol>
</div>
<div id="eeglab" class="section level2" number="5.4">
<h2><span class="header-section-number">5.4</span> EEGLAB</h2>
<div id="install-plugins" class="section level3" number="5.4.1">
<h3><span class="header-section-number">5.4.1</span> Install
Plugins</h3>
<p>MFFMatlabIO plugin</p>
</div>
<div id="import-data" class="section level3" number="5.4.2">
<h3><span class="header-section-number">5.4.2</span> Import Data</h3>
<p>File → Import Data → Using EEGLAB functions and plugins → Import
Magstim/EGI .mff file</p>
<pre class="matlab"><code>EEG = pop_mffimport({&#39;\\\\lc-rs-store24.hpc.uiowa.edu\\lss_itpetersen\\Lab\\Studies\\School Readiness Study\\Data\\LV2\\ERP\\Oddball\\0-Raw Data (mff)\\1613_90_oddball.mff&#39;},{&#39;code&#39;},0,0);

[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 1,&#39;overwrite&#39;,&#39;on&#39;,&#39;gui&#39;,&#39;off&#39;);</code></pre>
<p>Select <code>.mff</code> file(s)</p>
<p>Event type field (may select multiple): <code>code</code></p>
</div>
<div id="filter-data" class="section level3" number="5.4.3">
<h3><span class="header-section-number">5.4.3</span> Filter Data</h3>
<p>Filter → Basic FIR Filter</p>
<p>0.1 – 30 Hz</p>
<p>save as new name</p>
<pre class="matlab"><code>EEG = pop_eegfiltnew(EEG, &#39;locutoff&#39;,0.1,&#39;hicutoff&#39;,30,&#39;plotfreqz&#39;,1);</code></pre>
</div>
<div id="average-referencing" class="section level3" number="5.4.4">
<h3><span class="header-section-number">5.4.4</span> Average
Referencing</h3>
<p>Tools → Re-reference the data → Compute average reference</p>
<pre class="matlab"><code>EEG = eeg_checkset( EEG );
EEG = pop_reref( EEG, []);
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 1,&#39;setname&#39;,&#39;1613_90_oddball_fil_ref&#39;,&#39;overwrite&#39;,&#39;on&#39;,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;</code></pre>
</div>
<div id="artifact-rejection" class="section level3" number="5.4.5">
<h3><span class="header-section-number">5.4.5</span> Artifact
Rejection</h3>
<div id="automated-artifact-rejection" class="section level4"
number="5.4.5.1">
<h4><span class="header-section-number">5.4.5.1</span> Automated
Artifact Rejection</h4>
<p>Tools → Reject data using Clean Rawdata and ASR</p>
<pre class="matlab"><code>EEG = eeg_checkset( EEG );
EEG = pop_clean_rawdata(EEG, &#39;FlatlineCriterion&#39;,5,&#39;ChannelCriterion&#39;,0.8,&#39;LineNoiseCriterion&#39;,4,&#39;Highpass&#39;,&#39;off&#39;,&#39;BurstCriterion&#39;,20,&#39;WindowCriterion&#39;,0.25,&#39;BurstRejection&#39;,&#39;on&#39;,&#39;Distance&#39;,&#39;Euclidian&#39;,&#39;WindowCriterionTolerances&#39;,[-Inf 7] );
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 1,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;</code></pre>
<p>Currently, we run into a bug that yields the following error:</p>
<pre><code>Not enough memory, This is not a bug (Error occurred in function asr_process() at line 132)</code></pre>
<p>As a workaround, type the following code in MATLAB to edit the
function:</p>
<pre class="matlab"><code>edit clean_artifacts</code></pre>
<p>Then, change the number in the following line to a larger number
(e.g., 256) and click save:</p>
<pre class="matlab"><code>{&#39;max_mem&#39;,&#39;MaxMem&#39;}, 256, ...</code></pre>
</div>
<div id="selection-of-bad-channels" class="section level4"
number="5.4.5.2">
<h4><span class="header-section-number">5.4.5.2</span> Selection of Bad
Channels</h4>
<p>View data to identify bad channels to reject.</p>
<p>Edit → Select data</p>
<p>Specify channels to reject</p>
<p>Specify “on -&gt; remove these”</p>
<pre class="matlab"><code>EEG = eeg_checkset( EEG );
EEG = pop_select( EEG, &#39;nochannel&#39;,{&#39;E44&#39;,&#39;E56&#39;,&#39;E57&#39;,&#39;E113&#39;});
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 1,&#39;setname&#39;,&#39;1613_90_oddball_fil_ref_chn&#39;,&#39;overwrite&#39;,&#39;on&#39;,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;</code></pre>
</div>
<div id="selection-of-bad-time-periods" class="section level4"
number="5.4.5.3">
<h4><span class="header-section-number">5.4.5.3</span> Selection of Bad
Time Periods</h4>
<p>Plot → Channel data (scroll)</p>
<p>Change voltage scale to 50</p>
<p>Settings → Time range to display</p>
<p>Change to 10 seconds</p>
<p>Settings → Number of channels to display</p>
<p>Change to number of channels to view at one time (e.g., 64)</p>
<p>To erase a selected portion of the data, first drag the mouse
(holding down the left mouse button) horizontally across the time region
of interest to mark it for rejection. To deselect a portion of the data,
simply click on the selected region.</p>
<p>After marking some portions of the data for rejection, press REJECT
and a new data set will be created with the rejected data omitted. A new
dataset will be created with the marked regions removed. Your goal is to
reject non-stereotypic artifacts. Do not reject blinks/saccades, because
<a href="#ica">independent component analysis</a> will remove those.</p>
<p>Clicking “Stack” stacks all electrodes on top of each other to more
easily identify noisy data.</p>
<p>Click “REJECT” to remove the bad time periods from the data file.</p>
</div>
<div id="ica" class="section level4" number="5.4.5.4">
<h4><span class="header-section-number">5.4.5.4</span> Independent
Component Analysis</h4>
<p><a href="https://eeglab.org/tutorials/06_RejectArtifacts/RunICA.html"
class="uri">https://eeglab.org/tutorials/06_RejectArtifacts/RunICA.html</a>
(archived at <a href="https://perma.cc/AEU9-GB3B"
class="uri">https://perma.cc/AEU9-GB3B</a>)</p>
<p><a
href="https://socialsci.libretexts.org/Bookshelves/Psychology/Book%3A_Applied_Event-Related_Potential_Data_Analysis_(Luck)/14%3A_Appendix_3%3A_Example_Processing_Pipeline"
class="uri">https://socialsci.libretexts.org/Bookshelves/Psychology/Book%3A_Applied_Event-Related_Potential_Data_Analysis_(Luck)/14%3A_Appendix_3%3A_Example_Processing_Pipeline</a>
(archived at <a href="https://perma.cc/9QYQ-BNFE"
class="uri">https://perma.cc/9QYQ-BNFE</a>)</p>
<p>The component order returned by <code>runica.m</code> is in
decreasing order of the EEG variance accounted for by each
component.</p>
<p>Tools → Decompose data by ICA</p>
<pre class="matlab"><code>EEG = eeg_checkset( EEG );
EEG = pop_runica(EEG, &#39;icatype&#39;, &#39;runica&#39;, &#39;extended&#39;,1,&#39;interrupt&#39;,&#39;on&#39;);
[ALLEEG EEG] = eeg_store(ALLEEG, EEG, CURRENTSET);
eeglab redraw;</code></pre>
<p>Plot → Component maps → 2D</p>
<p>Visually identify independent components to remove</p>
<p>Tools → Inspect/label components by map</p>
<p>Example ICA Artifact Components</p>
<p><img src="images/ICA_EyeBlink.png" alt="ICA Eye Blink Artifact" />
<img src="images/ICA_LateralEyeMovement.png"
alt="ICA Lateral Eye Movement Artifact" /> <img
src="images/ICA_MuscleArtifact.png" alt="ICA Muscle Artifact" /> <img
src="images/ICA_CardiacArtifact.png" alt="ICA Cardiac Artifact" /> <img
src="images/ICA_BadChannel.png" alt="ICA Bad Channel" /></p>
<p>Example ICA Brain Components <img
src="images/ICA_BrainActivityEx1.png"
alt="ICA Brain Activity Example 1" /> <img
src="images/ICA_BrainActivityEx2.png"
alt="ICA Brain Activity Example 2" /> <img
src="images/ICA_BrainActivityEx3.png"
alt="ICA Brain Activity Example 3" /></p>
<p>Overview of ICA Components <img src="images/ICA_Overview.png"
alt="ICA Overview" /></p>
<p>Toggle the “Accept” button to reject an independent component, press
“OK” to specify it for rejection</p>
<p>Automated detection of artifactual ICA components:</p>
<p><a
href="https://eeglab.org/tutorials/06_RejectArtifacts/RunICA.html#automated-detection-of-artifactual-ica-components"
class="uri">https://eeglab.org/tutorials/06_RejectArtifacts/RunICA.html#automated-detection-of-artifactual-ica-components</a>
(archived at <a href="https://perma.cc/5RQ7-9WBT"
class="uri">https://perma.cc/5RQ7-9WBT</a>)</p>
<pre class="matlab"><code>EEG = eeg_checkset( EEG );
EEG = pop_iclabel(EEG, &#39;default&#39;);
[ALLEEG EEG] = eeg_store(ALLEEG, EEG, CURRENTSET);
EEG = eeg_checkset( EEG );
EEG = pop_icflag(EEG, [NaN NaN;0.9 1;0.9 1;NaN NaN;NaN NaN;NaN NaN;NaN NaN]);
[ALLEEG EEG] = eeg_store(ALLEEG, EEG, CURRENTSET);
eeglab redraw;</code></pre>
<p>There are six categories of components: Brain, Muscle, Eye, Heart,
Line Noise, Channel Noise, and Other</p>
<p>Our goal is to keep the brain components and to remove everything
else (i.e., artifacts).</p>
<p>Tools → Classify components using ICLabel → Label components</p>
<p>Tools → Classify components using ICLabel → Flag components as
artifacts</p>
<p>Substracting rejected ICA components:</p>
<p><a
href="https://eeglab.org/tutorials/06_RejectArtifacts/RunICA.html#subtracting-ica-components-from-data"
class="uri">https://eeglab.org/tutorials/06_RejectArtifacts/RunICA.html#subtracting-ica-components-from-data</a>
(archived at <a href="https://perma.cc/HVH4-Z4SA"
class="uri">https://perma.cc/HVH4-Z4SA</a>)</p>
<p>Tools → Remove components</p>
<pre class="matlab"><code>EEG = pop_subcomp( EEG, [1    2    6    7   10   13   21   24   26   31   32   33   36   43   44   51   54   55   59   61   67   68   74   83   90   91   93   99  103  112  113  116  118  121], 0);
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 6,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;</code></pre>
</div>
</div>
<div id="interpolate-bad-channels" class="section level3"
number="5.4.6">
<h3><span class="header-section-number">5.4.6</span> Interpolate Bad
Channels</h3>
<p><a href="https://sccn.ucsd.edu/pipermail/eeglablist/2016/011199.html"
class="uri">https://sccn.ucsd.edu/pipermail/eeglablist/2016/011199.html</a>
(archived at <a href="https://perma.cc/97NH-8LAR"
class="uri">https://perma.cc/97NH-8LAR</a>)</p>
<p>To interpolate channels you would load up one file that has only the
good channels, then load up a second file that has the full channel
list, and then run the channel interpolation function from the eeglab
gui.</p>
<p>Tools → Interpolate Electrodes → Use all channels (or specific
channels?) of other dataset</p>
<p>Using all channels of other dataset:</p>
<p><strong>Important Note:</strong> Interpolating files will
re-reference the data. Average reference the data after interpolating
channels.</p>
<pre class="matlab"><code>EEG = eeg_checkset( EEG );
EEG = pop_interp(EEG, ALLEEG(3).chanlocs, &#39;spherical&#39;);
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 4,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;</code></pre>
<p>Using specific channels of other dataset:</p>
<pre class="matlab"><code>EEG = eeg_checkset( EEG );
EEG = pop_interp(EEG, ALLEEG(3).chanlocs([44   56   57  113]), &#39;spherical&#39;);
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 1,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;</code></pre>
<p>Removed channels:</p>
<pre class="matlab"><code>EEG = eeg_checkset( EEG );
EEG = pop_interp(EEG, EEG.chaninfo.nodatchans([44  56  57  113]), &#39;spherical&#39;);
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 3,&#39;gui&#39;,&#39;off&#39;); 
EEG = eeg_checkset( EEG );
eeglab redraw;</code></pre>
<p>Data channels:</p>
<pre class="matlab"><code>EEG = eeg_checkset( EEG );
EEG = pop_interp(EEG, [44  56  57  113], &#39;spherical&#39;);
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 1,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;</code></pre>
</div>
<div id="average-referencing-1" class="section level3" number="5.4.7">
<h3><span class="header-section-number">5.4.7</span> Average
Referencing</h3>
<p>Tools → Re-reference the data → Compute average reference</p>
<pre class="matlab"><code>EEG = eeg_checkset( EEG );
EEG = pop_reref( EEG, []);
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 1,&#39;setname&#39;,&#39;1613_90_oddball_fil_ref&#39;,&#39;overwrite&#39;,&#39;on&#39;,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;</code></pre>
</div>
<div id="segmentation" class="section level3" number="5.4.8">
<h3><span class="header-section-number">5.4.8</span> Segmentation</h3>
<p>Tools → Extract Epochs</p>
<pre class="matlab"><code>EEG = eeg_checkset( EEG );
EEG = pop_epoch( EEG, {  &#39;frq+&#39;  &#39;tgt+&#39;  }, [-0.2           1], &#39;newname&#39;, &#39;1613_90_oddball_fil_ref epochs&#39;, &#39;epochinfo&#39;, &#39;yes&#39;);
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 1,&#39;overwrite&#39;,&#39;on&#39;,&#39;gui&#39;,&#39;off&#39;); </code></pre>
</div>
<div id="baseline-correction" class="section level3" number="5.4.9">
<h3><span class="header-section-number">5.4.9</span> Baseline
Correction</h3>
<pre class="matlab"><code>EEG = eeg_checkset( EEG );
EEG = pop_rmbase( EEG, [-200 0] ,[]);
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 1,&#39;overwrite&#39;,&#39;on&#39;,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;</code></pre>
</div>
</div>
<div id="automatic-script-example" class="section level2" number="5.5">
<h2><span class="header-section-number">5.5</span> Automatic Script
example</h2>
<pre class="matlab"><code>% Starting EEG Lab 
[ALLEEG EEG CURRENTSET ALLCOM] = eeglab;

%% Helpful documentation is located here
% https://eeglab.org/tutorials/11_Scripting/Using_EEGLAB_history.html (archived at https://perma.cc/Y687-5GKE)
% https://eeglab.org/tutorials/ConceptsGuide/Data_Structures.html (archived at https://perma.cc/5F39-5S32)

%Loading in the Dataset
EEG = pop_mffimport({&#39;R:\\Lab\\Studies\\School Readiness Study\\Data\\LV2\\ERP\\Oddball\\0-Raw Data (mff)\\1613_90_oddball.mff&#39;},{&#39;code&#39;},0,0);
EEG.setname=&#39;raw&#39;;
EEG = eeg_checkset( EEG );
%Storing the current dataset
[ALLEEG, EEG] = eeg_store( ALLEEG, EEG, 1);
% refreshing the graphical interface
eeglab redraw;

%Filter the data
EEG = pop_eegfiltnew(ALLEEG(1), &#39;locutoff&#39;,0.1,&#39;hicutoff&#39;,30,&#39;plotfreqz&#39;,1);
%Save the Filtered dataset 
%ALLEEG EEG CURRENTSET seems to just be a name for all of the current data
%sets 
%pop_newset seems to save the dataset in both memory and in the toolkit
[ALLEEG, EEG, CURRENTSET] = pop_newset(ALLEEG, EEG, 2,&#39;setname&#39;,&#39;fil&#39;,&#39;savenew&#39;,&#39;R:\\Lab\\Studies\\School Readiness Study\\Data\\LV2\\ERP\\Oddball\\MATLAB\\1-Filtering (fil)\\tcid_wave.set&#39;,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;

% Average referencing
%EEG = eeg_checkset( EEG );
EEG = pop_reref( ALLEEG(2), []);
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 3,&#39;setname&#39;,&#39;Avg Ref&#39;,&#39;savenew&#39;,&#39;R:\\Lab\\Studies\\School Readiness Study\\Data\\LV2\\ERP\\Oddball\\MATLAB\\9-Average Reference (ref)\\tcid_wave_avg.set&#39;,&#39;gui&#39;,&#39;off&#39;);
eeglab redraw;

% Rejecting the artifacts
% testing bumping the 
EEG = pop_clean_rawdata(ALLEEG(3), &#39;FlatlineCriterion&#39;,5,&#39;ChannelCriterion&#39;,0.8,&#39;LineNoiseCriterion&#39;,4,&#39;Highpass&#39;,&#39;off&#39;,&#39;BurstCriterion&#39;,30,&#39;WindowCriterion&#39;,0.25,&#39;BurstRejection&#39;,&#39;on&#39;,&#39;Distance&#39;,&#39;Euclidian&#39;,&#39;WindowCriterionTolerances&#39;,[-Inf 7] );
%Saving cleaned dataset
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 4,&#39;setname&#39;,&#39;clean data&#39;,&#39;savenew&#39;,&#39;R:\\Lab\\Studies\\School Readiness Study\\Data\\LV2\\ERP\\Oddball\\MATLAB\\10-Clean Artificats (clean)\\tcid_wave_clean.set&#39;,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;

% Placeholder to manually remove bad channels


% ICA components
EEG = pop_runica(ALLEEG(4), &#39;icatype&#39;, &#39;runica&#39;, &#39;extended&#39;, 1,&#39;interrupt&#39;,&#39;on&#39;);
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 5,&#39;setname&#39;,&#39;ICA test&#39;,&#39;savenew&#39;,&#39;R:\\Lab\\Studies\\School Readiness Study\\Data\\LV2\\ERP\\Oddball\\MATLAB\\11-ICA\\tcid_wave_ICA.set&#39;,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;

%Manually reject ICA components
EEG = pop_subcomp( EEG, [1    2    6    7   10   13   21   24   26   31   32   33   36   43   44   51   54   55   59   61   67   68   74   83   90   91   93   99  103  112  113  116  118  121], 0);
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 6,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;

% Place holder to remind to manually remove the channels that we would
% like to reject
% taking the EEG channel lock of the first (raw) dataset
EEG = eeg_checkset( EEG );
EEG = pop_interp(ALLEEG(5), ALLEEG(1).chanlocs, &#39;spherical&#39;);
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 6,&#39;setname&#39;,&#39;Interpolated&#39;,&#39;savenew&#39;,&#39;R:\\Lab\\Studies\\School Readiness Study\\Data\\LV2\\ERP\\Oddball\\MATLAB\\12-Interpolate\\tcid_wave_Interpolate.set&#39;,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;

% Segmenting the Data
EEG = eeg_checkset( EEG );
EEG = pop_epoch( ALLEEG(6), {  &#39;frq+&#39;  &#39;tgt+&#39;  }, [-0.2 1], &#39;newname&#39;, &#39;tcid_wave_segmented&#39;, &#39;epochinfo&#39;, &#39;yes&#39;);
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 7,&#39;setname&#39;,&#39;Segmented&#39;,&#39;savenew&#39;,&#39;R:\\Lab\\Studies\\School Readiness Study\\Data\\LV2\\ERP\\Oddball\\MATLAB\\13-Segment\\tcid_wave_Segment.set&#39;,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;

% Baseline Correcting the Data
EEG = eeg_checkset( EEG );
EEG = pop_rmbase( ALLEEG(7), [-200 0] ,[]);
[ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, 8,&#39;setname&#39;,&#39;Baseline Correct&#39;,&#39;savenew&#39;,&#39;R:\\Lab\\Studies\\School Readiness Study\\Data\\LV2\\ERP\\Oddball\\MATLAB\\14-Baseline-Correct\\tcid_wave_baseline-correct.set&#39;,&#39;gui&#39;,&#39;off&#39;); 
eeglab redraw;
</code></pre>
</div>
<div id="automatic-script-that-loops-files" class="section level2"
number="5.6">
<h2><span class="header-section-number">5.6</span> Automatic script that
loops files</h2>
<div id="warning-messages-with-script" class="section level3"
number="5.6.1">
<h3><span class="header-section-number">5.6.1</span> Warning messages
with script</h3>
<p>Warning messages appeared when using the automatic cleaning of data.
We may have to send a dataset to someone so they can check on it. Some
documentation is found here:</p>
<ul>
<li><a
href="https://sccn.ucsd.edu/pipermail/eeglablist/2021/016222.html"
class="uri">https://sccn.ucsd.edu/pipermail/eeglablist/2021/016222.html</a>
(archived at <a href="https://perma.cc/9SDG-NGXD"
class="uri">https://perma.cc/9SDG-NGXD</a>)</li>
<li><a href="https://sccn.ucsd.edu/wiki/EEGLAB_bug1971"
class="uri">https://sccn.ucsd.edu/wiki/EEGLAB_bug1971</a> (archived at
<a href="https://perma.cc/H7PA-TPTZ"
class="uri">https://perma.cc/H7PA-TPTZ</a>)</li>
</ul>
</div>
<div
id="filtering-average-referencing-and-automatically-cleaning-the-data."
class="section level3" number="5.6.2">
<h3><span class="header-section-number">5.6.2</span> Filtering, average
referencing, and automatically cleaning the data.</h3>
<p>This script batch reads in files, filters them, average references,
and automatically cleans them. After that, this script reads in the
cleaned files for manually processing to remove bad time periods and bad
channels</p>
<pre class="matlab"><code>%10/20/22 Working script that reads everything into matlab


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Location of Raw oddball files
rawOddballFiles = &#39;\\lc-rs-store24.hpc.uiowa.edu\lss_itpetersen\Lab\Studies\School Readiness Study\Data\LV2\ERP\Oddball\MATLAB\0-Raw\&#39;;
%Location of path to save cleaned files
cleanAutoPath = &#39;\\lc-rs-store24.hpc.uiowa.edu\lss_itpetersen\Lab\Studies\School Readiness Study\Data\LV2\ERP\Oddball\MATLAB\10-Clean Artificats (clean)\&#39;;

%all oddball files in the directory to be processed
filesInDirectory = dir(fullfile(rawOddballFiles, &#39;*.mff&#39;)); %Reading the files in the directory

%Listing the number of subjects for the number of times to loop
numberOfSubject = height(filesInDirectory);

%Names of all the files in the directory
listOfSubjects={filesInDirectory.name}; 

%splitting the filename up
filenameSplit = regexp(listOfSubjects, &#39;_&#39;, &#39;split&#39;);  
id = cellfun(@(x) x{1},filenameSplit,&#39;un&#39;,0);  %getting the id&#39;s
wave = cellfun(@(x) x{2},filenameSplit,&#39;un&#39;,0); %getting the waves



[ALLEEG EEG CURRENTSET ALLCOM] = eeglab;

for i=1:numberOfSubject

    %%%% Importing Data
    path = [rawOddballFiles,filesInDirectory(i).name];
    tcid = char(strcat(id(i),&#39;_&#39;, wave(i))); %combining the TCID and wave

    EEG = pop_mffimport({path},{&#39;code&#39;},0,0);
    % Saving the data in memory
   [ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, i,&#39;setname&#39;, tcid,&#39;gui&#39;,&#39;off&#39;);

    % Filtering the data
    EEG = pop_eegfiltnew(ALLEEG(i), &#39;locutoff&#39;,0.1,&#39;hicutoff&#39;,30,&#39;plotfreqz&#39;,1);
    [ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, i,&#39;overwrite&#39;,&#39;on&#39;,&#39;gui&#39;,&#39;off&#39;);
    
    % Average Referencing
    EEG = pop_reref( ALLEEG(i), []);
    [ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, i,&#39;overwrite&#39;,&#39;on&#39;,&#39;gui&#39;,&#39;off&#39;);

    % They strongly advise importing channel locations before using this
    % function.
    %Cleaning the Data
    EEG = pop_clean_rawdata(ALLEEG(i), &#39;FlatlineCriterion&#39;,5,&#39;ChannelCriterion&#39;,0.8,&#39;LineNoiseCriterion&#39;,4,&#39;Highpass&#39;,&#39;off&#39;,&#39;BurstCriterion&#39;,30,&#39;WindowCriterion&#39;,0.25,&#39;BurstRejection&#39;,&#39;on&#39;,&#39;Distance&#39;,&#39;Euclidian&#39;,&#39;WindowCriterionTolerances&#39;,[-Inf 7]);
    nameClean = [tcid,&#39;_autoClean.set&#39;];
    savePathClean = [cleanAutoPath,nameClean];
    [ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, i,&#39;setname&#39;, nameClean, &#39;savenew&#39;, savePathClean, &#39;gui&#39;,&#39;off&#39;, &#39;overwrite&#39;, &#39;on&#39;);


end
eeglab redraw:

%% Reading in automatically cleaned datasets

%%%%%%%%%%%%%%
% Clear Data becasue to overwrite anything in memory
%%%%%%%%%%%%%%
ALLEEG = [];
EEG = [];

% Adding the path for cleaned files
cleanAutoPath = &#39;\\lc-rs-store24.hpc.uiowa.edu\lss_itpetersen\Lab\Studies\School Readiness Study\Data\LV2\ERP\Oddball\MATLAB\10-Clean Artificats (clean)\&#39;;

%Starting EEGLAB
[ALLEEG EEG CURRENTSET ALLCOM] = eeglab;


%Location of cleaned oddball data
filesInDirectoryClean = dir(fullfile(cleanAutoPath, &#39;*.set&#39;)); %Reading the files in the directory


%Listing the number of subjects for the number of times to loop
numberOfSubjectClean = height(filesInDirectoryClean);

%Names of all the files in the directory
listOfSubjectsClean = {filesInDirectoryClean.name}; 

%splitting the filename up
filenameSplitClean = regexp(listOfSubjectsClean, &#39;_&#39;, &#39;split&#39;);  
id = cellfun(@(x) x{1},filenameSplitClean,&#39;un&#39;,0);  %getting the id&#39;s
wave = cellfun(@(x) x{2},filenameSplitClean,&#39;un&#39;,0); %getting the waves


for i=1:numberOfSubjectClean

    %%%% Importing Data
    tcidClean = char(strcat(id(i),&#39;_&#39;, wave(i), &#39;_autoClean.set&#39;)); %combining the TCID and wave to name the file
    EEG = pop_loadset(&#39;filename&#39;, tcidClean, &#39;filepath&#39;, cleanAutoPath); 
    [ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, i,&#39;setname&#39;, tcidClean,&#39;gui&#39;,&#39;off&#39;);

end
eeglab redraw;</code></pre>
</div>
<div id="removing-bad-time-periods-and-channels" class="section level3"
number="5.6.3">
<h3><span class="header-section-number">5.6.3</span> Removing bad time
periods and channels</h3>
<ol style="list-style-type: decimal">
<li>In the now open EEGLAB interface, select a dataset. Go to
<code>Tools</code> &gt; <code>Inspect/reject data by eye</code></li>
</ol>
<div class="float">
<img src="images/visual_reject_artifacts.png"
alt="visually reject artifacts" />
<div class="figcaption">visually reject artifacts</div>
</div>
<ol style="list-style-type: decimal">
<li>Go through the raw signal and manually reject bad time periods</li>
</ol>
<div class="float">
<img src="images/reject_time_periods.png"
alt="visually reject artifacts" />
<div class="figcaption">visually reject artifacts</div>
</div>
<ol style="list-style-type: decimal">
<li>Select <code>REJECT</code> and overwrite the file in memory
<ul>
<li>select
<code>Overwrite it in memory (set=yes; unset=create a new dataset)</code></li>
</ul></li>
<li>Visually inspect the data and select any bad channels, and write
them down</li>
<li>Next, manually reject the channels by selecting <code>Edit</code>
then <code>Select Data</code></li>
</ol>
<div class="float">
<img src="images/drop_channels.png" alt="visually reject artifacts" />
<div class="figcaption">visually reject artifacts</div>
</div>
<ol style="list-style-type: decimal">
<li>Manually enter the channels to be removed in the
<code>Channel range</code> field and select the checkbox under
<code>on-&gt;remove these</code> and select <code>Ok</code></li>
<li>Save the file as <code>tcid_wave_manualClean.set</code> in the
following drive path
<ul>
<li><code>\\lc-rs-store24.hpc.uiowa.edu\lss_itpetersen\Lab\Studies\School Readiness Study\Data\LV2\ERP\Oddball\MATLAB\11-Manually Cleaned</code></li>
<li>This screenshot represents removing channels
<code>23 56 57 97</code> <img src="images/remove_channels_specific.png"
alt="visually reject artifacts" /></li>
</ul></li>
<li>Repeat step for each cleaned dataset</li>
</ol>
</div>
<div id="running-the-ica" class="section level3" number="5.6.4">
<h3><span class="header-section-number">5.6.4</span> Running the
ICA</h3>
<p>This script runs the ICA. We’ll want to think about how to
automatically reject the components here. Once this runs, see the <a
href="#ica">ICA section</a> to reject components. Tools → Inspect/label
components by map is how to reject components.</p>
<pre class="matlab"><code>% Running the ICA

%% Reading in the manually cleaned datasets

%%%%%%%%%%%%%%
% Clear Data becasue to overwrite anything in memory
%%%%%%%%%%%%%%
ALLEEG = [];
EEG = [];

% Adding the path for cleaned files
manualCleanPath = &#39;\\lc-rs-store24.hpc.uiowa.edu\lss_itpetersen\Lab\Studies\School Readiness Study\Data\LV2\ERP\Oddball\MATLAB\11-Manually Cleaned\&#39;;

%Starting EEGLAB
[ALLEEG EEG CURRENTSET ALLCOM] = eeglab;


%Location of cleaned oddball data
filesInDirectoryManualClean = dir(fullfile(manualCleanPath, &#39;*.set&#39;)); %Reading the files in the directory


%Listing the number of subjects for the number of times to loop
numberOfSubjectManualClean = height(filesInDirectoryManualClean);

%Names of all the files in the directory
listOfSubjectsManualClean = {filesInDirectoryManualClean.name}; 

%splitting the filename up
filenameSplitManualClean = regexp(listOfSubjectsManualClean, &#39;_&#39;, &#39;split&#39;);  
id = cellfun(@(x) x{1},filenameSplitManualClean,&#39;un&#39;,0);  %getting the id&#39;s
wave = cellfun(@(x) x{2},filenameSplitManualClean,&#39;un&#39;,0); %getting the waves


for i=1:numberOfSubjectManualClean

    %%%% Importing Data
    tcidClean = char(strcat(id(i),&#39;_&#39;, wave(i), &#39;_manualClean.set&#39;)); %combining the TCID and wave to name the file
    EEG = pop_loadset(&#39;filename&#39;, tcidClean, &#39;filepath&#39;, manualCleanPath); 
    [ALLEEG EEG CURRENTSET] = pop_newset(ALLEEG, EEG, i,&#39;setname&#39;, tcidClean,&#39;gui&#39;,&#39;off&#39;);

    %%% Running the ICA
    EEG = eeg_checkset( EEG );
    EEG = pop_runica(EEG, &#39;icatype&#39;, &#39;runica&#39;, &#39;extended&#39;,1,&#39;interrupt&#39;,&#39;on&#39;);
    [ALLEEG EEG] = eeg_store(ALLEEG, EEG, CURRENTSET);
    eeglab redraw;

end
eeglab redraw;</code></pre>
</div>
</div>
<div id="notes" class="section level2" number="5.7">
<h2><span class="header-section-number">5.7</span> Notes</h2>
<div id="mountcap-type" class="section level3" number="5.7.1">
<h3><span class="header-section-number">5.7.1</span> Mount/Cap Type</h3>
<p>Options that say “AverageNet128” are suitable for our 128 channel cap
when selecting the template option when reading in text files. These are
age-normed coordinates provided by EGI. So, “2_9” is age-normed for 2 to
9 year olds.</p>
</div>
</div>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiRUVHIGFuZCBFUlAgUHJvY2Vzc2luZyBhbmQgQW5hbHlzaXMiCm91dHB1dDogCiAgaHRtbF9kb2N1bWVudDoKICAgIGNvZGVfZm9sZGluZzogc2hvdwotLS0KCmBgYHtyIHNldHVwLCBpbmNsdWRlID0gRkFMU0V9CmtuaXRyOjpvcHRzX2NodW5rJHNldCgKICBlY2hvID0gVFJVRSwKICBlcnJvciA9IFRSVUUsCiAgY29tbWVudCA9ICIiLAogIGNsYXNzLnNvdXJjZSA9ICJmb2xkLXNob3ciKQpgYGAKIyBFUlAgUHJvY2Vzc2luZyBQaXBlbGluZSB1c2luZyBIQVBQRSB7I2hhcHBlfQoKIyMgSW5pdGFsIFNldC11cCB7I2luaXRpYWx9CgoxLiBEb3dubG9hZCBNQVRMQUI6IGh0dHBzOi8vaXRzLnVpb3dhLmVkdS9tYXRsYWIKICAgIC0gQ2xpY2sgYEhvdyB0byBJbnN0YWxsIE1hdExhYmAgYW5kIGZvbGxvdyB0aGUgcmVsZXZhbnQgaW5zdHJ1Y3Rpb25zCiAgICAtIENyZWF0ZSBhIGBNYXRMYWJgIGZvbGRlciBpbiB5b3VyIGxvY2FsIGRpcmVjdG9yeS4KICAgIFlvdSB3aWxsIGtlZXAgYWxsIG9mIHlvdXIgTWF0TGFiIHJlbGF0ZWQgZmlsZXMgaW4gdGhpcyBmb2xkZXIuCjEuIEluc3RhbGwgdGhlIEhBUFBFIHBpcGVsaW5lOiBodHRwczovL2dpdGh1Yi5jb20vUElORS1MYWIvSEFQUEUKICAgIC0gQ2xvbmUgdGhlIEhBUFBFIHJlcG9zaXRvcnkgdG8geW91ciBgR2l0SHViYCBhY2NvdW50CiAgICAtIE9wZW4gdGhlIGBIQVBQRWAgZm9sZGVyCiAgICAtIE9wZW4gdGhlIGBIQVBQRSBVc2VyIEd1aWRlYCBkb2N1bWVudAogICAgLSBSZWFkIHRocm91Z2ggdGhlIGBIQVBQRSBVc2VyIEd1aWRlYAogICAgLSBOYXZpZ2F0ZSB0byB0aGUgYFNldHRpbmcgdXAgSEFQUEVgIHNlY3Rpb24gaW4gdGhlIHVzZXIgZ3VpZGUgYW5kIGZvbGxvdyB0aGUgaW5zdHJ1Y3Rpb25zIGZvciBzZXR0aW5nIHVwIHRoZSBIQVBQRSBwaXBlbGluZSwgaW5jbHVkaW5nIGluc3RhbGxhdGlvbiBvZiBhZGQtb25zIGFuZCBlZWdsYWIKMS4gSW5zdGFsbCBFUCBUb29sa2l0OiBodHRwczovL3NvdXJjZWZvcmdlLm5ldC9wcm9qZWN0cy9lcnBwY2F0b29sa2l0LwogICAgLSBBZnRlciBkb3dubG9hZGluZywgY29weSB0aGUgYEVQX1Rvb2xraXRgIGZvbGRlciB0byB5b3VyIGBNYXRsYWJgIGZvbGRlciAoaW4geW91ciBsb2NhbCBkaXJlY3RvcnkpCiAgICAtIEluIHRoZSBgRVBfdG9vbGtpdGAgZm9sZGVyOiAKICAgICAgICAtIE9wZW4gYEVQX1Rvb2xraXRgCiAgICAgICAgLSBPcGVuIGBEb2N1bWVudGF0aW9uYAogICAgICAgIC0gT3BlbiBgdHV0b3JpYWxgCiAgICAtIEluIHRoZSBgdHV0b3JpYWxgIGRvY3VtZW50LCBuYXZpZ2F0ZSB0byB0aGUgYFNldCBVcGAgc2VjdGlvbiBhbmQgZm9sbG93IHRoZSBpbnN0cnVjdGlvbnMgZm9yIGluc3RhbGxpbmcgYW5kIHNldHRpbmcgdXAgRVAgVG9vbGtpdCBhbmQgRmllbGRUcmlwLgogICAgRG8gKipOT1QqKiBmb2xsb3cgaW5zdHJ1Y3Rpb25zIGZvciBzZXR0aW5nIHVwIEVFR0xBQi4KICAgIFlvdSBoYXZlIGFscmVhZHkgc2V0IHVwIHlvdXIgcGF0aCB0byBFRUdMQUIgd2hlbiB5b3Ugc2V0IHVwIHRoZSBIQVBQRSBwaXBlbGluZS4KICAgIC0gWW91IHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgc3ViZm9sZGVycyBpbiB5b3VyIGBNYXRMYWJgIGZvbGRlcjoKICAgICAgICAtIGBFUF9Ub29sa2l0YAogICAgICAgIC0gYEZpZWxkdHJpcC1bdmVyc2lvbiBudW1iZXJdYAoKIyMgTUFUTEFCIFNjcmlwdHMgdG8gTWFuYWdlIEhBUFBFIEZpbGVzIHsjbWF0bGFiU2NyaXB0c30KCldlIGhhdmUgc2NyaXB0cyBmb3IgZWFjaCB0YXNrIHRoYXQgY2FuIHByZXBhcmUgZmlsZXMgZm9yIHRoZSBIQVBQRSBQaXBlbGluZSBhbmQvb3IgbWFuYWdlIHRoZSBmaWxlcyBvdXRwdXR0ZWQgZnJvbSBIQVBQRS4KVGhlc2UgYWN0aW9ucyBjYW4gYmUgZG9uZSBtYW51YWxseSBhcyB3ZWxsLCBidXQgdGhlIE1BVExBQiBzY3JpcHRzIG1ha2UgdGhlIHByb2Nlc3MgbW9yZSBlZmZpY2llbnQuClRoZSBzY3JpcHRzIHdpbGwgYWxzbyBnZW5lcmF0ZSBhICJsb2ciIG9mIGFsbCBvZiB0aGUgZmlsZXMgcHJvY2Vzc2VkIHRocm91Z2ggSEFQUEUgdG8gZmFjaWxpdGF0ZSB0cmFja2luZyBvZiBFRUcgZGF0YSBwcm9jZXNzaW5nLgpUaGUgc2VjdGlvbnMgYmVsb3cgZGV0YWlsIHRoZSBjb2RlIHVzZWQgdG8gcGVyZm9ybSB0aGVzZSBhY3Rpb25zIGFzIHdlbGwgYXMgdGhlIGluc3RydWN0aW9ucyBmb3IgdXNpbmcgdGhlIGN1cnJlbnQgc2NyaXB0cy4KCk5vdGU6IEJlZm9yZSB1c2luZyB0aGUgc2NyaXB0cy9jb2RlIGRldGFpbGVkIGJlbG93LCBlbnN1cmUgdGhhdCBhbGwgZmlsZXBhdGhzIHVzZWQgYXJlIGluIHlvdXIgTUFUTEFCIHBhdGggY29sbGVjdGlvbi4KVGhlc2UgbWF5IGluY2x1ZGU6CiAgIAogICAtIFRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgYXV0b21hdGljIHNjcmlwdHMgYXJlIHN0b3JlZCAoZm9yIG91ciBsYWIsIHRoaXMgaXMgdW5kZXIgYC9EYXRhIFByb2Nlc3NpbmcvNi4gTUFUTEFCIEVFRyBQaXBlbGluZWApCiAgIC0gVGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBIQVBQRSBwcmUtcHJvY2Vzc2luZyBzY3JpcHQgaXMgc3RvcmVkCiAgIC0gVGhlIGxvY2F0aW9uIG9mIHRoZSByYXcgZGF0YSAodG8gYmUgcHJvY2Vzc2VkKQogICAtIFRoZSBsb2NhdGlvbihzKSBvZiBhbnkgaW50ZXJtZWRpYXRlIGZpbGVzIGZvciBwcm9jZXNzaW5nIChlLmcuLCB0aGUgdXBkYXRlZCAubWZmIGZpbGVzIHRoYXQgY29udGFpbiBhY2N1cmFjeSBpbmZvcm1hdGlvbiBpbiBGaXNoU2hhcmspCiAgIC0gVGhlIGxvY2F0aW9uKHMpIGZvciBhbnkgZmlsZXMgb3V0cHV0dGVkIGJ5IEhBUFBFIGFuZC9vciBwbGFjZXMgeW91IHdpc2ggdG8gdXNlIHRoZSBzY3JpcHQgdG8gbW92ZSB0aGVtIHRvCgojIyBPZGRiYWxsIFByb2Nlc3NpbmcgUGlwZWxpbmUgCgojIyMgTUFUTEFCIFNjcmlwdAoKVGhlIGZvbGxvd2luZyBzZWN0aW9uIGRlc2NyaWJlcyB0aGUgTUFUTEFCIHNjcmlwdHMgdXNlZCB0byBtYW5hZ2UgSEFQUEUgb3V0cHV0IGZpbGVzIGZvciB0aGUgT2RkYmFsbCB0YXNrIGRhdGEuIElmIHlvdSBhcmUgcnVubmluZyBIQVBQRSBtYW51YWxseSAoaS5lLiwgd2l0aG91dCBpbnRlZ3JhdGluZyB0aGVzZSBzY3JpcHRzKSwgc2tpcCB0byB0aGUgW09kZGJhbGwgSEFQUEUgaW5wdXRzXSgjaW5wdXRPZGRiYWxsSEFQUEUpIHNlY3Rpb24uIAoKMS4gT3BlbiB0aGUgYGVlZ1Byb2NjZXNzaW5nT2RkYmFsbC5tYCBmaWxlIChzdG9yZWQgaGVyZTogYC9EYXRhIFByb2Nlc3NpbmcvNi4gTUFUTEFCIEVFRyBQaXBlbGluZS9gOyBhY2Nlc3NpYmxlIHZpYSBHaXQgW2hlcmVdKGh0dHBzOi8vcmVzZWFyY2gtZ2l0LnVpb3dhLmVkdS9QZXRlcnNlbkxhYi9TUlMvU1JTLURhdGFQcm9jZXNzaW5nLy0vYmxvYi9tYXN0ZXIvNi4lMjBNQVRMQUIlMjBFRUclMjBQaXBlbGluZS9lZWdQcm9jZXNzaW5nT2RkYmFsbC5tKSkgaW4gTUFUTEFCCjEuIFVwZGF0ZSBhbGwgdGhyZXNob2xkcyBhbmQgZmlsZXBhdGhzIGluIHNjcmlwdCBmaWxlIChtdXN0IGJlIGRvbmUgQkVGT1JFIHJ1bm5pbmcgdGhlIHNjcmlwdCkKICAgLSBJbiB0aGUgc2Vjb25kIHNlY3Rpb24gb2Ygb3VyIHNjcmlwdCBmaWxlLCB3ZSBzZXQgb3VyICJ0aHJlc2hvbGQiIGZvciB0aGUgbWluaW11bSBudW1iZXIgb2YgdHJpYWxzIHRoYXQgbmVlZCB0byBiZSByZXRhaW5lZCBhZnRlciBwcmUtcHJvY2Vzc2luZyBmb3IgYSBzdWJqZWN0J3MgZGF0YSB0byBiZSBlbGlnaWJsZSBmb3IgUENBLgogICBBZGRpdGlvbmFsIHRocmVzaG9sZHMgY2FuIGFsc28gYmUgc2V0IGZvciB0aGluZ3MgbGlrZSBudW1iZXIgb2YgY2hhbm5lbHMgcmV0YWluZWQsIGJ1dCB0aGVzZSBhcmUgbm90IGN1cnJlbnRseSBpbiB1c2UuCiAgIAogICBgYGAKICAgJSBTZXQgcXVhbGl0eSB0aHJlc2hvbGQgcGFyYW1ldGVycwogICB0cmlhbEN1dG9mZiA9IDEwOwogICBgYGAKICAgLSBXZSBhbHNvIHNldCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgd2l0aCBhbGwgb2YgdGhlIGZpbGVwYXRocyB0aGF0IGFyZSByZWxldmFudCBmb3IgbWFuYWdpbmcgSEFQUEUgb3V0cHV0IGZpbGVzIGFuZCB0cmFja2luZyBwcm9jZXNzZWQgZGF0YS4KICAgVGhlIGZvbGxvd2luZyBwYXRocyBzaG91bGQgYmUgY2hlY2tlZCBhbmQgdXBkYXRlZCBhcyBuZWNlc3NhcnkgdG8gcmVmbGVjdCB0aGUgb3JnYW5pemF0aW9uIG9mIHByb2Nlc3Npbmcgb24geW91ciBjb21wdXRlci4KICAgICAgLSBgcGFzc1BhdGhgIGlzIHRoZSBsb2NhdGlvbiB5b3Ugd2lzaCB0byBoYXZlIGZpbGVzIHRoYXQgbWVldCBvciBleGNlZWQgdGhlIGFib3ZlLWRlZmluZWQgdGhyZXNob2xkcyB0byBiZSBzYXZlZAogICAgICAtIGBhbGxQYXRoYCBpcyB0aGUgbG9jYXRpb24geW91IHdpc2ggdG8gaGF2ZSBBTEwgZmlsZXMgb3V0cHV0dGVkIGZyb20gSEFQUEUgc2F2ZWQgdG8gKHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aHJlc2hvbGQgaXMgbWV0IG9yIG5vdCkKICAgICAgLSBgZmFpbFBhdGhgIGlzIHRoZSBsb2NhdGlvbiB5b3Ugd2lzaCB0byBoYXZlIGZpbGVzIHRoYXQgZG8gbm90IG1lZXQgdGhlIGFib3ZlLWRlZmluZWQgdGhyZXNob2xkcyB0byBiZSBjb3BpZWQgdG8KICAgICAgICAgLSAubWZmIGZpbGVzIHRoYXQgZG8gbm90IG1lZXQgdGhyZXNob2xkIHdpbGwgYmUgY29waWVkIGhlcmUgYXMgYW4gaW5kaWNhdGlvbiB0aGF0IHRoZXkgc2hvdWxkIGJlIHByb2Nlc3NlZCBtYW51YWxseSB0byBzZWUgaWYgdGhleSBtZWV0IHRocmVzaG9sZCBhZnRlcndhcmQKICAgICAgLSBgc3VtbVBhdGhgIGlzIHRoZSBsb2NhdGlvbiB5b3Ugd2lzaCB0byBzYXZlIHRoZSBmaWxlIHRoYXQgbGlzdHMgYWxsIGZpbGVzIHByb2Nlc3NlZCB0aHJvdWdoIEhBUFBFIGluIHRoZSBjdXJyZW50IGJhdGNoCiAgICAgICAgIC0gV2UgY3VycmVudGx5IHVzZSB0aGlzIHRvIHNhdmUgdGhlICJwcm9jZXNzaW5nIGxvZyIgdG8gYSBsb2NhdGlvbiB0aGF0IGFsbCB0ZWFtIG1lbWJlcnMvY29tcHV0ZXJzIGhhdmUgYWNjZXNzIHRvIHNvIGl0IGlzIGVhc2llciB0byBkZXRlcm1pbmUgd2hpY2ggZmlsZXMgcmVxdWlyZSBwcm9jZXNzaW5nIHdoZW4gRUVHIGRhdGEgYXJlIG5vdCBzdG9yZWQgb24gYSBzaGFyZWQgc2VydmVyCiAgICAKICAgIGBgYAogICAgJSBTZXQgcGF0aHMgZm9yIGZpbGUgc29ydGluZwogICAgcGFzc1BhdGggPSAnVjpcUHJvY2Vzc2luZy1SZXBvXEZvbGRlciBTdHJ1Y3R1cmVcMyAtIEZpbGVzIGZvciBQQ0EnOyAlbG9jYXRpb24gZm9yIC50eHQgb3V0cHV0IGZpbGVzCiAgICBhbGxQYXRoID0gJ1Y6XFByb2Nlc3NpbmctUmVwb1xGb2xkZXIgU3RydWN0dXJlXDIgLSBQcm9jZXNzZWQgRmlsZXMnOyAlbG9jYXRpb24gZm9yIGFsbCBwcm9jZXNzZWQgZmlsZXMgdG8gZW5kIHVwCiAgICBmYWlsUGF0aCA9ICdWOlxQcm9jZXNzaW5nLVJlcG9cRm9sZGVyIFN0cnVjdHVyZVwxYiAtIE1hbnVhbCBQcm9jZXNzaW5nJzsgJWxvY2F0aW9uIHRvIGNvcHkgdW5zdWNjZXNzZnVsIC5tZmYgdG8gZm9yIG1hbnVhbCBwcm9jZXNzCgogICAgJSBTZXQgcGF0aCBmb3IgcHJvY2Vzc2luZyBzdW1tYXJ5CiAgICBzdW1tUGF0aCA9ICdaOlxTaGFyZWQgU2VydmVyXFN0dWR5IEZvbGRlclxEYXRhIFByb2Nlc3NpbmdcNi4gTUFUTEFCIEVFRyBQaXBlbGluZVxQcm9jZXNzZWQgRGF0YSBMb2dzJzsKICAgIGBgYAoxLiBSdW4gdGhlIEhBUFBFIFBpcGVsaW5lCiAgIC0gVGhpcyBmaXJzdCBzZWN0aW9uIGlzIGRlc2lnbmVkIHRvIHJlbHkgb24gdXNlciBpbnB1dC4KICAgQ2xpY2sgIlJ1biIgb24gdGhlIE1BVExBQiBlZGl0b3Igd2luZG93IHdpdGggdGhlIGZpbGUgb3BlbiB0byBiZWdpbiB0aGUgcHJvY2Vzcy4KICAgLSBBIG1lc3NhZ2Ugd2lsbCBhcHBlYXIgaW4gdGhlIGNvbnNvbGUgcHJvbXB0aW5nIHlvdSB0byBlbnRlciB0aGUgZmlsZXBhdGggdG8gdGhlIGxvY2F0aW9uIG9mIHRoZSBIQVBQRSBwcmUtcHJvY2Vzc2luZyBmaWxlIHlvdSB3aXNoIHRvIHJ1bgogICAtIE9uY2UgdGhlIHBhdGggaXMgZW50ZXJlZCwgTUFUTEFCIHdpbGwgcnVuIHRoZSBmaWxlCgogICBgYGAKICAgJSBTZXQgcGF0aCB0byBIQVBQRSBwcmUtcHJvY2Vzc2luZyBzY3JpcHQKICAgaGFwcGVSdW4gPSBpbnB1dCgnRW50ZXIgdGhlIGZ1bGwgcGF0aCB0byB0aGUgSEFQUEUgcHJlLXByb2Nlc3NpbmcgZmlsZTpcbj4gJywncycpIDsKCiAgICUgQ2FsbCBhbmQgcnVuIEhBUFBFIHByZS1wcm9jZXNzaW5nIHNjcmlwdAogICBydW4oaGFwcGVSdW4pOwogICBgYGAKMS4gRW50ZXIgSEFQUEUgaW5wdXRzCiAgIC0gU2VlIHRoZSBmb2xsb3dpbmcgc2VjdGlvbiBmb3IgSEFQUEUgdXNlciBpbnB1dHMgZm9yIE9kZGJhbGwKCkFmdGVyIHRoZSBIQVBQRSBpbnB1dHMgYXJlIGVudGVyZWQsIG5vIG1vcmUgdXNlciBpbnRlcmFjdGlvbiBpcyByZXF1aXJlZCBmb3IgdGhlIHNjcmlwdCB0byBkbyBpdHMgam9iLgpUaGUgSEFQUEUgcGlwZWxpbmUgd2lsbCBydW4sIGFuZCB0aGUgcmVtYWluaW5nIE1BVExBQiBjb2RlIGluIHRoZSBzY3JpcHQgZmlsZSB3aWxsIGV2YWx1YXRlIHRoZSBmaWxlcyBvdXRwdXR0ZWQgYnkgSEFQUEUgYW5kIG1vdmUgdGhlbSB0byB0aGUgYXBwcm9wcmlhdGUgbG9jYXRpb25zIGJhc2VkIG9uIHRoaXMgZXZhbHVhdGlvbi4gClNlZSBbT2RkYmFsbCBQb3N0LUhBUFBFIFN0ZXBzXSgjb2RkYmFsbFBvc3QpIGZvciBhIGRldGFpbGVkIGV4cGxhbmF0aW9uIG9mIHRoZSBjb2RlIHVzZWQgdG8gYWNjb21wbGlzaCB0aGlzLgoKIyMjIEhBUFBFIElucHV0cyB7I2lucHV0T2RkYmFsbEhBUFBFfQoKMS4gSWYgeW91IGFyZSBub3QgdXNpbmcgdGhlIE1BVExBQiBzY3JpcHRzIGRlc2NyaWJlZCBhYm92ZSwgeW91IG11c3QgZmlyc3Qgb3BlbiB0aGUgSEFQUEUgcGlwZWxpbmUgVjQgc2NyaXB0IGluIE1BVExBQiBhbmQgY2xpY2sgIlJ1biIKICAgLSBUaGlzIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBsb2NhdGlvbiB0byB3aGljaCB5b3UgbWFwcGVkIHRoZSBIQVBQRSBHaXQgcmVwbyAoZS5nLiBgRG9jdW1lbnRzL0dpdEh1Yi9IQVBQRS8xLiBwcmUtcHJvY2Vzcy9IQVBQRV92NC5tYCkKMS4gVXNlciBJbnB1dHMKICAgIC0gRW50ZXIgdGhlIHBhdGggdG8gdGhlIGZvbGRlciBjb250YWluaW5nIHRoZSBkYXRhc2V0LgogICAgLSBTZWxlY3QgYHJhd2AKICAgIC0gTG9hZCBwcmUtZXhpc3Rpbmcgc2V0IG9mIGlucHV0IHBhcmFtZXRlcjogCiAgICAgICAgLSBgTmAgaWYgdGhpcyBpcyB5b3VyIGZpcnN0IHRpbWUgcnVubmluZyBkYXRhIHRocm91Z2ggdGhlIHBpcGVsaW5lLgogICAgICAgIC0gYFlgIGlmIHlvdSBoYXZlIGRlY2lkZWQgb24gYSBzZXQgb2YgcGFyYW1ldGVycy4KICAgICAgICBFbnRlciB0aGUgcGF0aCB0byB0aGUgZm9sZGVyIGNvbnRhaW5pbmcgdGhlIGlucHV0IHBhcmFtZXRlcnMuCiAgICAtIExvdyBkZW5zaXR5IGRhdGE6IGBOYAogICAgLSBEYXRhIHR5cGU6IGB0YXNrYAogICAgLSBQZXJmb3JtaW5nIGV2ZW50LXJlbGF0ZWQgcG90ZW50aWFsIChFUlApIGFuYWx5c2lzOiBgWWAKICAgIC0gRW50ZXIgdGhlIHRhc2sgb25zZXQgdGFncwogICAgICAgIC0gVGFyZ2V0OiBgdGd0K2AKICAgICAgICAtIEZyZXF1ZW50OiBgZnJxK2AKICAgICAgICAtIGBkb25lYAogICAgLSBEbyBtdWx0aXBsZSBvbnNldCB0YWdzIGJlbG9uZyB0byBhIHNpbmdsZSBjb25kaXRpb24/IGBOYAogICAgLSBGaWxlIGZvcm1hdDogYDVgCiAgICAtIEFjcXVpc2l0aW9uIGxheW91dCB0eXBlOiBgMmAKICAgIC0gTnVtYmVyIG9mIGNoYW5uZWxzOiBgMTI4YAogICAgLSBEbyB5b3UgaGF2ZSBhZGRpdGlvbmFsIHR5cGUgZmllbGRzIGJlc2lkZXMgImNvZGUiPyBgTmAKICAgIC0gU2VsZWN0IGNoYW5uZWxzIG9mIGludGVyZXN0OiBgYWxsYAogICAgLSBGcmVxdWVuY3kgb2YgZWxlY3RyaWNhbCBub2lzZSBpbiBIejogYDYwYAogICAgLSBBcmUgdGhlcmUgYW55IGFkZGl0aW9uYWwgZnJlcXVlbmNpZXMsIChlLmcuLCBoYXJtb25pY3MpIHRvIHJlZHVjZT8gYE5gCiAgICAtIExpbmUgTm9pc2UgcmVkdWN0aW9uIG1ldGhvZDogYG5vdGNoYAogICAgICAgIC0gTG93IGN1dG9mZjogYDU5YAogICAgICAgIC0gaGlnaCBjdXRvZmY6IGA2MWAKICAgIC0gUmVzYW1wbGU6IGBOYAogICAgLSBGaWx0ZXIKICAgICAgICAtIExvdyBQYXNzIEN1dG9mZjogYDMwYAogICAgICAgIC0gSGlnaCBQYXNzIEN1dG9mZjogYC4xYAogICAgLSBDaG9vc2UgYSBmaWx0ZXI6IGBmaXJgCiAgICAtIEJhZCBDaGFubmVsIERldGVjdGlvbjogYFlgCiAgICAgICAgLSBgYWZ0ZXJgIHdhdmVsZXQgdGhyZXNob2xkaW5nCiAgICAtIEVDR29uZTogYE5gCiAgICAtIFdhdmVsZXQgVGhyZXNob2xkaW5nCiAgICAgICAgLSBgZGVmYXVsdGAKICAgICAgICAtIFRocmVzaG9sZCBydWxlOiBgaGFyZGAKICAgIC0gTXVzY0lMOiBgTmAKICAgIC0gU2VnbWVudGF0aW9uOiBgWWAKICAgICAgICAtIFN0YXJ0aW5nIHBhcmFtZXRlciBmb3Igc3RpbXVsdXM6IGAtMjAwYAogICAgICAgIC0gRW5kaW5nIHBhcmFtZXRlciBmb3Igc3RpbXVsdXM6IGAxMDAwYAogICAgICAgIC0gVGFzayBvZmZzZXQ6IGAyYAogICAgLSBCYXNlbGluZSBDb3JyZWN0aW9uOiBgWWAKICAgICAgICAtIEJhc2VsaW5lIENvcnJlY3Rpb24gc3RhcnQ6IGAtMjAwYAogICAgICAgIC0gQmFzZWxpbmUgQ29ycmVjdGlvbiBlbmQ6IGAwYAogICAgLSBJbnRlcnBvbGF0aW9uOiBgWWAKICAgIC0gU2VnbWVudCBSZWplY3Rpb246IGBZYAogICAgICAgIC0gU2VnbWVudCBSZWplY3Rpb24gTWV0aG9kOiBgYW1wbGl0dWRlYAogICAgICAgICAgICAtIG1pbmltdW0gc2VnbWVudCByZWplY3Rpb24gdGhyZXNob2xkOiBgLTE1MGAKICAgICAgICAgICAgLSBtYXhpbXVtIHNlZ21lbnQgcmVqZWN0aW9uIHRocmVzaG9sZDogYDE1MGAKICAgICAgICAgICAgLSBzZWdtZW50IHJlamVjdGlvbiBiYXNlZCBvbiBhbGwgY2hhbm5lbHMgb3IgUk9JOiBgYWxsYAogICAgLSBSZS1yZWZlcmVuY2luZzogYFlgCiAgICAgICAgLSBEb2VzIHlvdXIgZGF0YSBjb250YWluIGEgZmxhdGxpbmUgb3IgYWxsIHplcm8gcmVmZXJlbmNlIGNoYW5uZWw/IGBOYAogICAgICAgIC0gcmUtcmVmZXJlbmNpbmcgbWV0aG9kOiBgYXZlcmFnZWAKICAgIC0gU2F2ZSBmb3JtYXQ6IGAxYAogICAgLSBWaXN1YWxpemF0aW9uczogYE5gCiAgICAtIFBhcmFtZXRlciBmaWxlIHNhdmUgbmFtZTogYGRlZmF1bHRgCgojIyMgT2RkYmFsbCBQb3N0LUhBUFBFIFN0ZXBzIHsjb2RkYmFsbFBvc3R9CgpUaGlzIHNlY3Rpb24gZGV0YWlscyB0aGUgYWN0aW9ucyBwZXJmb3JtZWQgYnkgdGhlIE1BVExBQiBzY3JpcHRzIG9uY2UgSEFQUEUgaXMgY29tcGxldGVkLgpUaGVzZSBhY3Rpb25zIHdpbGwgdGFrZSBwbGFjZSBhdXRvbWF0aWNhbGx5IHVwb24gY29tcGxldGlvbiBvZiB0aGUgSEFQUEUgcGlwZWxpbmUuCioqTm8gdXNlciBpbnB1dHMgb3IgYWN0aW9ucyBhcmUgbmVjZXNzYXJ5IGF0IHRoaXMgc3RhZ2UuKioKCjEuIEV4Y2x1ZGUgZmlsZXMgdGhhdCBkb24ndCBoYXZlIGFueSBvdXRwdXQgZGF0YSBmcm9tIHRoZSBkYXRhc2V0IChjb250YWluaW5nIGZpbGVuYW1lIGFuZCBxdWFsaXR5IHJlcG9ydHMgZnJvbSBIQVBQRSBwaXBlbGluZSkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gYXNzZXNzIGZpbGUgcXVhbGl0eQogICAtIFRoaXMgc3RlcCBpcyBpbXBvcnRhbnQgYmVjYXVzZSAiZW1wdHkiIGZpbGVzIGRvbid0IHBsYXkgbmljZWx5IHdpdGggdGhlIGNvZGUgdXNlZCB0byBldmFsdWF0ZSBmaWxlcyB0aGF0IGhhdmUgc29tZSBkYXRhIGluIHRoZW0gKGV2ZW4gaWYgdGhlIGRhdGEgZG8gbm90IG1lZXQgdGhyZXNob2xkKQogICAtIFRoaXMgY29kZSByZWxpZXMgb24gSEFQUEUncyBxdWFsaXR5IGRhdGEgdGhhdCByZW1haW5zIGluIHRoZSBNQVRMQUIgZW52aXJvbm1lbnQgYWZ0ZXIgdGhlIHBpcGVsaW5lIGhhcyBmaW5pc2hlZC4KCiAgIGBgYAogICAlIENyZWF0ZSBhIGxpc3Qgb2YgZmlsZXMgdGhhdCByZWNlaXZlZCBzb21lIGtpbmQgb2YgZXJyb3IgbWVzc2FnZQogICBub1RhZ3MgPSBhbnkoc3RyY21wKGRhdGFRQywgJ05PX1RBR1MnKSwgMik7CiAgIG9uZVJlaiA9IGFueShzdHJjbXAoZGF0YVFDLCAnUkVKX09ORV9TRUcnKSwgMik7CiAgIGFsbFJlaiA9IGFueShzdHJjbXAoZGF0YVFDLCAnQUxMX1NFR19SRUonKSwgMik7CiAgIGVycm9yID0gYW55KHN0cmNtcChkYXRhUUMsICdFUlJPUicpLCAyKTsKICAgbG9hZEZhaWwgPSBhbnkoc3RyY21wKGRhdGFRQywgJ0xPQURfRkFJTCcpLCAyKTsKCiAgICUgQ29tYmluZSBmaWxlbmFtZXMgd2l0aCBxdWFsaXR5IGRhdGEgKGZvciBzb21lIHJlYXNvbiwgdGhleSBhcmUgbm90IGF1dG9tYXRpY2FsbHkgY29ubmVjdGVkIGJ5IEhBUFBFKQogICBkYXRhUUNOZXcgPSBbRmlsZU5hbWVzJywgZGF0YVFDXTsKCiAgICUgUmVtb3ZlIGFsbCBmaWxlcyBpbiB0aGUgYWJvdmUgbGlzdHMgKHRob3NlIHJlY2VpdmluZyBlcnJvcnMpIGZyb20gdGhlIHF1YWxpdHkgZGF0YQogICBkYXRhUUNOZXcobm9UYWdzIHwgYWxsUmVqIHwgZXJyb3IgfCBsb2FkRmFpbCB8IG9uZVJlaiwgOikgPSBbXTsKCiAgICUgQ3JlYXRlIGxpc3Qgb2YgdmFyaWFibGUgbmFtZXMgZm9yIHF1YWxpdHkgZGF0YQogICBkYXRhUUNuYW1lc05ldyA9IFsiRmlsZSIsIGRhdGFRQ25hbWVzXTsKICAgCiAgICUgU2F2ZSB0aGUgZGF0YSBhcyBhIHRhYmxlIGZvciBlYXNlIG9mIHVzZSBpbiBzdWJzZXF1ZW50IHN0ZXBzCiAgIHFjVGFibGUgPSBjZWxsMnRhYmxlKGRhdGFRQ05ldywgJ1ZhcmlhYmxlTmFtZXMnLCBkYXRhUUNuYW1lc05ldyk7CiAgIGBgYAoKMS4gSWRlbnRpZnkgdGhlIGZpbGVzIHRoYXQgbWVldCAob3IgZG9uJ3QgbWVldCkgdGhlIHRocmVzaG9sZAoKICAgYGBgCiAgICUgQ3JlYXRlIGEgbGlzdCBvZiBmaWxlcyAoaS5lLiwgcm93cyBpbiB0aGUgdGFibGUpIHRoYXQgbWVldCB0aHJlc2hvbGQKICAgdGhyZXNob2xkVGVzdCA9IHFjVGFibGUuKCJOdW1iZXJfdGd0K19TZWdzX1Bvc3QtU2VnX1JlaiIpID49IHRyaWFsQ3V0b2ZmICYgcWNUYWJsZS4oIk51bWJlcl9mcnErX1NlZ3NfUG9zdC1TZWdfUmVqIikgPj0gdHJpYWxDdXRvZmY7CgogICAlIEFkZCBhIHZhcmlhYmxlIHRvIHRoZSBxdWFsaXR5IGRhdGEgdGFibGUgdGhhdCBpbmNsdWRlIHdoZXRoZXIgb3Igbm90IHRoZSBmaWxlIG1lZXQgdGhyZXNob2xkCiAgIHFjVGFibGUuVGVzdCA9IHRocmVzaG9sZFRlc3Q7CiAgIGBgYAoKMS4gQWRkIGFuIGlkZW50aWZ5aW5nIHZhcmlhYmxlIHRvIGJlIHVzZWQgZm9yIGRhdGEgam9pbmluZyBkb3duIHRoZSBsaW5lCiAgIC0gVGhpcyB2YXJpYWJsZSBpcyBnZW5lcmF0ZWQgdXNpbmcgaXRzIGV4cGVjdGVkIGxvY2F0aW9uIGluIHRoZSBmaWxlIG5hbWUgKGkuZS4sIGhvdyBtYW55IHRleHQgY2hhcmFjdGVycyAiaW4iIGl0IGlzKQoKICAgYGBgCiAgICUgR2VuZXJhdGUgSURzIGJhc2VkIG9uIEZpbGUgdmFyaWFibGUKICAgaWRXYXZlUUMgPSBleHRyYWN0QmVmb3JlKHFjVGFibGUuRmlsZSwgOCk7CgogICAlIEFwcGVuZCBJRCB2YXJpYWJsZSB0byBxdWFsaXR5IGRhdGEKICAgcWNUYWJsZS5pZFdhdmUgPSBpZFdhdmVRQzsKICAgYGBgCgoxLiBDcmVhdGUgYSBzdWJzZXR0ZWQgZGF0YXNldCBjb25hdGFpbmluZyBvbmx5IHRoZSBgaWRXYXZlYCwgZmlsZSBuYW1lLCBhbmQgInRlc3QgcmVzdWx0cyIgKGkuZS4sIHdoZXRoZXIgYSBnaXZlbiBmaWxlIG1lZXRzIHRoZSBzcGVjaWZpZWQgY3V0b2ZmIHRocmVzaG9sZCBmb3IgaW5jbHVzaW9uKSB2YXJpYWJsZXMKCiAgIGBgYAogICAlIFN1YnNldCB0byBJRCBhbmQgdGhyZXNob2xkIGluZm9ybWF0aW9uCiAgIHRlc3RJbmZvID0gcWNUYWJsZSg6LCBbImlkV2F2ZSIsICJGaWxlIiwgIlRlc3QiXSk7CiAgIAogICBmcHJpbnRmKCdBc3Nlc3NtZW50IENvbXBsZXRlIFxuJyk7CiAgIGBgYAoKMS4gR2VuZXJhdGUgYSBsaXN0IG9mIGZpbGVzIG91dHB1dHRlZCBieSBIQVBQRQoKICAgYGBgCiAgICUgR2VuZXJhdGUgcGF0aCBmb3IgSEFQUEUgcHJlLXByb2Nlc3Npbmcgb3V0cHV0ICh1c2luZyB0aGUgSEFQUEUgZW52aXJvbm1lbnQgdmFyaWFibGUgZnJvbSB1c2VyJ3MgaW5wdXQgb2YgbG9jYXRpb24gb2YgcmF3IGRhdGEgZm9yIHByb2Nlc3NpbmcpCiAgIGlucHV0UGF0aCA9IHN0cmNhdChzcmNEaXIsICJcNSAtIHByb2Nlc3NlZCIpOwoKICAgJSBSZWFkIGluIGxpc3Qgb2YgZmlsZXMgb3V0cHV0dGVkIGZyb20gSEFQUEUgCiAgIHByZXByb2Nlc3NpbmdPdXRwdXQgPSBkaXIoaW5wdXRQYXRoKTsKICAgCiAgICUgUmVtb3ZlICJlbXB0eSIgcm93cyAKICAgcHJlcHJvY2Vzc2luZ091dHB1dCA9IHByZXByb2Nlc3NpbmdPdXRwdXQofmlzbWVtYmVyKHtwcmVwcm9jZXNzaW5nT3V0cHV0Lm5hbWV9LCB7Jy4nLCAnLi4nfSkpOwogICAKICAgJSBTYXZlIGRhdGEgYXMgYSB0YWJsZSBmb3IgZWFzZSBvZiBsYXRlciB1c2UKICAgcHJlcHJvY2Vzc2luZ091dHB1dCA9IHN0cnVjdDJ0YWJsZShwcmVwcm9jZXNzaW5nT3V0cHV0KTsKICAgCiAgICUgU3Vic2V0IHRvIGZpbGUgaW5mbwogICBmaWxlSW5mbyA9IHByZXByb2Nlc3NpbmdPdXRwdXQoOiwgWyJuYW1lIiwgImZvbGRlciJdKTsKICAgYGBgCjEuIFNlbGVjdCBvbmx5IGRlc2lyZWQgZmlsZXMgdG8gYmUgbW92ZWQvY29waWVkCiAgIC0gQ3VycmVudGx5LCB3ZSBkb24ndCBkbyBhbnl0aGluZyB3aXRoIHRoZSAiSW5kaXZpZHVhbCBUcmlhbCIgZmlsZXMgb3V0cHV0dGVkIGJ5IEhBUFBFLgogICBUaGVzZSBmaWxlcyBhcmUgcXVpdGUgbGFyZ2UgYW5kIHRha2UgYSBsb25nIHRpbWUgdG8gbW92ZSwgc28gaXQgaXMgbW9yZSBlZmZpY2llbnQgdG8ganVzdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBkYXRhIGFuZCBub3Qgd29ycnkgYWJvdXQgbW92aW5nIHRoZW0gYW55d2hlcmUuCgogICBgYGAKICAgJSBTdWJzZXQgdG8gZGVzaXJlZCBmaWxlcyAoQXZlT3ZlclRyaWFsKQogICBmaWxlU3Vic2V0ID0gZmlsZUluZm8oY29udGFpbnMoZmlsZUluZm8ubmFtZSwgIkF2ZU92ZXJUcmlhbHMiKSwgOik7CiAgIGBgYAoxLiBBZGQgY29uZGl0aW9uLCBJRCwgYW5kIHRocmVzaG9sZC1yZWxhdGVkIHZhcmlhYmxlcyB0byB0aGUgZmlsZSBkYXRhCiAgIC0gTk9URTogVGhlIHZhbHVlIGZvciBgQ29uZGl0aW9uYCB2YXJpYWJsZSAoaS5lLiwgIlRhcmdldCIgb3IgIkZyZXF1ZW50Iikgc2hvdWxkIG1hdGNoIHRoZSBuYW1lIG9mIHRoZSBjb25kaXRpb24tc3BlY2lmaWMgZm9sZGVycyB5b3Ugd2lzaCB0aGUgZmlsZXMgdG8gc2F2ZSB0byB3aXRoaW4gdGhlIHByb2Nlc3NpbmcgcmVwby4KCiAgIAogICBgYGAKICAgJSBHZW5lcmF0ZSBsaXN0IG9mIElEcyBiYXNlZCBvbiBmaWxlIG5hbWUgdmFyaWFibGUKICAgaWRXYXZlRlMgPSBleHRyYWN0QmVmb3JlKGZpbGVTdWJzZXQubmFtZSwgOCk7CiAgIAogICAlIEFkZCBJRCBsaXN0IHRvIGZpbGUgZGF0YQogICBmaWxlU3Vic2V0LmlkV2F2ZSA9IGlkV2F2ZUZTOwogICAKICAgJSBHZW5lcmF0ZSBsaXN0IG9mIGZpbGVzIGJlbG9uZ2luZyB0byBlYWNoIGNvbmRpdGlvbiBiYXNlZCBvbiBmaWxlIG5hbWUgdmFyaWFibGUKICAgdGFyZ2V0ID0gY29udGFpbnMoZmlsZVN1YnNldC5uYW1lLCAidGd0KyIpOwogICBmcmVxdWVudCA9IGNvbnRhaW5zKGZpbGVTdWJzZXQubmFtZSwgImZycSsiKTsKCiAgICUgQ3JlYXRlIGVtcHR5IHZhcmlhYmxlIGZvciBjb25kaXRpb24KICAgZmlsZVN1YnNldC5jb25kID0gY2VsbChzaXplKGZpbGVTdWJzZXQsIDEpLCAxKTsKCiAgICUgRmlsbCBpbiBjb25kaXRpb24gdmFyaWFibGUgYmFzZWQgb24gdGhlIGxpc3RzIGdlbmVyYXRlZCBhYm92ZQogICBmaWxlU3Vic2V0LmNvbmQodGFyZ2V0KSA9IHsnVGFyZ2V0J307CiAgIGZpbGVTdWJzZXQuY29uZChmcmVxdWVudCkgPSB7J0ZyZXF1ZW50J307CiAgIGZpbGVTdWJzZXQuY29uZCh+dGFyZ2V0ICYgfmZyZXF1ZW50KSA9IHsnQWxsJ307CgogICAlIEpvaW4gdGhyZXNob2xkIHRlc3QgaW5mb3JtYXRpb24KICAgZmlsZVRlc3QgPSBqb2luKGZpbGVTdWJzZXQsIHRlc3RJbmZvKTsKICAgYGBgCjEuIFByZXBhcmUgZGF0YSB0YWJsZSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IGZpbGVzIHRoYXQgbWV0IHRoZSB0aHJlc2hvbGQKICAgLSBUaGUgZGF0YSBnZW5lcmF0ZWQgaGVyZSBhcmUgcHJlcGFyaW5nIHRvIGNvcHkgdGhlIC50eHQgZmlsZXMgb3V0cHV0dGVkIGJ5IEhBUFBFIGludG8gYSBmb2xkZXIgY29udGFpbmluZyBhbGwgZmlsZXMgdGhhdCBhcmUgc3VpdGFibGUgZm9yIFBDQQoKICAgYGBgCiAgICUgQ3JlYXRlIGEgc2VwYXJhdGUgdGFibGUgZm9yIG9ubHkgZmlsZXMgdGhhdCBtZWV0IHRocmVzaG9sZAogICBtb3ZpbmdJbmZvID0gZmlsZVRlc3QoZmlsZVRlc3QuVGVzdCwgOik7CgogICAlIENyZWF0ZSBlbXB0eSBjb2x1bW5zIGZvciBmaWxlcGF0aCB2YXJpYWJsZXMKICAgbW92aW5nSW5mby5kZXN0aW5hdGlvbiA9IGNlbGwoc2l6ZShtb3ZpbmdJbmZvLCAxKSwgMSk7CiAgIG1vdmluZ0luZm8ub3JpZ2luID0gY2VsbChzaXplKG1vdmluZ0luZm8sIDEpLCAxKTsKICAgbW92aW5nSW5mby5wcm9jZXNzZWRUbyA9IGNlbGwoc2l6ZShtb3ZpbmdJbmZvLCAxKSwgMSk7CiAgIG1vdmluZ0luZm8ucHJvY2Vzc2VkRnJvbSA9IGNlbGwoc2l6ZShtb3ZpbmdJbmZvLCAxKSwgMSk7CgogICAlIEdlbmVyYXRlIGZpbGUgcGF0aHMgYmFzZWQgb24gY29uZGl0aW9uIAogICBtb3ZpbmdJbmZvLmRlc3RpbmF0aW9uID0gc3RyY2F0KHtwYXNzUGF0aH0sICJcIiwgbW92aW5nSW5mby5jb25kLCAiXCIsIG1vdmluZ0luZm8ubmFtZSk7CiAgIG1vdmluZ0luZm8ub3JpZ2luID0gc3RyY2F0KG1vdmluZ0luZm8uZm9sZGVyLCAiXCIsIG1vdmluZ0luZm8ubmFtZSk7CiAgIG1vdmluZ0luZm8ucHJvY2Vzc2VkVG8gPSBzdHJjYXQoe2FsbFBhdGh9LCAiXCIsIG1vdmluZ0luZm8ubmFtZSk7CiAgIG1vdmluZ0luZm8ucHJvY2Vzc2VkRnJvbSA9IHN0cmNhdChtb3ZpbmdJbmZvLmZvbGRlciwgIlwiLCBtb3ZpbmdJbmZvLm5hbWUpOwogICBgYGAKCjEuIFByZXBhcmUgZGF0YSB0YWJsZSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IGZpbGVzIHRoYXQgZG8gTk9UIG1lZXQgdGhlIHRocmVzaG9sZAogICAtIFRoZSBkYXRhIGdlbmVyYXRlZCBoZXJlIGFyZSBwcmVwYXJpbmcgdG8gY29weSAubWZmIGZpbGVzIGZyb20gdGhlIGxvY2F0aW9uIG9mIHRoZSByYXcgZmlsZXMgaW50byBhIGZvbGRlciBpbmRpY2F0aW5nIHRoZSBuZWVkIGZvciBtYW51YWwgcHJvY2Vzc2luZwoKICAgYGBgCiAgICUgQ3JlYXRlIGEgc2VwYXJhdGUgdGFibGUgZm9yIG9ubHkgZmlsZXMgdGhhdCBkaWQgbm90IG1lZXQgdGhyZXNob2xkCiAgIGZhaWxGaWxlcyA9IGZpbGVUZXN0KH5maWxlVGVzdC5UZXN0LCBbIkZpbGUiLCAiZm9sZGVyIiwgIm5hbWUiXSk7CgogICAlIENyZWF0ZSBlbXB0eSBjb2x1bW5zIGZvciBmaWxlcGF0aCB2YXJpYWJsZXMKICAgZmFpbEZpbGVzLmRlc3RpbmF0aW9uID0gY2VsbChzaXplKGZhaWxGaWxlcywgMSksIDEpOwogICBmYWlsRmlsZXMub3JpZ2luID0gY2VsbChzaXplKGZhaWxGaWxlcywgMSksIDEpOwogICBmYWlsRmlsZXMucHJvY2Vzc2VkVG8gPSBjZWxsKHNpemUoZmFpbEZpbGVzLCAxKSwgMSk7CiAgIGZhaWxGaWxlcy5wcm9jZXNzZWRGcm9tID0gY2VsbChzaXplKGZhaWxGaWxlcywgMSksIDEpOwoKICAgJSBHZW5lcmF0ZSBmaWxlcGF0aHMgYmFzZWQgb24gSUQgYW5kIHRhc2sKICAgZmFpbEZpbGVzLmRlc3RpbmF0aW9uID0gc3RyY2F0KHtmYWlsUGF0aH0sICJcIiwgZmFpbEZpbGVzLkZpbGUpOwogICBmYWlsRmlsZXMub3JpZ2luID0gc3RyY2F0KHtzcmNEaXJ9LCAiXCIsIGZhaWxGaWxlcy5GaWxlKTsKICAgZmFpbEZpbGVzLnByb2Nlc3NlZEZyb20gPSBzdHJjYXQoZmFpbEZpbGVzLmZvbGRlciwgIlwiLCBmYWlsRmlsZXMubmFtZSk7CiAgIGZhaWxGaWxlcy5wcm9jZXNzZWRUbyA9IHN0cmNhdCh7YWxsUGF0aH0sICJcIiwgZmFpbEZpbGVzLm5hbWUpOwoKICAgYGBgCgoxLiBHZW5lcmF0ZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBjb2x1bW4gaW5kZXggb2YgcmVsZXZhbnQgdmFyaWFibGVzIGZvciBmaWxlIHNvcnRpbmcKICAgLSBOb3RlIHRoYXQgdGhlIHZlcnkgbGFzdCBsaW5lIG9mIHRoaXMgY29kZSBkZWZpbmVzIHRoZSB2YXJhaWJsZShzKSB0byBleGNsdWRlIGZyb20gdGhlIEhBUFBFIG91dHB1dHRlZCBmaWxlcy4KICAgVGhpcyB2YXJpYWJsZSBtdXN0IGJlIHN0cmlwcGVkIGZyb20gdGhlIGRhdGEgYmVmb3JlIHNhdmluZyB0aGVtLCBiZWNhdXNlIHRoZSBwcmVzZW5jZSBvZiB0aGUgZXh0cmEgdmFyaWFibGUgbWFrZXMgdGhlIGZpbGUgaW5jb21wYXRpYmxlIHdpdGggRVAgVG9vbGtpdCdzIFBDQSBwcm9jZXNzLgoKICAgYGBgCiAgICUgRGVmaW5lIGNvbHVtbiBsb2NhdGlvbnMgZm9yIGVhY2ggZmlsZXBhdGggdmFyaWFibGUKCiAgICUgRm9yIGZpbGVzIHRoYXQgbWVldCB0aHJlc2hvbGQ6CiAgIHRvQ29sID0gZmluZChzdHJjbXAobW92aW5nSW5mby5Qcm9wZXJ0aWVzLlZhcmlhYmxlTmFtZXMsICJkZXN0aW5hdGlvbiIpKTsKICAgZnJvbUNvbCA9IGZpbmQoc3RyY21wKG1vdmluZ0luZm8uUHJvcGVydGllcy5WYXJpYWJsZU5hbWVzLCAib3JpZ2luIikpOwogICBwcm9jQ29sdG8gPSBmaW5kKHN0cmNtcChtb3ZpbmdJbmZvLlByb3BlcnRpZXMuVmFyaWFibGVOYW1lcywgInByb2Nlc3NlZFRvIikpOwogICBwcm9jQ29sZnJvbSA9IGZpbmQoc3RyY21wKG1vdmluZ0luZm8uUHJvcGVydGllcy5WYXJpYWJsZU5hbWVzLCAicHJvY2Vzc2VkRnJvbSIpKTsKICAgCiAgICUgRm9yIGZpbGVzIHRoYXQgZG8gbm90IG1lZXQgdGhyZXNob2xkCiAgIHJhd0NvbCA9IGZpbmQoc3RyY21wKGZhaWxGaWxlcy5Qcm9wZXJ0aWVzLlZhcmlhYmxlTmFtZXMsICJvcmlnaW4iKSk7CiAgIG1hbkNvbCA9IGZpbmQoc3RyY21wKGZhaWxGaWxlcy5Qcm9wZXJ0aWVzLlZhcmlhYmxlTmFtZXMsICJkZXN0aW5hdGlvbiIpKTsKICAgZmFpbFByb2NDb2x0byA9IGZpbmQoc3RyY21wKGZhaWxGaWxlcy5Qcm9wZXJ0aWVzLlZhcmlhYmxlTmFtZXMsICJwcm9jZXNzZWRUbyIpKTsKICAgZmFpbFByb2NDb2xGcm9tID0gZmluZChzdHJjbXAoZmFpbEZpbGVzLlByb3BlcnRpZXMuVmFyaWFibGVOYW1lcywgInByb2Nlc3NlZEZyb20iKSk7CiAgIAogICAlIERlZmluZSB2YXJpYWJsZSB0byBleGNsdWRlCiAgIGV4dHJhVmFyID0gJ1RpbWUnOwogICBgYGAKMS4gVXNlIGEgbG9vcCB0byBwcm9jZXNzIGFsbCBmaWxlcyB0aGF0IG1ldCB0aHJlc2hvbGQKICAgLSBGb3IgZWFjaCByb3cgaW4gdGhlICJtb3ZpbmdJbmZvIiBkYXRhc2V0LCB0aGUgbG9vcCB3aWxsOgogICAgICAtIElkZW50aWZ5IHRoZSBvcmlnaW4gYW5kIGRlc3RpbmF0aW9uIHBhdGhzCiAgICAgIC0gUmVhZCBpbiB0aGUgSEFQUEUgb3V0cHV0IGZpbGUKICAgICAgLSBSZW1vdmUgdGhlIGV4dHJhIHZhcmlhYmxlCiAgICAgIC0gU2F2ZSB0aGUgImNsZWFuZWQiIGRhdGEgaW4gdGhlIGFwcHJvcHJpYXRlIGZvbGRlciAod2l0aG91dCB2YXJpYWJsZSBuYW1lcywgYXMgcmVxdWlyZWQgYnkgRVAgVG9vbGtpdCkgCgogICBgYGAKICAgZm9yIHJvdyA9IDE6aGVpZ2h0KG1vdmluZ0luZm8pCiAgICAgICAlIFNwZWNpZnkgcGF0aCBpbmZvCiAgICAgICBwYXRoRnJvbSA9IG1vdmluZ0luZm97cm93LCBmcm9tQ29sfTsKICAgICAgIHBhdGhUbyA9IG1vdmluZ0luZm97cm93LCB0b0NvbH07CiAgICAgICAlIFJlYWQgaW4gdGhlIGRhdGEKICAgICAgIHJhd1RhYmxlID0gcmVhZHRhYmxlKHBhdGhGcm9tKTsKICAgICAgICUgUmVtb3ZlIGV4dHJhIGNvbHVtbiAoVGltZSkKICAgICAgIGNsZWFuVGFibGUgPSByYXdUYWJsZXs6LCB+c3RyY21wKHJhd1RhYmxlLlByb3BlcnRpZXMuVmFyaWFibGVOYW1lcywgZXh0cmFWYXIpfTsKICAgICAgICUgU2F2ZSB3aXRob3V0IGhlYWRlcnMKICAgICAgIHdyaXRlbWF0cml4KGNsZWFuVGFibGUsIHBhdGhUbywgJ0RlbGltaXRlcicsICdcdCcpCiAgIGVuZAoKICAgYGBgCjEuIFVzZSBhIGxvb3AgdG8gY29weSByYXcgKC5tZmYpIGZpbGVzIGludG8gYSBsb2NhdGlvbiB0aGF0IHN0b3JlcyBmaWxlcyByZXF1aXJpbmcgbWFudWFsIHByb2Nlc3NpbmcKCiAgIGBgYAogICBmb3Igcm93ID0gMTpoZWlnaHQoZmFpbEZpbGVzKQogICAgICAgJSBTcGVjaWZ5IHBhdGggaW5mbwogICAgICAgcGF0aEZyb20gPSBmYWlsRmlsZXN7cm93LCByYXdDb2x9OwogICAgICAgcGF0aFRvID0gZmFpbEZpbGVze3JvdywgbWFuQ29sfTsKICAgICAgICUgQ29weSBmaWxlIAogICAgICAgY29weWZpbGUocGF0aEZyb20sIHBhdGhUbykKICAgZW5kCiAgIGBgYAoKMS4gVXNlIGEgc2V0IG9mIGxvb3BzIHRvIGNvcHkgYWxsIEhBUFBFIG91dHB1dCBmaWxlcyBpbnRvIGEgZm9sZGVyIGludGVuZGVkIHRvIGhvdXNlIGFsbCBvdXRwdXQgKHdoZXRoZXIgdGhyZXNob2xkIGlzIG1ldCBvciBub3QpCgogICBgYGAKICAgZm9yIHJvdyA9IDE6aGVpZ2h0KG1vdmluZ0luZm8pCiAgICAgICAlIFNwZWNpZnkgcGF0aCBpbmZvCiAgICAgICBwYXRoRnJvbSA9IG1vdmluZ0luZm97cm93LCBwcm9jQ29sZnJvbX07CiAgICAgICBwYXRoVG8gPSBtb3ZpbmdJbmZve3JvdywgcHJvY0NvbHRvfTsKICAgICAgICUgQ29weSBmaWxlCiAgICAgICBjb3B5ZmlsZShwYXRoRnJvbSwgcGF0aFRvKTsKICAgZW5kCgogICBmb3Igcm93ID0gMTpoZWlnaHQoZmFpbEZpbGVzKQogICAgICAgJSBTcGVjaWZ5IHBhdGggaW5mbwogICAgICAgcGF0aEZyb20gPSBmYWlsRmlsZXN7cm93LCBmYWlsUHJvY0NvbEZyb219OwogICAgICAgcGF0aFRvID0gZmFpbEZpbGVze3JvdywgZmFpbFByb2NDb2x0b307CiAgICAgICAlIENvcHkgZmlsZQogICAgICAgY29weWZpbGUocGF0aEZyb20sIHBhdGhUbyk7CiAgIGVuZAogICBgYGAKMS4gR2VuZXJhdGUgYSAudHh0IGZpbGUgbGlzdGluZyBhbGwgcHJvY2Vzc2VkIC5tZmYgZmlsZXMKICAgLSBUaGlzIGZpbGUgd2lsbCBjb250YWluIGEgbGlzdCBvZiBhbGwgcmF3IGZpbGVzIChlLmcuLCBgMTExMV8yMl9vZGRiYWxsLm1mZmApIGFuZCBzYXZlIHRoZSBsaXN0IHRvIHRoZSBzcGVjaWZpZWQgbG9jYXRpb24gKCJzdW1tUGF0aCIpCiAgIC0gVGhlIGZpbGUgd2lsbCBoYXZlIHRoZSBjdXJyZW50IGRhdGUgYW5kIHRpbWUgYXBwZW5kZWQgdG8gdGhlIGVuZCBzbyB0aGF0IGl0IHdpbGwgYmUgZGlzdGluZ3Vpc2hhYmxlIGZyb20gcGFzdCBsb2dzIAogICAtIFRoZSBsaXN0IG9mIHByb2Nlc3NlZCBmaWxlcyBpcyBnZW5lcmF0ZWQgdXNpbmcgYW4gZW52aXJvbm1lbnQgdmFyaWFibGUgKGBGaWxlTmFtZXNgKSB0aGF0IHRoZSBIQVBQRSBwaXBlbGluZSBjcmVhdGVzIHRoYXQgbGlzdHMgYWxsIGZpbGVzIGlucHV0dGVkIHRvIHRoZSBwaXBlbGluZQoKICAgYGBgCiAgICUgQ3JlYXRlIGEgdGFibGUgZnJvbSBIQVBQRSBGaWxlTmFtZXMgY2VsbCBhcnJheQogICBwcm9jZXNzZWRMaXN0ID0gY2VsbDJ0YWJsZShGaWxlTmFtZXMoOikpOwoKICAgJSBSZW5hbWUgZmlsZSB2YXJpYWJsZSBmcm9tIGRlZmF1bHQKICAgcHJvY2Vzc2VkTGlzdCA9IHJlbmFtZXZhcnMocHJvY2Vzc2VkTGlzdCwgeydWYXIxJ30sIHsnRmlsZSd9KTsKCiAgICUgU2F2ZSBjdXJyZW50IGRhdGUgYXMgYSBzdHJpbmcgdmFyaWFibGUgCiAgIHRvZGF5ID0gc3RyaW5nKGRhdGUoKSk7CgogICAlIFNhdmUgdGltZSBhcyBhIHN0cmluZyB2YXJpYWJsZSwgcmVwbGFjaW5nICI6IiB3aXRoICJfIiBzbyB0aGF0IGZpbGUgY2FuIGJlIHdyaXR0ZW4gCiAgIHRpbWUgPSBzdHJyZXAoZGF0ZXN0cihub3csICdISDpNTTpTUzpGRkYnKSwgJzonLCAiXyIpOwoKICAgJSBHZW5lcmF0ZSBmaWxlIG5hbWUgdG8gaW5jbHVkZSBjdXJyZW50IGRhdGUgYW5kIHRpbWUgCiAgIGxpc3RGaWxlID0gc3RyY2F0KCJcb2RkYmFsbFByb2Nlc3NlZF8iLCB0b2RheSwgIl8iLCB0aW1lKTsKCiAgICUgR2VuZXJhdGUgZnVsbCBwYXRoIGluY2x1ZGluZyBmaWxlIG5hbWUKICAgc3VtbVBhdGhGdWxsID0gc3RyY2F0KHN1bW1QYXRoLCBsaXN0RmlsZSk7CgogICAlIFdyaXRlIHRhYmxlIHRvIHNwZWNpZmllZCBsb2NhdGlvbgogICB3cml0ZXRhYmxlKHByb2Nlc3NlZExpc3QsIHN1bW1QYXRoRnVsbCk7CiAgIGBgYAoKIyMgRmlzaC9TaGFyayBQcm9jZXNzaW5nIFBpcGVsaW5lCgojIyMgTUFUTEFCIFNjcmlwdAoKVGhlIGZvbGxvd2luZyBzZWN0aW9uIGRlc2NyaWJlcyB0aGUgTUFUTEFCIHNjcmlwdHMgdXNlZCB0byBtYW5hZ2UgSEFQUEUgaW5wdXQgYW5kIG91dHB1dCBmaWxlcyBmb3IgdGhlIEZpc2gvU2hhcmsgdGFzayBkYXRhLiBJZiB5b3UgYXJlIHJ1bm5pbmcgSEFQUEUgbWFudWFsbHkgKGkuZS4sIHdpdGhvdXQgaW50ZWdyYXRpbmcgdGhlc2Ugc2NyaXB0cyksIHNraXAgdG8gdGhlIFtGaXNoL1NoYXJrIEhBUFBFIGlucHV0c10oI2lucHV0RmlzaFNoYXJrSEFQUEUpIHNlY3Rpb24uCgoqKlRoZSBmaXJzdCB0d28gc3RlcHMgZHNlc2NyaWJlZCBpbiB0aGlzIHNlY3Rpb24gYXJlIHRoZSBzYW1lIGFzIHRob3NlIGRlc2NyaWJlZCBmb3IgT2RkYmFsbCBwcm9jZXNzaW5nLioqCioqUHJvY2Vzc2luZyBhY3Rpb25zIHNwZWNpZmljIHRvIEZpc2hTaGFya3MgdGFzayBiZWdpbiBpbiBTdGVwIDMqKgoKMS4gT3BlbiB0aGUgYGVlZ1Byb2NjZXNzaW5nRmlzaHNoYXJrLm1gIGZpbGUgKHN0b3JlZCBoZXJlOiBgL0RhdGEgUHJvY2Vzc2luZy82LiBNQVRMQUIgRUVHIFBpcGVsaW5lL2A7IGFjY2Vzc2libGUgdmlhIEdpdCBbaGVyZV0oaHR0cHM6Ly9yZXNlYXJjaC1naXQudWlvd2EuZWR1L1BldGVyc2VuTGFiL1NSUy9TUlMtRGF0YVByb2Nlc3NpbmcvLS9ibG9iL21hc3Rlci82LiUyME1BVExBQiUyMEVFRyUyMFBpcGVsaW5lL2VlZ1Byb2Nlc3NpbmdGaXNoc2hhcmsubSkpIGluIE1BVExBQgoxLiBVcGRhdGUgYWxsIHRocmVzaG9sZHMgYW5kIGZpbGVwYXRocyBpbiBzY3JpcHQgZmlsZSAobXVzdCBiZSBkb25lIEJFRk9SRSBydW5uaW5nIHRoZSBzY3JpcHQpCiAgIC0gSW4gdGhlIGZpZnRoIHNlY3Rpb24gb2Ygb3VyIHNjcmlwdCBmaWxlLCB3ZSBzZXQgb3VyICJ0aHJlc2hvbGQiIGZvciB0aGUgbWluaW11bSBudW1iZXIgb2YgdHJpYWxzIHRoYXQgbmVlZCB0byBiZSByZXRhaW5lZCBhZnRlciBwcmUtcHJvY2Vzc2luZyBmb3IgYSBzdWJqZWN0J3MgZGF0YSB0byBiZSBlbGlnaWJsZSBmb3IgUENBLgogICBBZGRpdGlvbmFsIHRocmVzaG9sZHMgY2FuIGFsc28gYmUgc2V0IGZvciB0aGluZ3MgbGlrZSBudW1iZXIgb2YgY2hhbm5lbHMgcmV0YWluZWQsIGJ1dCB0aGVzZSBhcmUgbm90IGN1cnJlbnRseSBpbiB1c2UuCiAgIC0gTm90ZSB0aGF0IHNldHRpbmcgdGhlc2UgcGFyYW1ldGVycyBvY2N1cnMgbGF0ZXIgaW4gdGhlIEZpc2hTaGFya3Mgc2NyaXB0IHRoYW4gdGhlIG9uZSBmb3IgT2RkYmFsbDsgCiAgIHRoaXMgaXMgYmVjYXVzZSBGaXNoU2hhcmtzIGZpbGVzIHJlcXVpcmUgYWRkaXRpb25hbCBwcm9jZXNzaW5nIGJlZm9yZSB0aGV5IGFyZSByZWFkeSBmb3IgSEFQUEUgKHNlZSBzdGVwIDIgZm9yIGRldGFpbHMpCiAgIAogICBgYGAKICAgJSBTZXQgcXVhbGl0eSB0aHJlc2hvbGQgcGFyYW1ldGVycwogICB0cmlhbEN1dG9mZiA9IDEwOwogICBgYGAKICAgLSBXZSBhbHNvIHNldCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgd2l0aCBhbGwgb2YgdGhlIGZpbGVwYXRocyB0aGF0IGFyZSByZWxldmFudCBmb3IgbWFuYWdpbmcgSEFQUEUgb3V0cHV0IGZpbGVzIGFuZCB0cmFja2luZyBwcm9jZXNzZWQgZGF0YS4KICAgVGhlIGZvbGxvd2luZyBwYXRocyBzaG91bGQgYmUgY2hlY2tlZCBhbmQgdXBkYXRlZCBhcyBuZWNlc3NhcnkgdG8gcmVmbGVjdCB0aGUgb3JnYW5pemF0aW9uIG9mIHByb2Nlc3Npbmcgb24geW91ciBjb21wdXRlci4KICAgICAgLSBgcGFzc1BhdGhgIGlzIHRoZSBsb2NhdGlvbiB5b3Ugd2lzaCB0byBoYXZlIGZpbGVzIHRoYXQgbWVldCBvciBleGNlZWQgdGhlIGFib3ZlLWRlZmluZWQgdGhyZXNob2xkcyB0byBiZSBzYXZlZAogICAgICAtIGBhbGxQYXRoYCBpcyB0aGUgbG9jYXRpb24geW91IHdpc2ggdG8gaGF2ZSBBTEwgZmlsZXMgb3V0cHV0dGVkIGZyb20gSEFQUEUgc2F2ZWQgdG8gKHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aHJlc2hvbGQgaXMgbWV0IG9yIG5vdCkKICAgICAgLSBgZmFpbFBhdGhgIGlzIHRoZSBsb2NhdGlvbiB5b3Ugd2lzaCB0byBoYXZlIGZpbGVzIHRoYXQgZG8gbm90IG1lZXQgdGhlIGFib3ZlLWRlZmluZWQgdGhyZXNob2xkcyB0byBiZSBjb3BpZWQgdG8KICAgICAgICAgLSAubWZmIGZpbGVzIHRoYXQgZG8gbm90IG1lZXQgdGhyZXNob2xkIHdpbGwgYmUgY29waWVkIGhlcmUgYXMgYW4gaW5kaWNhdGlvbiB0aGF0IHRoZXkgc2hvdWxkIGJlIHByb2Nlc3NlZCBtYW51YWxseSB0byBzZWUgaWYgdGhleSBtZWV0IHRocmVzaG9sZCBhZnRlcndhcmQKICAgICAgLSBgc3VtbVBhdGhgIGlzIHRoZSBsb2NhdGlvbiB5b3Ugd2lzaCB0byBzYXZlIHRoZSBmaWxlIHRoYXQgbGlzdHMgYWxsIGZpbGVzIHByb2Nlc3NlZCB0aHJvdWdoIEhBUFBFIGluIHRoZSBjdXJyZW50IGJhdGNoCiAgICAgICAgIC0gV2UgY3VycmVudGx5IHVzZSB0aGlzIHRvIHNhdmUgdGhlICJwcm9jZXNzaW5nIGxvZyIgdG8gYSBsb2NhdGlvbiB0aGF0IGFsbCB0ZWFtIG1lbWJlcnMvY29tcHV0ZXJzIGhhdmUgYWNjZXNzIHRvIHNvIGl0IGlzIGVhc2llciB0byBkZXRlcm1pbmUgd2hpY2ggZmlsZXMgcmVxdWlyZSBwcm9jZXNzaW5nIHdoZW4gRUVHIGRhdGEgYXJlIG5vdCBzdG9yZWQgb24gYSBzaGFyZWQgc2VydmVyCiAgICAKICAgIGBgYAogICAgJSBTZXQgcGF0aHMgZm9yIGZpbGUgc29ydGluZwogICAgcGFzc1BhdGggPSAnVjpcUHJvY2Vzc2luZy1SZXBvXEZvbGRlciBTdHJ1Y3R1cmVcMyAtIEZpbGVzIGZvciBQQ0EnOyAlbG9jYXRpb24gZm9yIC50eHQgb3V0cHV0IGZpbGVzCiAgICBhbGxQYXRoID0gJ1Y6XFByb2Nlc3NpbmctUmVwb1xGb2xkZXIgU3RydWN0dXJlXDIgLSBQcm9jZXNzZWQgRmlsZXMnOyAlbG9jYXRpb24gZm9yIGFsbCBwcm9jZXNzZWQgZmlsZXMgdG8gZW5kIHVwCiAgICBmYWlsUGF0aCA9ICdWOlxQcm9jZXNzaW5nLVJlcG9cRm9sZGVyIFN0cnVjdHVyZVwxYiAtIE1hbnVhbCBQcm9jZXNzaW5nJzsgJWxvY2F0aW9uIHRvIGNvcHkgdW5zdWNjZXNzZnVsIC5tZmYgdG8gZm9yIG1hbnVhbCBwcm9jZXNzCgogICAgJSBTZXQgcGF0aCBmb3IgcHJvY2Vzc2luZyBzdW1tYXJ5CiAgICBzdW1tUGF0aCA9ICdaOlxTaGFyZWQgU2VydmVyXFN0dWR5IEZvbGRlclxEYXRhIFByb2Nlc3NpbmdcNi4gTUFUTEFCIEVFRyBQaXBlbGluZVxQcm9jZXNzZWQgRGF0YSBMb2dzJzsKICAgIGBgYAoxLiBVcGRhdGUgcmF3ICgubWZmKSBmaWxlcycgY29uZGl0aW9uIHRhZ3Mgd2l0aCBhY2N1cmFjeSBpbmZvcm1hdGlvbgogICAtIFVubGlrZSB0aGUgUGFzc2l2ZSBPZGRiYWxsIHRhc2ssIEZpc2hTaGFya3MgdHJpYWxzIGNhbiBiZSBlaXRoZXIgY29ycmVjdCBvciBpbmNvcnJlY3QuIAogICBXaGV0aGVyIG9yIG5vdCBhIHRyaWFsIHdhcyAicmVzcG9uZGVkIHRvIiBjb3JyZWN0bHkgaXMgcmVsZXZhbnQgdG8gdGhlIG5hdHVyZSBvZiB0aGUgZXh0cmFjdGVkIEVSUC4KICAgQmVjYXVzZSB0aGUgZXZlbnQgdGFncyBpbiBvdXIgLm1mZiBmaWxlcyBkbyBub3QgaW5oZXJlbnRseSBjb250YWluIGluZm9ybWF0aW9uIGFib3V0IHdoZXRoZXIgZWFjaCB0cmlhbCB3YXMgcmVzcG9uZGVkIHRvIGNvcnJlY3RseSwgd2UgbmVlZCB0byBhZGQgaXQgb3Vyc2VsdmVzLgogICBUaGlzIHByb2Nlc3MgY2FuIGJlIGRvbmUgbWFudWFsbHkgaW4gTmV0U3RhdGlvbiwgYnV0IGl0IGNhbiBhbHNvIGJlIGF1dG9tYXRlZCB1c2luZyB0aGUgTUFUTEFCIGNvZGUgZGV0YWlsZWQgYmVsb3cuCiAgIC0gTk9URTogVGhpcyBjb2RlIHJlcXVpcmVzIGVlZ2xhYi4KICAgQmVmb3JlIHJ1bm5pbmcgdGhlIGNvZGUsIG9wZW4gZWVnbGFiIGluIHlvdXIgTUFUTEFCIHNlc3Npb24gYnkgdHlwaW5nIGBlZWdsYWJgIGludG8gdGhlIGNvbnNvbGUuCiAgIFlvdSBjYW4gY2xvc2UgaXQgYXMgc29vbiBhcyBpdCBvcGVucywgYnV0IHRoaXMgc3RlcCBlbnN1cmVzIHRoYXQgZWVnbGFiIGlzIGxvYWRlZCBpbnRvIHlvdXIgY3VycmVudCBzZXNzaW9uIGFuZCBoZWxwcyBwcmV2ZW50IHRoZSBzdWJzZXF1ZW50IGNvZGUgZnJvbSBlcnJvcmluZyBvdXQuCiAgIAogICAxLiBTZXQgdGhlIGZpbGVwYXRocyBmb3IgcmF3IGFuZCB1cGRhdGVkIC5tZmYgZmlsZXMKICAgICAgLSBUaGlzIHNlY3Rpb24gaXMgc2V0IHRvIHJlbHkgb24gdXNlciBpbnB1dHMuCiAgICAgIENsaWNrICJSdW4iIGluIHRoZSBNQVRMQUIgZWRpdG9yIHRvIHN0YXJ0IHRoZSBwcm9jZXNzaW5nLgogICAgICAtIEEgbWVzc2FnZSB3aWxsIGFwcGVhciBpbiB0aGUgY29uc29sZSBwcm9tcHRpbmcgeW91IHRvIGVudGVyIHR3byBmaWxlcGF0aHM6IAogICAgICB0aGUgZmlyc3QgaXMgdGhlIGxvY2F0aW9uIG9mIHRoZSByYXcgLm1mZiBmaWxlcywgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGxvY2F0aW9uIHlvdSB3b3VsZCBsaWtlIHRoZSB1cGRhdGVkIGZpbGVzIHRvIHNhdmUgaW4uCgogICAgICBgYGAKICAgICAgJSBVc2VyIGlucHV0IGZvciBsb2NhdGlvbiBvZiByYXcgZmlsZXMKICAgICAgcGF0aFJhdyA9IGlucHV0KCdFbnRlciB0aGUgZnVsbCBwYXRoIHRvIHRoZSBmb2xkZXIgY29udGFpbmluZyB0aGUgcmF3IGZpbGVzOlxuPiAnLCdzJyk7CiAgICAgIAogICAgICAlIFVzZXIgaW5wdXQgZm9yIGRlc3RpbmF0aW9uIG9mIHN1YnNldHRlZCBmaWxlcwogICAgICBwYXRoU3ViID0gaW5wdXQoJ0VudGVyIHRoZSBmdWxsIHBhdGggdG8gdGhlIGZvbGRlciBpbiB3aGljaCB0byBzYXZlIHRoZSBzdWJzZXR0ZWQgZmlsZXM6XG4+ICcsJ3MnKTsKICAgICAgYGBgCiAgICAgICBBdCB0aGlzIHBvaW50LCB0aGVyZSB3aWxsIGJlIG5vIHVzZXIgaW5wdXQvYWN0aW9ucyBuZWNlc3NhcnkgdW50aWwgYWxsIG9mIHRoZSAubWZmIGZpbGVzIGluIHRoZSAicGF0aFJhdyIgZGlyZWN0b3J5IGhhdmUgYmVlbiB1cGRhdGVkIGFuZCBzYXZlZCBpbnRvIHRoZSAicGF0aFN1YiIgZGlyZWN0b3J5LgogICAgICAgVGhlIGNvZGUgdGhhdCBhc2tzIHRoZSB1c2VyIGZvciB0aGUgcGF0aCB0byBIQVBQRSB3aWxsIHJ1biB3aGVuIHRoYXQgcHJvY2VzcyBoYXMgZmluaXNoZWQuCiAgICAgICBUaGUgZm9sbG93aW5nIHNlY3Rpb24gd2lsbCBkZXNjcmliZSB0aGUgY29kZSB1c2VkIHRvIGF1dG9tYXRlIHRoZSBwcm9jZXNzIG9mIHVwZGF0ZWQgLm1mZiBldmVudCB0YWdzIHRvIGluY2x1ZGUgYWNjdXJhY3kgaW5mb3JtYXRpb24gYXQgdGhlIHRyaWFsIGxldmVsLgogICAgICAgTW92ZSBvbiB0byBTdGVwIDMgd2hlbiB0aGUgcHJvY2VzcyBoYXMgY29tcGxldGVkLgoKICAgMS4gR2F0aGVyIGFuZCBtYW5hZ2UgaW5mb3JtYXRpb24gZnJvbSB0aGUgZGlyZWN0b3J5IGhvdXNpbmcgdGhlIHJhdyAoLm1mZikgZmlsZXMKICAgICAgCiAgICAgIGBgYAogICAgICAlIEhhdmUgTUFUTEFCIGdhdGhlciBhIGxpc3Qgb2YgcmF3IGZpbGVzIGhvdXNlZCBpbiBzcGVjaWZpZWQgbG9jYXRpb24gKHBhdGhSYXcpCiAgICAgIGRpckluZm8gPSBzdHJ1Y3QydGFibGUoZGlyKHBhdGhSYXcpKTsKCiAgICAgICUgUmVtb3ZlIGJsYW5rIHJvd3MKICAgICAgbm9OYW1lID0gc3RyY21wKGRpckluZm8ubmFtZSwgJy4nKSB8IHN0cmNtcChkaXJJbmZvLm5hbWUsICcuLicpOwogICAgICBkaXJJbmZvKG5vTmFtZSwgOikgPSBbXTsKICAgICAgYGBgCiAgIDEuIEdlbmVyYXRlIHZhcmlhYmxlcyBuZWNlc3NhcnkgZm9yIG1hbmFnaW5nIHJhdyBhbmQgdXBkYXRlZCBmaWxlcwogICAgICAtIFRoaXMgY29kZSB3aWxsIGdlbmVyYXRlIHRoZSBmdWxsIGZpbGVwYXRocyAoaW5jbHVkaW5nIGZpbGUgbmFtZSkgbmVjZXNzYXJ5IGZvciByZWFkaW5nIGluIGFuZCBzYXZpbmcgZWFjaCAubWZmIGZpbGUgYW5kIGl0cyB1cGRhdGVkIGNvdW50ZXJwYXJ0CiAgICAgIC0gSXQgd2lsbCBhbHNvIGdlbmVyYXRlIGFuIElEIHZhcmlhYmxlIGZvciBqb2luaW5nIHB1cnBvc2VzIGJhc2VkIG9uIHRoZSBleHBlY3RlZCBsb2NhdGlvbiBvZiB0aGUgc3ViamVjdCBuYW1lIGluIHRoZSBuYW1lIG9mIGVhY2ggZmlsZSAKCiAgICAgIGBgYAogICAgICAlIEdlbmVyYXRlIElEIHZhcmlhYmxlCiAgICAgIGRhdGFGaWxlcyA9IGRpckluZm8oOiwgIm5hbWUiKTsKICAgICAgCiAgICAgICUgQWRkIElEIHZhcmlhYmxlIHRvIGZpbGUgZGF0YQogICAgICBkYXRhRmlsZXMuSUQgPSBleHRyYWN0QmVmb3JlKGRhdGFGaWxlcy5uYW1lLCA4KTsKICAgICAgCiAgICAgICUgR2VuZXJhdGUgcGF0aCB0byByZWFkIHJhdyBkYXRhCiAgICAgIHJhd1BhdGhzID0gZGF0YUZpbGVzOwogICAgICByYXdQYXRocy5wYXRoID0gc3RyY2F0KHtwYXRoUmF3fSwgIi8iLCBkaXJJbmZvLm5hbWUpOwogICAgICByYXdQYXRocyA9IHJhd1BhdGhzKDosIFsiSUQiLCAicGF0aCJdKTsKICAgICAgCiAgICAgICUgR2VuZXJhdGUgcGF0aCB0byBzYXZlIHVwZGF0ZWQgdmVyc2lvbnMgb2YgdGhlIGRhdGEgKGNvbnRhaW5pbmcgYWNjdXJhY3kgaW5mbyBhdCB0cmlhbCBsZXZlbCkKICAgICAgc3ViUGF0aHMgPSBkYXRhRmlsZXM7CiAgICAgIHN1YlBhdGhzLnBhdGggPSBzdHJjYXQoe3BhdGhTdWJ9LCAiLyIsIHN1YlBhdGhzLklELCAiX3N1Yl9maXNoc2hhcmsubWZmIik7CiAgICAgIHN1YlBhdGhzID0gc3ViUGF0aHMoOiwgWyJJRCIsICJwYXRoIl0pOwogICAgICAKICAgICAgJSBKb2luIGZpbGVwYXRoIGRhdGF0YWJsZXMKICAgICAgbWVyZ2VQYXRocyA9IGpvaW4ocmF3UGF0aHMsIHN1YlBhdGhzLCAnS2V5cycsIHsnSUQnfSkKICAgICAgYGBgCiAgICAxLiBVc2UgYSBsb29wIHRvIHVwZGF0ZSB0aGUgZXZlbnQgdGFncyBpbiBlYWNoIC5tZmYgZmlsZSB0byByZWZsZWN0IGFjY3VyYWN5IG9mIHJlc3BvbnNlCiAgICAgICAtIEZvciBldmVyeSBmaWxlIGluY2x1ZGVkIGluIHRoZSAibWVyZ2VQYXRocyIgZGF0YXNldCwgTUFUTEFCIHdpbGwgcGVyZm9ybSB0aGUgZm9sbG93aW5nIGFjdGlvbnM6CiAgICAgICAgICAtIFNldCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgcmVwcmVzZW50aW5nIHRoZSBwYXRoIHRvIHJlYWQgaW4gdGhlIG9yaWdpbmFsIC5tZmYgZmlsZSBhbmQgc2F2ZSBpdHMgdXBkYXRlZCBjb3VudGVycGFydCAodXBkYXRlcyB3aXRoIGVhY2ggaXRlcmF0aW9uIG9mIHRoZSBsb29wKQogICAgICAgICAgLSBSZWFkIGluIHRoZSAubWZmIGZpbGUKICAgICAgICAgIC0gRXh0cmFjdCB0aGUgImV2ZW50IiBpbmZvcm1hdGlvbiBmcm9tIHRoZSAubWZmIGZpbGUgCiAgICAgICAgICAtIEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUgaXMgdXNhYmxlIGRhdGEgaW4gdGhlIGZpbGUgCiAgICAgICAgICAgICAtIFRoaXMgc3RlcCBwcmV2ZW50cyB0aGUgY29kZSBmcm9tIGVycm9yaW5nIG91dCBpZiBhIHN1YmplY3QgZGlkIG5vdCBtYWtlIGl0IHBhc3QgdGhlIHByYWN0aWNlIHRyaWFscwogICAgICAgICAgICAgLSBJZiB0aGUgZXZhbHVhdGlvbiBkZXRlcm1pbmVzIHRoYXQgdGhlcmUgaXMgTk9UIHVzYWJsZSBkYXRhIGluIHRoZSBwcmVzZW50IGZpbGUsIHRoZSBsb29wIHdpbGwganVtcCB0byB0aGUgbmV4dCBmaWxlCiAgICAgICAgICAtIENyZWF0ZSBhIHRhYmxlIGNvbnRhaW5pbmcgcmVzcG9uc2UgaW5mb3JtYXRpb24gKHJlc3BvbnNlIHZzIG5vIHJlc3BvbnNlIGFuZCByZWFjdGlvbiB0aW1lKSBhbmQgY29uZGl0aW9uIGluZm9ybWF0aW9uIChnbyB2cyBuby1nbykgYXQgdGhlIHRyaWFsIGxldmVsCiAgICAgICAgICAtIEV2YWx1YXRlIGVhY2ggdHJpYWwgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHJlc3BvbnNlIHdhcyBjb3JyZWN0IG9yIGluY29ycmVjdAogICAgICAgICAgICAgLSBGb3IgTm8tR28gdHJpYWxzLCByZXNwb25zZXMgYXJlIENPUlJFQ1QgaWYgdGhlcmUgd2FzIG5vIHJlc3BvbnNlIChpbmNvcnJlY3QgaWYgc3ViamVjdCBkaWQgcmVzcG9uZCkKICAgICAgICAgICAgIC0gRm9yIEdvIHRyaWFscywgcmVzcG9uc2VzIGFyZSBDT1JSRUNUIGlmIHRoZXJlIHdhcyBhIHJlc3BvbnNlIEFORCBzdWJqZWN0J3MgcmVhY3Rpb24gdGltZSB3YXMgYXQgbGVhc3QgMjAwIG1zIChpbmNvcnJlY3QgaWYgc3ViamVjdCBkaWQgbm90IHJlc3BvbmQgT1IgaWYgc3ViamVjdCByZXNwb25kZWQgdG9vIHF1aWNrbHkgZm9yIHJlc3BvbnNlIHRvIGJlIGNvbnNpZGVyZWQgInZhbGlkIikKICAgICAgICAgIC0gVXBkYXRlIHRoZSBldmVudCB0YWdzIGluIHRoZSAubWZmIGZpbGUgdG8gY29udGFpbiBhICJjIiBmb3IgY29ycmVjdCB0cmlhbHMgYW5kIGFuICJ4IiBmb3IgaW5jb3JyZWN0IHRyaWFscyAKICAgICAgICAgICAgIC0gVGhlIGMveCBpbmRpY2F0b3Igd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZnJvbnQgb2YgdGhlIGV4aXN0aW5nIGV2ZW50IHRhZyAoZS5nLiwgYEdvKytgIHdpbGwgYmVjb21lIGBjR28rK2ApCiAgICAgICAgICAtIEV4cG9ydCBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIC5tZmYgZmlsZSB3aXRoIGFjY3VyYWN5IGluZm9ybWF0aW9uIHRvIHRoZSBzcGVjaWZpZWQgbG9jYXRpb24gKCJwYXRoU3ViIikKCiAgICoqTk9URTogV2hlbiBleHBvcnRpbmcgRUVHIGRhdGEgZnJvbSBNQVRMQUIsIGl0IGlzIGFic29sdXRlbHkgbmVjZXNzYXJ5IGZvciB0aGUgZGF0YSB0byBiZSBvcmdhbml6ZWQgaW4gb3JkZXIgb2YgZXZlbnQgbGF0ZW5jeS4qKgogICAqKklmIHRoZSByb3dzIGFyZSBvdXQgb2Ygb3JkZXIsIGxhdGVuY3kgZXJyb3JzIG1heSBiZSBpbnRyb2R1Y2VkLioqCgogICAgICAtIENvcnJlY3Qgcm93IG9yZGVyIGNhbiBiZSBhY2hpZXZlZCBpbiAubWZmIGZpbGV0eXBlcyBieSBzb3J0aW5nIGFjY29yZGluZyB0byBlaXRoZXIgdGhlIGBsYXRlbmN5YCBjb2x1bW4gb3IgdGhlIGB1cmV2ZW50YCBjb2x1bW4gKGFzIHNob3duIGJlbG93KSAKCiAgICAgICBgYGAKICAgICAgIGZvciByb3cgPSAxOmhlaWdodChtZXJnZVBhdGhzKQogICAgICAgICAgICUgU3BlY2lmeSBwYXRocwogICAgICAgICAgIHJhd0ZvbGRlciA9IG1lcmdlUGF0aHN7cm93LCAicGF0aF9yYXdQYXRocyJ9CiAgICAgICAgICAgc3ViRm9sZGVyID0gbWVyZ2VQYXRoc3tyb3csICJwYXRoX3N1YlBhdGhzIn0KICAgIAogICAgICAgICAgICUgUmVhZCBpbiBFRUcgZGF0YQogICAgICAgICAgIEVFR3JhdyA9IHBvcF9tZmZpbXBvcnQoY2hhcihyYXdGb2xkZXIpLCAnY29kZScpCgogICAgICAgICAgICUgQ3JlYXRlIHRhYmxlIGZyb20gImV2ZW50IiBmaWVsZCBvZiByYXcgZGF0YQogICAgICAgICAgIEVFR2V2ZW50ID0gc3RydWN0MnRhYmxlKEVFR3Jhdy5ldmVudCkKCiAgICAgICAgICAgJSBDaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB1c2FibGUgcm93cwogICAgICAgICAgIGNoZWNrVmFycyA9IHN0cmNtcChFRUdldmVudC5Qcm9wZXJ0aWVzLlZhcmlhYmxlTmFtZXMsICdtZmZrZXlfY2VsJykKCiAgICAgICAgICAgJSBTa2lwIGZpbGVzIHdpdGhvdXQgbmVjZXNzYXJ5IHZhcmlhYmxlcwogICAgICAgICAgIGlmIG1heChjaGVja1ZhcnMpID09IDAKICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICBlbmQKCiAgICAgICAgICAgJSBDcmVhdGUgdGFibGUgd2l0aG91dCBwcmFjdGljZS90cmFpbmluZyB0cmlhbHMKICAgICAgICAgICBrZWVwUm93cyA9IHN0cmNtcChFRUdldmVudC5tZmZrZXlfY2VsLCAnNCcpCiAgICAgICAgICAgRUVHc3ViICA9IEVFR2V2ZW50KGtlZXBSb3dzLCA6KQoKICAgICAgICAgICAlIENoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIHVzYWJsZSByb3dzCiAgICAgICAgICAgY2hlY2tSb3dzID0gbWF4KGtlZXBSb3dzKQoKICAgICAgICAgICAlIFNraXAgZmlsZXMgd2l0aCBubyB1c2FibGUgcm93cwogICAgICAgICAgIGlmIGNoZWNrUm93cyA9PSAwCiAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgZW5kCgogICAgICAgICAgICUgR2V0IHJlc3BvbnNlIGluZm8gYXQgdHJpYWwgbGV2ZWwKICAgICAgICAgICBFRUdyZXNwID0gdGFibGUoRUVHc3ViLm1mZmtleV9vYnMsIEVFR3N1Yi5tZmZrZXlfZXZhbCwgRUVHc3ViLm1mZmtleV9ydGltKQogICAgICAgICAgIEVFR3Jlc3AgPSBybW1pc3NpbmcoRUVHcmVzcCkKICAgICAgICAgICBFRUdyZXNwID0gcmVuYW1ldmFycyhFRUdyZXNwLCBbIlZhcjEiLCAiVmFyMiIsICJWYXIzIl0sIFsiVHJpYWwiLCAiRXZhbCIsICJSVGltZSJdKQoKICAgICAgICAgICAlIEdldCBjb25kaXRpb24gaW5mbyBhdCB0cmlhbCBsZXZlbAogICAgICAgICAgIEVFR2NvbmRzID0gdGFibGUoRUVHc3ViLm1mZmtleV9vYnMsIEVFR3N1Yi50eXBlKQogICAgICAgICAgIEVFR2NvbmRzID0gcmVuYW1ldmFycyhFRUdjb25kcywgWyJWYXIxIiwgIlZhcjIiXSwgWyJUcmlhbCIsICJDb25kIl0pCiAgICAgICAgICAga2VlcENvbmRzID0gc3RyY21wKEVFR2NvbmRzLkNvbmQsICdHbysrJykgfCBzdHJjbXAoRUVHY29uZHMuQ29uZCwgJ05HKysnKQogICAgICAgICAgIEVFR2NvbmQgPSBFRUdjb25kcyhrZWVwQ29uZHMsIDopCgogICAgICAgICAgICUgTWVyZ2UgZGF0YXNldHMKICAgICAgICAgICBFRUd0cmlhbHMgPSBqb2luKEVFR2NvbmQsIEVFR3Jlc3ApCgogICAgICAgICAgIEVFR3RyaWFscy5SVGltZSA9IGNlbGxmdW4oQHN0cjJudW0sIEVFR3RyaWFscy5SVGltZSkKICAgICAgICAgICAlIEV2YWx1YXRlIHRyaWFscyBmb3IgY29ycmVjdC1uZXNzIG9mIHJlc3BvbnNlCiAgICAgICAgICAgY29ycmVjdCA9IHN0cmNtcChFRUd0cmlhbHMuQ29uZCwgJ0dvKysnKSAmIHN0cmNtcChFRUd0cmlhbHMuRXZhbCwgJzEnKSAmIEVFR3RyaWFscy5SVGltZSA+IDIwMCB8IHN0cmNtcChFRUd0cmlhbHMuQ29uZCwgJ05HKysnKSAmIHN0cmNtcChFRUd0cmlhbHMuRXZhbCwgJzAnKQogICAgICAgICAgIEVFR3RyaWFscy5BY2MgPSBjb3JyZWN0CgoKICAgICAgICAgICAlIENyZWF0ZSBuZXcgY29kZSB0YWdzIGluY2x1ZGluZyBhY2N1cmFjeSBpbmZvcm1hdGlvbgogICAgICAgICAgIEVFR3RyaWFscy5uZXdDb2RlKEVFR3RyaWFscy5BY2MgJiBzdHJjbXAoRUVHdHJpYWxzLkNvbmQsICdHbysrJykpID0geydjR28rKyd9CiAgICAgICAgICAgRUVHdHJpYWxzLm5ld0NvZGUofkVFR3RyaWFscy5BY2MgJiBzdHJjbXAoRUVHdHJpYWxzLkNvbmQsICdHbysrJykpID0geyd4R28rKyd9CiAgICAgICAgICAgRUVHdHJpYWxzLm5ld0NvZGUoRUVHdHJpYWxzLkFjYyAmIHN0cmNtcChFRUd0cmlhbHMuQ29uZCwgJ05HKysnKSkgPSB7J2NORysrJ30KICAgICAgICAgICBFRUd0cmlhbHMubmV3Q29kZSh+RUVHdHJpYWxzLkFjYyAmIHN0cmNtcChFRUd0cmlhbHMuQ29uZCwgJ05HKysnKSkgPSB7J3hORysrJ30KCiAgICAgICAgICAgJSBTdWJzZXQgaW5mb3JtYXRpb24gZm9yIG1lcmdlCiAgICAgICAgICAgRUVHbWVyZ2UgPSBFRUd0cmlhbHMoOiwgeydUcmlhbCcsICdDb25kJywgJ25ld0NvZGUnfSkKCiAgICAgICAgICAgJSBQcmVwIGtleSBpbiBvcmlnaW5hbCBkYXRhCiAgICAgICAgICAgRUVHZXZlbnQua2V5ID0gc3RyY2F0KEVFR2V2ZW50Lm1mZmtleV9vYnMsIEVFR2V2ZW50LnR5cGUpCgogICAgICAgICAgICUgUHJlcCBrZXkgaW4gbWVyZ2UgZGF0YQogICAgICAgICAgIEVFR21lcmdlLmtleSA9IHN0cmNhdChFRUdtZXJnZS5UcmlhbCwgRUVHbWVyZ2UuQ29uZCkKICAgICAgICAgICBFRUdtZXJnZSA9IEVFR21lcmdlKDosIHsna2V5JywgJ25ld0NvZGUnfSkKCiAgICAgICAgICAgJSBNZXJnZSBuZXcgY29kZXMgd2l0aCBldmVudCB0YWJsZQogICAgICAgICAgIEVFR25ldyA9IG91dGVyam9pbihFRUdldmVudCwgRUVHbWVyZ2UpCgogICAgICAgICAgICUgUmVwbGFjZSBjb2RlcyB3aGVyZSBuZXcgY29kZSBpcyBuZWVkZWQKICAgICAgICAgICBFRUduZXcuY29kZSh+c3RyY21wKEVFR25ldy5uZXdDb2RlLCAnJykpID0gRUVHbmV3Lm5ld0NvZGUofnN0cmNtcChFRUduZXcubmV3Q29kZSwgJycpKQogICAgICAgICAgIEVFR25ldy50eXBlKH5zdHJjbXAoRUVHbmV3Lm5ld0NvZGUsICcnKSkgPSBFRUduZXcubmV3Q29kZSh+c3RyY21wKEVFR25ldy5uZXdDb2RlLCAnJykpCgogICAgICAgICAgICUgQXJyYW5nZSB0YWJsZSBpbiBvcmRlciBvZiBldmVudCAoQ1JVQ0lBTCBmb3IgY29ycmVjdCBleHBvcnQpCiAgICAgICAgICAgRUVHbmV3ID0gc29ydHJvd3MoRUVHbmV3LCAndXJldmVudCcpCiAgICAgICAgICAKICAgICAgICAgICAlIENvbnZlcnQgdGFibGUgYmFjayB0byBzdHJ1Y3QgYW5kIHJlc3RvcmUgb3JpZ2luYWwgZGltZW5zaW9ucwogICAgICAgICAgIEVFR25ldyA9IHRhYmxlMnN0cnVjdChFRUduZXcoOiwgMToyOSkpCiAgICAgICAgICAgRUVHbmV3ID0gcmVzaGFwZShFRUduZXcsIFsxLCBoZWlnaHQoRUVHbmV3KV0pCgogICAgICAgICAgICUgUmVwbGFjZSBldmVudCB0YWJsZShzKSBpbiBvcmlnaW5hbCBzdHJ1Y3QKICAgICAgICAgICBFRUdyYXcuZXZlbnQgPSBFRUduZXcKICAgICAgICAgICBFRUdyYXcudXJldmVudCA9IHRhYmxlMnN0cnVjdChzdHJ1Y3QydGFibGUoRUVHbmV3KDosIDE6MjgpKSkKCiAgICAgICAgICAgJSBFeHBvcnQgdXBkYXRlZCBmaWxlCiAgICAgICAgICAgcG9wX21mZmV4cG9ydChFRUdyYXcsIGNoYXIoc3ViRm9sZGVyKSkKICAgICAgIGVuZCAKICAgICAgIGBgYAoKICAgIAoxLiBSdW4gdGhlIEhBUFBFIFBpcGVsaW5lCiAgIC0gVGhpcyBzZWN0aW9uIGlzIGRlc2lnbmVkIHRvIHJlbHkgb24gdXNlciBpbnB1dC4KICAgLSBXaGVuIHRoZSBwcmlvciBzdGVwcyBoYXZlIGZpbnNpaGVkLCBhIG1lc3NhZ2Ugd2lsbCBhcHBlYXIgaW4gdGhlIGNvbnNvbGUgcHJvbXB0aW5nIHlvdSB0byBlbnRlciB0aGUgZmlsZXBhdGggdG8gdGhlIGxvY2F0aW9uIG9mIHRoZSBIQVBQRSBwcmUtcHJvY2Vzc2luZyBmaWxlIHlvdSB3aXNoIHRvIHJ1bgogICAtIE9uY2UgdGhlIHBhdGggaXMgZW50ZXJlZCwgTUFUTEFCIHdpbGwgcnVuIHRoZSBmaWxlCgogICBgYGAKICAgJSBTZXQgcGF0aCB0byBIQVBQRSBwcmUtcHJvY2Vzc2luZyBzY3JpcHQKICAgaGFwcGVSdW4gPSBpbnB1dCgnRW50ZXIgdGhlIGZ1bGwgcGF0aCB0byB0aGUgSEFQUEUgcHJlLXByb2Nlc3NpbmcgZmlsZTpcbj4gJywncycpIDsKCiAgICUgQ2FsbCBhbmQgcnVuIEhBUFBFIHByZS1wcm9jZXNzaW5nIHNjcmlwdAogICBydW4oaGFwcGVSdW4pOwogICBgYGAKMS4gRW50ZXIgSEFQUEUgaW5wdXRzIAogICAtIFNlZSB0aGUgZm9sbG93aW5nIHNlY3Rpb24gZm9yIEhBUFBFIGlucHV0cyBmb3IgdGhlIEZpc2gvU2hhcmsgdGFzawoKQWZ0ZXIgdGhlIEhBUFBFIGlucHV0cyBhcmUgZW50ZXJlZCwgbm8gbW9yZSB1c2VyIGludGVyYWN0aW9uIGlzIHJlcXVpcmVkIGZvciB0aGUgc2NyaXB0IHRvIGRvIGl0cyBqb2IuClRoZSBIQVBQRSBwaXBlbGluZSB3aWxsIHJ1biwgYW5kIHRoZSByZW1haW5pbmcgTUFUTEFCIGNvZGUgaW4gdGhlIHNjcmlwdCBmaWxlIHdpbGwgZXZhbHVhdGUgdGhlIGZpbGVzIG91dHB1dHRlZCBieSBIQVBQRSBhbmQgbW92ZSB0aGVtIHRvIHRoZSBhcHByb3ByaWF0ZSBsb2NhdGlvbnMgYmFzZWQgb24gdGhpcyBldmFsdWF0aW9uLiAKU2VlIFtGaXNoL1NoYXJrIFBvc3QtSEFQUEUgU3RlcHNdKCNGaXNoU2hhcmtQb3N0KSBmb3IgYSBkZXRhaWxlZCBleHBsYW5hdGlvbiBvZiB0aGUgY29kZSB1c2VkIHRvIGFjY29tcGxpc2ggdGhpcy4KCiMjIyBIQVBQRSBJbnB1dHMgeyNpbnB1dEZpc2hTaGFya0hBUFBFfQoKMS4gSWYgeW91IGFyZSBub3QgdXNpbmcgdGhlIE1BVExBQiBzY3JpcHRzIGRlc2NyaWJlZCBhYm92ZSwgeW91IG11c3QgZmlyc3Qgb3BlbiB0aGUgSEFQUEUgcGlwZWxpbmUgVjQgc2NyaXB0IGluIE1BVExBQiBhbmQgY2xpY2sgIlJ1biIKICAgLSBUaGlzIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBsb2NhdGlvbiB0byB3aGljaCB5b3UgbWFwcGVkIHRoZSBIQVBQRSBHaXQgcmVwbyAoZS5nLiBgRG9jdW1lbnRzL0dpdEh1Yi9IQVBQRS8xLiBwcmUtcHJvY2Vzcy9IQVBQRV92NC5tYCkKMS4gVXNlciBJbnB1dHMKICAgIC0gRW50ZXIgdGhlIHBhdGggdG8gdGhlIGZvbGRlciBjb250YWluaW5nIHRoZSBkYXRhc2V0LgogICAgLSBTZWxlY3QgYHJhd2AKICAgIC0gTG9hZCBwcmUtZXhpc3Rpbmcgc2V0IG9mIGlucHV0IHBhcmFtZXRlcjogCiAgICAgICAgLSBgTmAgaWYgdGhpcyBpcyB5b3VyIGZpcnN0IHRpbWUgcnVubmluZyBkYXRhIHRocm91Z2ggdGhlIHBpcGVsaW5lLgogICAgICAgIC0gYFlgIGlmIHlvdSBoYXZlIGRlY2lkZWQgb24gYSBzZXQgb2YgcGFyYW1ldGVycy4KICAgICAgICBFbnRlciB0aGUgcGF0aCB0byB0aGUgZm9sZGVyIGNvbnRhaW5pbmcgdGhlIGlucHV0IHBhcmFtZXRlcnMuCiAgICAtIExvdyBkZW5zaXR5IGRhdGE6IGBOYAogICAgLSBEYXRhIHR5cGU6IGB0YXNrYAogICAgLSBQZXJmb3JtaW5nIGV2ZW50LXJlbGF0ZWQgcG90ZW50aWFsIChFUlApIGFuYWx5c2lzOiBgWWAKICAgIC0gRW50ZXIgdGhlIHRhc2sgb25zZXQgdGFncwogICAgICAgIC0gQ29ycmVjdCBHbzogYGNHbysrYAogICAgICAgIC0gSW5jb3JyZWN0IEdvOiBgeEdvKytgCiAgICAgICAgLSBDb3JyZWN0IE5vR286IGBjTkcrK2AKICAgICAgICAtIEluY29ycmVjdCBOb0dvOiBgeE5HKytgCiAgICAgICAgLSBgZG9uZWAKICAgIC0gRG8gbXVsdGlwbGUgb25zZXQgdGFncyBiZWxvbmcgdG8gYSBzaW5nbGUgY29uZGl0aW9uPyBgTmAKICAgIC0gRmlsZSBmb3JtYXQ6IGA1YAogICAgLSBBY3F1aXNpdGlvbiBsYXlvdXQgdHlwZTogYDJgCiAgICAtIE51bWJlciBvZiBjaGFubmVsczogYDEyOGAKICAgIC0gRG8geW91IGhhdmUgYWRkaXRpb25hbCB0eXBlIGZpZWxkcyBiZXNpZGVzICJjb2RlIj8gYE5gCiAgICAtIFNlbGVjdCBjaGFubmVscyBvZiBpbnRlcmVzdDogYGFsbGAKICAgIC0gRnJlcXVlbmN5IG9mIGVsZWN0cmljYWwgbm9pY2UgaW4gSHo6IGA2MGAKICAgIC0gQXJlIHRoZXJlIGFueSBhZGRpdGlvbmFsIGZyZXF1ZW5jaWVzLCAoZS5nLiwgaGFybW9uaWNzKSB0byByZWR1Y2U/IGBOYAogICAgLSBMaW5lIE5vaXNlIHJlZHVjdGlvbiBtZXRob2Q6IGBub3RjaGAKICAgICAgICAtIExvdyBjdXRvZmY6IGA1OWAKICAgICAgICAtIGhpZ2ggY3V0b2ZmOiBgNjFgCiAgICAtIFJlc2FtcGxlOiBgTmAKICAgIC0gRmlsdGVyCiAgICAgICAgLSBMb3cgUGFzcyBDdXRvZmY6IGAzMGAKICAgICAgICAtIEhpZ2ggUGFzcyBDdXRvZmY6IGAuMWAKICAgIC0gQ2hvb3NlIGEgZmlsdGVyOiBgZmlyYAogICAgLSBCYWQgQ2hhbm5lbCBEZXRlY3Rpb246IGBZYAogICAgICAgIC0gYGFmdGVyYCB3YXZlbGV0IHRocmVzaG9sZGluZwogICAgLSBFQ0dvbmU6IGBOYAogICAgLSBXYXZlbGV0IFRocmVzaG9sZGluZwogICAgICAgIC0gYGRlZmF1bHRgCiAgICAgICAgLSBUaHJlc2hvbGQgcnVsZTogYGhhcmRgCiAgICAtIE11c2NJTDogYE5gCiAgICAtIFNlZ21lbnRhdGlvbjogYFlgCiAgICAgICAgLSBTdGFydGluZyBwYXJhbWV0ZXIgZm9yIHN0aW11bHVzOiBgLTIwMGAKICAgICAgICAtIEVuZGluZyBwYXJhbWV0ZXIgZm9yIHN0aW11bHVzOiBgMTAwMGAKICAgICAgICAtIFRhc2sgb2Zmc2V0OiBgMTdgCiAgICAtIEJhc2VsaW5lIENvcnJlY3Rpb246IGBZYAogICAgICAgIC0gQmFzZWxpbmUgQ29ycmVjdGlvbiBzdGFydDogYC0yMDBgCiAgICAgICAgLSBCYXNlbGluZSBDb3JyZWN0aW9uIGVuZDogYDBgCiAgICAtIEludGVycG9sYXRpb246IGBZYAogICAgLSBTZWdtZW50IFJlamVjdGlvbjogYFlgCiAgICAgICAgLSBTZWdtZW50IFJlamVjdGlvbiBNZXRob2Q6IGBhbXBsaXR1ZGVgCiAgICAgICAgICAgIC0gbWluaW11bSBzZWdtZW50IHJlamVjdGlvbiB0aHJlc2hvbGQ6IGAtMTUwYAogICAgICAgICAgICAtIG1heGltdW0gc2VnbWVudCByZWplY3Rpb24gdGhyZXNob2xkOiBgMTUwYAogICAgICAgICAgICAtIHNlZ21lbnQgcmVqZWN0aW9uIGJhc2VkIG9uIGFsbCBjaGFubmVscyBvciBST0k6IGBhbGxgCiAgICAtIFJlLXJlZmVyZW5jaW5nOiBgWWAKICAgICAgICAtIERvZXMgeW91ciBkYXRhIGNvbnRhaW4gYSBmbGF0bGluZSBvciBhbGwgemVybyByZWZlcmVuY2UgY2hhbm5lbD8gYE5gCiAgICAgICAgLSByZS1yZWZlcmVuY2luZyBtZXRob2Q6IGBhdmVyYWdlYAogICAgLSBTYXZlIGZvcm1hdDogYDFgCiAgICAtIFZpc3VhbGl6YXRpb25zOiBgTmAKICAgIC0gUGFyYW1ldGVyIGZpbGUgc2F2ZSBuYW1lOiBgZGVmYXVsdGAKCiMjIyBGaXNoL1NoYXJrIFBvc3QtSEFQUEUgU3RlcHMgeyNmaXNoU2hhcmtQb3N0fQoKVGhpcyBzZWN0aW9uIGRldGFpbHMgdGhlIGFjdGlvbnMgcGVyZm9ybWVkIGJ5IHRoZSBNQVRMQUIgc2NyaXB0cyBvbmNlIEhBUFBFIGlzIGNvbXBsZXRlZC4KVGhlc2UgYWN0aW9ucyB3aWxsIHRha2UgcGxhY2UgYXV0b21hdGljYWxseSB1cG9uIGNvbXBsZXRpb24gb2YgdGhlIEhBUFBFIHBpcGVsaW5lLgoqKk5vIHVzZXIgaW5wdXRzIG9yIGFjdGlvbnMgYXJlIG5lY2Vzc2FyeSBhdCB0aGlzIHN0YWdlLioqCgoxLiBFeGNsdWRlIGZpbGVzIHRoYXQgZG9uJ3QgaGF2ZSBhbnkgb3V0cHV0IGRhdGEgZnJvbSB0aGUgZGF0YXNldCAoY29udGFpbmluZyBmaWxlbmFtZSBhbmQgcXVhbGl0eSByZXBvcnRzIGZyb20gSEFQUEUgcGlwZWxpbmUpIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGFzc2VzcyBmaWxlIHF1YWxpdHkKICAgLSBUaGlzIHN0ZXAgaXMgaW1wb3J0YW50IGJlY2F1c2UgImVtcHR5IiBmaWxlcyBkb24ndCBwbGF5IG5pY2VseSB3aXRoIHRoZSBjb2RlIHVzZWQgdG8gZXZhbHVhdGUgZmlsZXMgdGhhdCBoYXZlIHNvbWUgZGF0YSBpbiB0aGVtIChldmVuIGlmIHRoZSBkYXRhIGRvIG5vdCBtZWV0IHRocmVzaG9sZCkKICAgLSBUaGlzIGNvZGUgcmVsaWVzIG9uIEhBUFBFJ3MgcXVhbGl0eSBkYXRhIHRoYXQgcmVtYWlucyBpbiB0aGUgTUFUTEFCIGVudmlyb25tZW50IGFmdGVyIHRoZSBwaXBlbGluZSBoYXMgZmluaXNoZWQuCgogICBgYGAKICAgJSBDcmVhdGUgYSBsaXN0IG9mIGZpbGVzIHRoYXQgcmVjZWl2ZWQgc29tZSBraW5kIG9mIGVycm9yIG1lc3NhZ2UKICAgbm9UYWdzID0gYW55KHN0cmNtcChkYXRhUUMsICdOT19UQUdTJyksIDIpOwogICBhbGxSZWogPSBhbnkoc3RyY21wKGRhdGFRQywgJ0FMTF9TRUdfUkVKJyksIDIpOwogICBvbmVSZWogPSBhbnkoc3RyY21wKGRhdGFRQywgJ1JFSl9PTkVfU0VHJyksIDIpOwogICBlcnJvciA9IGFueShzdHJjbXAoZGF0YVFDLCAnRVJST1InKSwgMik7CiAgIGxvYWRGYWlsID0gYW55KHN0cmNtcChkYXRhUUMsICdMT0FEX0ZBSUwnKSwgMik7CgogICAlIENvbWJpbmUgZmlsZW5hbWVzIHdpdGggcXVhbGl0eSBkYXRhIChmb3Igc29tZSByZWFzb24sIHRoZXkgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IGNvbm5lY3RlZCBieSBIQVBQRSkKICAgZGF0YVFDTmV3ID0gW0ZpbGVOYW1lcycsIGRhdGFRQ107CgogICAlIFJlbW92ZSBhbGwgZmlsZXMgaW4gdGhlIGFib3ZlIGxpc3RzICh0aG9zZSByZWNlaXZpbmcgZXJyb3JzKSBmcm9tIHRoZSBxdWFsaXR5IGRhdGEKICAgZGF0YVFDTmV3KG5vVGFncyB8IGFsbFJlaiB8IGVycm9yIHwgbG9hZEZhaWwgfCBvbmVSZWosIDopID0gW107CgogICAlIENyZWF0ZSBsaXN0IG9mIHZhcmlhYmxlIG5hbWVzIGZvciBxdWFsaXR5IGRhdGEKICAgZGF0YVFDbmFtZXNOZXcgPSBbIkZpbGUiLCBkYXRhUUNuYW1lc107CiAgIAogICAlIFNhdmUgdGhlIGRhdGEgYXMgYSB0YWJsZSBmb3IgZWFzZSBvZiB1c2UgaW4gc3Vic2VxdWVudCBzdGVwcwogICBxY1RhYmxlID0gY2VsbDJ0YWJsZShkYXRhUUNOZXcsICdWYXJpYWJsZU5hbWVzJywgZGF0YVFDbmFtZXNOZXcpOwoKICAgJSBTdWJzZXQgdG8gSUQgYW5kIHRocmVzaG9sZCBpbmZvcm1hdGlvbgogICB0ZXN0SW5mbyA9IHFjVGFibGUoOiwgWyJpZFdhdmUiLCAiRmlsZSIsICJUZXN0Il0pOwogICBgYGAKCjIuIElkZW50aWZ5IHRoZSBmaWxlcyB0aGF0IG1lZXQgKG9yIGRvbid0IG1lZXQpIHRoZSB0aHJlc2hvbGQKCiAgIGBgYAogICAlIENyZWF0ZSBhIGxpc3Qgb2YgZmlsZXMgKGkuZS4sIHJvd3MgaW4gdGhlIHRhYmxlKSB0aGF0IG1lZXQgdGhyZXNob2xkCiAgIHRocmVzaG9sZFRlc3QgPSBxY1RhYmxlLigiTnVtYmVyX2NORysrX1NlZ3NfUG9zdC1TZWdfUmVqIikgPj0gdHJpYWxDdXRvZmYgJiBxY1RhYmxlLigiTnVtYmVyX2NHbysrX1NlZ3NfUG9zdC1TZWdfUmVqIikgPj0gdHJpYWxDdXRvZmY7CgogICAlIEFkZCBhIHZhcmlhYmxlIHRvIHRoZSBxdWFsaXR5IGRhdGEgdGFibGUgdGhhdCBpbmNsdWRlIHdoZXRoZXIgb3Igbm90IHRoZSBmaWxlIG1lZXQgdGhyZXNob2xkCiAgIHFjVGFibGUuVGVzdCA9IHRocmVzaG9sZFRlc3Q7CiAgIGBgYAoKMS4gQWRkIGFuIGlkZW50aWZ5aW5nIHZhcmlhYmxlIHRvIGJlIHVzZWQgZm9yIGRhdGEgam9pbmluZyBkb3duIHRoZSBsaW5lCiAgIC0gVGhpcyB2YXJpYWJsZSBpcyBnZW5lcmF0ZWQgdXNpbmcgaXRzIGV4cGVjdGVkIGxvY2F0aW9uIGluIHRoZSBmaWxlIG5hbWUgKGkuZS4sIGhvdyBtYW55IHRleHQgY2hhcmFjdGVycyAiaW4iIGl0IGlzKQoKICAgYGBgCiAgICUgR2VuZXJhdGUgSURzIGJhc2VkIG9uIEZpbGUgdmFyaWFibGUKICAgaWRXYXZlUUMgPSBleHRyYWN0QmVmb3JlKHFjVGFibGUuRmlsZSwgOCk7CgogICAlIEFwcGVuZCBJRCB2YXJpYWJsZSB0byBxdWFsaXR5IGRhdGEKICAgcWNUYWJsZS5pZFdhdmUgPSBpZFdhdmVRQzsKICAgYGBgCgoxLiBDcmVhdGUgYSBzdWJzZXR0ZWQgZGF0YXNldCBjb25hdGFpbmluZyBvbmx5IHRoZSBgaWRXYXZlYCwgZmlsZSBuYW1lLCBhbmQgInRlc3QiIHJlc3VsdHMgKGkuZS4sIHdoZXRoZXIgYSBnaXZlbiBmaWxlIG1lZXRzIHRoZSBzcGVjaWZpZWQgY3V0b2ZmIHRocmVzaG9sZCBmb3IgaW5jbHVzaW9uKQoKICAgYGBgCiAgICUgU3Vic2V0IHRvIElEIGFuZCB0aHJlc2hvbGQgaW5mb3JtYXRpb24KICAgdGVzdEluZm8gPSBxY1RhYmxlKDosIFsiaWRXYXZlIiwgIkZpbGUiLCAiVGVzdCJdKTsKICAgCiAgIGZwcmludGYoJ0Fzc2Vzc21lbnQgQ29tcGxldGUgXG4nKTsKICAgYGBgCgoxLiBHZW5lcmF0ZSBhIGxpc3Qgb2YgZmlsZXMgb3V0cHV0dGVkIGJ5IEhBUFBFCgogICBgYGAKICAgJSBHZW5lcmF0ZSBwYXRoIGZvciBIQVBQRSBwcmUtcHJvY2Vzc2luZyBvdXRwdXQgKHVzaW5nIHRoZSBIQVBQRSBlbnZpcm9ubWVudCB2YXJpYWJsZSBmcm9tIHVzZXIncyBpbnB1dCBvZiBsb2NhdGlvbiBvZiByYXcgZGF0YSBmb3IgcHJvY2Vzc2luZykKICAgaW5wdXRQYXRoID0gc3RyY2F0KHNyY0RpciwgIlw1IC0gcHJvY2Vzc2VkIik7CgogICAlIFJlYWQgaW4gbGlzdCBvZiBmaWxlcyBvdXRwdXR0ZWQgZnJvbSBIQVBQRSAKICAgcHJlcHJvY2Vzc2luZ091dHB1dCA9IGRpcihpbnB1dFBhdGgpOwogICAKICAgJSBSZW1vdmUgImVtcHR5IiByb3dzIAogICBwcmVwcm9jZXNzaW5nT3V0cHV0ID0gcHJlcHJvY2Vzc2luZ091dHB1dCh+aXNtZW1iZXIoe3ByZXByb2Nlc3NpbmdPdXRwdXQubmFtZX0sIHsnLicsICcuLid9KSk7CiAgIAogICAlIFNhdmUgZGF0YSBhcyBhIHRhYmxlIGZvciBlYXNlIG9mIGxhdGVyIHVzZQogICBwcmVwcm9jZXNzaW5nT3V0cHV0ID0gc3RydWN0MnRhYmxlKHByZXByb2Nlc3NpbmdPdXRwdXQpOwogICAKICAgJSBTdWJzZXQgdG8gZmlsZSBpbmZvCiAgIGZpbGVJbmZvID0gcHJlcHJvY2Vzc2luZ091dHB1dCg6LCBbIm5hbWUiLCAiZm9sZGVyIl0pOwogICBgYGAKMS4gU2VsZWN0IG9ubHkgZGVzaXJlZCBmaWxlcyB0byBiZSBtb3ZlZC9jb3BpZWQKICAgLSBDdXJyZW50bHksIHdlIGRvbid0IGRvIGFueXRoaW5nIHdpdGggdGhlICJJbmRpdmlkdWFsIFRyaWFsIiBmaWxlcyBvdXRwdXR0ZWQgYnkgSEFQUEUuCiAgIFRoZXNlIGZpbGVzIGFyZSBxdWl0ZSBsYXJnZSBhbmQgdGFrZSBhIGxvbmcgdGltZSB0byBtb3ZlLCBzbyBpdCBpcyBtb3JlIGVmZmljaWVudCB0byBqdXN0IHJlbW92ZSB0aGVtIGZyb20gdGhlIGRhdGEgYW5kIG5vdCB3b3JyeSBhYm91dCBtb3ZpbmcgdGhlbSBhbnl3aGVyZS4KCiAgIGBgYAogICAlIFN1YnNldCB0byBkZXNpcmVkIGZpbGVzIChBdmVPdmVyVHJpYWwpCiAgIGZpbGVTdWJzZXQgPSBmaWxlSW5mbyhjb250YWlucyhmaWxlSW5mby5uYW1lLCAiQXZlT3ZlclRyaWFscyIpLCA6KTsKICAgYGBgCjEuIEFkZCBjb25kaXRpb24sIElELCBhbmQgdGhyZXNob2xkLXJlbGF0ZWQgdmFyaWFibGVzIHRvIHRoZSBmaWxlIGRhdGEKICAgLSBOT1RFOiBUaGUgdmFsdWUgZm9yIGBDb25kaXRpb25gIHZhcmlhYmxlIChpLmUuLCAiY0dvIiBvciAiY05vR28iKSBzaG91bGQgbWF0Y2ggdGhlIG5hbWUgb2YgdGhlIGNvbmRpdGlvbi1zcGVjaWZpYyBmb2xkZXJzIHlvdSB3aXNoIHRoZSBmaWxlcyB0byBzYXZlIHRvIHdpdGhpbiB0aGUgcHJvY2Vzc2luZyByZXBvLgoKICAgCiAgIGBgYAogICAlIEdlbmVyYXRlIGxpc3Qgb2YgSURzIGJhc2VkIG9uIGZpbGUgbmFtZSB2YXJpYWJsZQogICBpZFdhdmVGUyA9IGV4dHJhY3RCZWZvcmUoZmlsZVN1YnNldC5uYW1lLCA4KTsKICAgCiAgICUgQWRkIElEIGxpc3QgdG8gZmlsZSBkYXRhCiAgIGZpbGVTdWJzZXQuaWRXYXZlID0gaWRXYXZlRlM7CiAgIAogICAlIEdlbmVyYXRlIGxpc3Qgb2YgZmlsZXMgYmVsb25naW5nIHRvIGVhY2ggY29uZGl0aW9uIGJhc2VkIG9uIGZpbGUgbmFtZSB2YXJpYWJsZQogICBjR28gPSBjb250YWlucyhmaWxlU3Vic2V0Lm5hbWUsICJjR28rKyIpOwogICBjTm9HbyA9IGNvbnRhaW5zKGZpbGVTdWJzZXQubmFtZSwgImNORysrIik7CiAgIHhHbyA9IGNvbnRhaW5zKGZpbGVTdWJzZXQubmFtZSwgInhHbysrIik7CiAgIHhOb0dvID0gY29udGFpbnMoZmlsZVN1YnNldC5uYW1lLCAieE5HKysiKTsKCiAgICUgQ3JlYXRlIGVtcHR5IHZhcmlhYmxlIGZvciBjb25kaXRpb24KICAgZmlsZVN1YnNldC5jb25kID0gY2VsbChzaXplKGZpbGVTdWJzZXQsIDEpLCAxKTsKCiAgICUgRmlsbCBpbiBjb25kaXRpb24gdmFyaWFibGUgYmFzZWQgb24gdGhlIGxpc3RzIGdlbmVyYXRlZCBhYm92ZQogICBmaWxlU3Vic2V0LmNvbmQoY0dvKSA9IHsnY0dvJ307CiAgIGZpbGVTdWJzZXQuY29uZChjTm9HbykgPSB7J2NOb0dvJ307CiAgIGZpbGVTdWJzZXQuY29uZCh4R28pID0geyd4R28nfTsKICAgZmlsZVN1YnNldC5jb25kKHhOb0dvKSA9IHsneE5vR28nfTsKICAgZmlsZVN1YnNldC5jb25kKH5jR28gJiB+Y05vR28gJiB+eEdvICYgfnhOb0dvKSA9IHsnQWxsJ307CgogICAlIEpvaW4gdGhyZXNob2xkIHRlc3QgaW5mb3JtYXRpb24KICAgZmlsZVRlc3QgPSBqb2luKGZpbGVTdWJzZXQsIHRlc3RJbmZvKTsKICAgYGBgCjEuIFByZXBhcmUgZGF0YSB0YWJsZSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IGZpbGVzIHRoYXQgbWV0IHRoZSB0aHJlc2hvbGQKICAgLSBUaGUgZGF0YSBnZW5lcmF0ZWQgaGVyZSBhcmUgcHJlcGFyaW5nIHRvIGNvcHkgdGhlIC50eHQgZmlsZXMgb3V0cHV0dGVkIGJ5IEhBUFBFIGludG8gYSBmb2xkZXIgY29udGFpbmluZyBhbGwgZmlsZXMgdGhhdCBhcmUgc3VpdGFibGUgZm9yIFBDQQoKICAgYGBgCiAgICUgQ3JlYXRlIGEgc2VwYXJhdGUgdGFibGUgZm9yIG9ubHkgZmlsZXMgdGhhdCBtZWV0IHRocmVzaG9sZAogICBtb3ZpbmdJbmZvID0gZmlsZVRlc3QoZmlsZVRlc3QuVGVzdCwgOik7CgogICAlIENyZWF0ZSBlbXB0eSBjb2x1bW5zIGZvciBmaWxlcGF0aCB2YXJpYWJsZXMKICAgbW92aW5nSW5mby5kZXN0aW5hdGlvbiA9IGNlbGwoc2l6ZShtb3ZpbmdJbmZvLCAxKSwgMSk7CiAgIG1vdmluZ0luZm8ub3JpZ2luID0gY2VsbChzaXplKG1vdmluZ0luZm8sIDEpLCAxKTsKICAgbW92aW5nSW5mby5wcm9jZXNzZWRUbyA9IGNlbGwoc2l6ZShtb3ZpbmdJbmZvLCAxKSwgMSk7CiAgIG1vdmluZ0luZm8ucHJvY2Vzc2VkRnJvbSA9IGNlbGwoc2l6ZShtb3ZpbmdJbmZvLCAxKSwgMSk7CgogICAlIEdlbmVyYXRlIGZpbGUgcGF0aHMgYmFzZWQgb24gY29uZGl0aW9uIAogICBtb3ZpbmdJbmZvLmRlc3RpbmF0aW9uID0gc3RyY2F0KHtwYXNzUGF0aH0sICJcIiwgbW92aW5nSW5mby5jb25kLCAiXCIsIG1vdmluZ0luZm8ubmFtZSk7CiAgIG1vdmluZ0luZm8ub3JpZ2luID0gc3RyY2F0KG1vdmluZ0luZm8uZm9sZGVyLCAiXCIsIG1vdmluZ0luZm8ubmFtZSk7CiAgIG1vdmluZ0luZm8ucHJvY2Vzc2VkVG8gPSBzdHJjYXQoe2FsbFBhdGh9LCAiXCIsIG1vdmluZ0luZm8ubmFtZSk7CiAgIG1vdmluZ0luZm8ucHJvY2Vzc2VkRnJvbSA9IHN0cmNhdChtb3ZpbmdJbmZvLmZvbGRlciwgIlwiLCBtb3ZpbmdJbmZvLm5hbWUpOwogICBgYGAKCjEuIFByZXBhcmUgZGF0YSB0YWJsZSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IGZpbGVzIHRoYXQgZG8gTk9UIG1lZXQgdGhlIHRocmVzaG9sZAogICAtIFRoZSBkYXRhIGdlbmVyYXRlZCBoZXJlIGFyZSBwcmVwYXJpbmcgdG8gY29weSAubWZmIGZpbGVzIGZyb20gdGhlIGxvY2F0aW9uIG9mIHRoZSByYXcgZmlsZXMgaW50byBhIGZvbGRlciBpbmRpY2F0aW5nIHRoZSBuZWVkIGZvciBtYW51YWwgcHJvY2Vzc2luZwoKICAgYGBgCiAgICUgQ3JlYXRlIGEgc2VwYXJhdGUgdGFibGUgZm9yIG9ubHkgZmlsZXMgdGhhdCBkaWQgbm90IG1lZXQgdGhyZXNob2xkCiAgIGZhaWxGaWxlcyA9IGZpbGVUZXN0KH5maWxlVGVzdC5UZXN0LCBbIkZpbGUiLCAiZm9sZGVyIiwgIm5hbWUiXSk7CgogICAlIENyZWF0ZSBlbXB0eSBjb2x1bW5zIGZvciBmaWxlcGF0aCB2YXJpYWJsZXMKICAgZmFpbEZpbGVzLmRlc3RpbmF0aW9uID0gY2VsbChzaXplKGZhaWxGaWxlcywgMSksIDEpOwogICBmYWlsRmlsZXMub3JpZ2luID0gY2VsbChzaXplKGZhaWxGaWxlcywgMSksIDEpOwogICBmYWlsRmlsZXMucHJvY2Vzc2VkVG8gPSBjZWxsKHNpemUoZmFpbEZpbGVzLCAxKSwgMSk7CiAgIGZhaWxGaWxlcy5wcm9jZXNzZWRGcm9tID0gY2VsbChzaXplKGZhaWxGaWxlcywgMSksIDEpOwoKICAgJSBHZW5lcmF0ZSBmaWxlcGF0aHMgYmFzZWQgb24gSUQgYW5kIHRhc2sKICAgZmFpbEZpbGVzLmRlc3RpbmF0aW9uID0gc3RyY2F0KHtmYWlsUGF0aH0sICJcIiwgZmFpbEZpbGVzLkZpbGUpOwogICBmYWlsRmlsZXMub3JpZ2luID0gc3RyY2F0KHtzcmNEaXJ9LCAiXCIsIGZhaWxGaWxlcy5GaWxlKTsKICAgZmFpbEZpbGVzLnByb2Nlc3NlZEZyb20gPSBzdHJjYXQoZmFpbEZpbGVzLmZvbGRlciwgIlwiLCBmYWlsRmlsZXMubmFtZSk7CiAgIGZhaWxGaWxlcy5wcm9jZXNzZWRUbyA9IHN0cmNhdCh7YWxsUGF0aH0sICJcIiwgZmFpbEZpbGVzLm5hbWUpOwoKICAgYGBgCgoxLiBHZW5lcmF0ZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBjb2x1bW4gaW5kZXggb2YgcmVsZXZhbnQgdmFyaWFibGVzIGZvciBmaWxlIHNvcnRpbmcKICAgLSBOb3RlIHRoYXQgdGhlIHZlcnkgbGFzdCBsaW5lIG9mIHRoaXMgY29kZSBkZWZpbmVzIHRoZSB2YXJhaWJsZShzKSB0byBleGNsdWRlIGZyb20gdGhlIEhBUFBFIG91dHB1dHRlZCBmaWxlcy4KICAgVGhpcyB2YXJpYWJsZSBtdXN0IGJlIHN0cmlwcGVkIGZyb20gdGhlIGRhdGEgYmVmb3JlIHNhdmluZyB0aGVtLCBiZWNhdXNlIHRoZSBwcmVzZW5jZSBvZiB0aGUgZXh0cmEgdmFyaWFibGUgbWFrZXMgdGhlIGZpbGUgaW5jb21wYXRpYmxlIHdpdGggRVAgVG9vbGtpdCdzIFBDQSBwcm9jZXNzLgoKICAgYGBgCiAgICUgRGVmaW5lIGNvbHVtbiBsb2NhdGlvbnMgZm9yIGVhY2ggZmlsZXBhdGggdmFyaWFibGUKCiAgICUgRm9yIGZpbGVzIHRoYXQgbWVldCB0aHJlc2hvbGQ6CiAgIHRvQ29sID0gZmluZChzdHJjbXAobW92aW5nSW5mby5Qcm9wZXJ0aWVzLlZhcmlhYmxlTmFtZXMsICJkZXN0aW5hdGlvbiIpKTsKICAgZnJvbUNvbCA9IGZpbmQoc3RyY21wKG1vdmluZ0luZm8uUHJvcGVydGllcy5WYXJpYWJsZU5hbWVzLCAib3JpZ2luIikpOwogICBwcm9jQ29sdG8gPSBmaW5kKHN0cmNtcChtb3ZpbmdJbmZvLlByb3BlcnRpZXMuVmFyaWFibGVOYW1lcywgInByb2Nlc3NlZFRvIikpOwogICBwcm9jQ29sZnJvbSA9IGZpbmQoc3RyY21wKG1vdmluZ0luZm8uUHJvcGVydGllcy5WYXJpYWJsZU5hbWVzLCAicHJvY2Vzc2VkRnJvbSIpKTsKICAgCiAgICUgRm9yIGZpbGVzIHRoYXQgZG8gbm90IG1lZXQgdGhyZXNob2xkCiAgIHJhd0NvbCA9IGZpbmQoc3RyY21wKGZhaWxGaWxlcy5Qcm9wZXJ0aWVzLlZhcmlhYmxlTmFtZXMsICJvcmlnaW4iKSk7CiAgIG1hbkNvbCA9IGZpbmQoc3RyY21wKGZhaWxGaWxlcy5Qcm9wZXJ0aWVzLlZhcmlhYmxlTmFtZXMsICJkZXN0aW5hdGlvbiIpKTsKICAgZmFpbFByb2NDb2x0byA9IGZpbmQoc3RyY21wKGZhaWxGaWxlcy5Qcm9wZXJ0aWVzLlZhcmlhYmxlTmFtZXMsICJwcm9jZXNzZWRUbyIpKTsKICAgZmFpbFByb2NDb2xGcm9tID0gZmluZChzdHJjbXAoZmFpbEZpbGVzLlByb3BlcnRpZXMuVmFyaWFibGVOYW1lcywgInByb2Nlc3NlZEZyb20iKSk7CiAgIAogICAlIERlZmluZSB2YXJpYWJsZSB0byBleGNsdWRlCiAgIGV4dHJhVmFyID0gJ1RpbWUnOwogICBgYGAKMS4gVXNlIGEgbG9vcCB0byBwcm9jZXNzIGFsbCBmaWxlcyB0aGF0IG1ldCB0aHJlc2hvbGQKICAgLSBGb3IgZWFjaCByb3cgaW4gdGhlICJtb3ZpbmdJbmZvIiBkYXRhc2V0LCB0aGUgbG9vcCB3aWxsOgogICAgICAtIElkZW50aWZ5IHRoZSBvcmlnaW4gYW5kIGRlc3RpbmF0aW9uIHBhdGhzCiAgICAgIC0gUmVhZCBpbiB0aGUgSEFQUEUgb3V0cHV0IGZpbGUKICAgICAgLSBSZW1vdmUgdGhlIGV4dHJhIHZhcmlhYmxlCiAgICAgIC0gU2F2ZSB0aGUgImNsZWFuZWQiIGRhdGEgaW4gdGhlIGFwcHJvcHJpYXRlIGZvbGRlciAod2l0aG91dCB2YXJpYWJsZSBuYW1lcywgYXMgcmVxdWlyZWQgYnkgRVAgVG9vbGtpdCkgCgogICBgYGAKICAgZm9yIHJvdyA9IDE6aGVpZ2h0KG1vdmluZ0luZm8pCiAgICAgICAlIFNwZWNpZnkgcGF0aCBpbmZvCiAgICAgICBwYXRoRnJvbSA9IG1vdmluZ0luZm97cm93LCBmcm9tQ29sfTsKICAgICAgIHBhdGhUbyA9IG1vdmluZ0luZm97cm93LCB0b0NvbH07CiAgICAgICAlIFJlYWQgaW4gdGhlIGRhdGEKICAgICAgIHJhd1RhYmxlID0gcmVhZHRhYmxlKHBhdGhGcm9tKTsKICAgICAgICUgUmVtb3ZlIGV4dHJhIGNvbHVtbiAoVGltZSkKICAgICAgIGNsZWFuVGFibGUgPSByYXdUYWJsZXs6LCB+c3RyY21wKHJhd1RhYmxlLlByb3BlcnRpZXMuVmFyaWFibGVOYW1lcywgZXh0cmFWYXIpfTsKICAgICAgICUgU2F2ZSB3aXRob3V0IGhlYWRlcnMKICAgICAgIHdyaXRlbWF0cml4KGNsZWFuVGFibGUsIHBhdGhUbywgJ0RlbGltaXRlcicsICdcdCcpCiAgIGVuZAoKICAgYGBgCjEuIFVzZSBhIGxvb3AgdG8gY29weSByYXcgKC5tZmYpIGZpbGVzIGludG8gYSBsb2NhdGlvbiB0aGF0IHN0b3JlcyBmaWxlcyByZXF1aXJpbmcgbWFudWFsIHByb2Nlc3NpbmcKCiAgIGBgYAogICBmb3Igcm93ID0gMTpoZWlnaHQoZmFpbEZpbGVzKQogICAgICAgJSBTcGVjaWZ5IHBhdGggaW5mbwogICAgICAgcGF0aEZyb20gPSBmYWlsRmlsZXN7cm93LCByYXdDb2x9OwogICAgICAgcGF0aFRvID0gZmFpbEZpbGVze3JvdywgbWFuQ29sfTsKICAgICAgICUgQ29weSBmaWxlIAogICAgICAgY29weWZpbGUocGF0aEZyb20sIHBhdGhUbykKICAgZW5kCiAgIGBgYAoKMS4gVXNlIGEgc2V0IG9mIGxvb3BzIHRvIGNvcHkgYWxsIEhBUFBFIG91dHB1dCBmaWxlcyBpbnRvIGEgZm9sZGVyIGludGVuZGVkIHRvIGhvdXNlIGFsbCBvdXRwdXQgKHdoZXRoZXIgdGhyZXNob2xkIGlzIG1ldCBvciBub3QpCgogICBgYGAKICAgZm9yIHJvdyA9IDE6aGVpZ2h0KG1vdmluZ0luZm8pCiAgICAgICAlIFNwZWNpZnkgcGF0aCBpbmZvCiAgICAgICBwYXRoRnJvbSA9IG1vdmluZ0luZm97cm93LCBwcm9jQ29sZnJvbX07CiAgICAgICBwYXRoVG8gPSBtb3ZpbmdJbmZve3JvdywgcHJvY0NvbHRvfTsKICAgICAgICUgQ29weSBmaWxlCiAgICAgICBjb3B5ZmlsZShwYXRoRnJvbSwgcGF0aFRvKTsKICAgZW5kCgogICBmb3Igcm93ID0gMTpoZWlnaHQoZmFpbEZpbGVzKQogICAgICAgJSBTcGVjaWZ5IHBhdGggaW5mbwogICAgICAgcGF0aEZyb20gPSBmYWlsRmlsZXN7cm93LCBmYWlsUHJvY0NvbEZyb219OwogICAgICAgcGF0aFRvID0gZmFpbEZpbGVze3JvdywgZmFpbFByb2NDb2x0b307CiAgICAgICAlIENvcHkgZmlsZQogICAgICAgY29weWZpbGUocGF0aEZyb20sIHBhdGhUbyk7CiAgIGVuZAogICBgYGAKMS4gR2VuZXJhdGUgYSAudHh0IGZpbGUgbGlzdGluZyBhbGwgcHJvY2Vzc2VkIC5tZmYgZmlsZXMKICAgLSBUaGlzIGZpbGUgd2lsbCBjb250YWluIGEgbGlzdCBvZiBhbGwgcmF3IGZpbGVzIChlLmcuLCBgMTExMV8yMl9maXNoc2hhcmsubWZmYCkgYW5kIHNhdmUgdGhlIGxpc3QgdG8gdGhlIHNwZWNpZmllZCBsb2NhdGlvbiAoInN1bW1QYXRoIikKICAgLSBUaGUgZmlsZSB3aWxsIGhhdmUgdGhlIGN1cnJlbnQgZGF0ZSBhbmQgdGltZSBhcHBlbmRlZCB0byB0aGUgZW5kIHNvIHRoYXQgaXQgd2lsbCBiZSBkaXN0aW5ndWlzaGFibGUgZnJvbSBwYXN0IGxvZ3MgCiAgIC0gVGhlIGxpc3Qgb2YgcHJvY2Vzc2VkIGZpbGVzIGlzIGdlbmVyYXRlZCB1c2luZyBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZSB0aGF0IHRoZSBIQVBQRSBwaXBlbGluZSBjcmVhdGVzIHRoYXQgbGlzdHMgYWxsIGZpbGVzIGlucHV0dGVkIHRvIHRoZSBwaXBlbGluZQoKICAgYGBgCiAgICUgQ3JlYXRlIGEgdGFibGUgZnJvbSBIQVBQRSBGaWxlTmFtZXMgY2VsbCBhcnJheQogICBwcm9jZXNzZWRMaXN0ID0gY2VsbDJ0YWJsZShGaWxlTmFtZXMoOikpOwoKICAgJSBSZW5hbWUgZmlsZSB2YXJpYWJsZSBmcm9tIGRlZmF1bHQKICAgcHJvY2Vzc2VkTGlzdCA9IHJlbmFtZXZhcnMocHJvY2Vzc2VkTGlzdCwgeydWYXIxJ30sIHsnRmlsZSd9KTsKCiAgICUgU2F2ZSBjdXJyZW50IGRhdGUgYXMgYSBzdHJpbmcgdmFyaWFibGUgCiAgIHRvZGF5ID0gc3RyaW5nKGRhdGUoKSk7CgogICAlIFNhdmUgdGltZSBhcyBhIHN0cmluZyB2YXJpYWJsZSwgcmVwbGFjaW5nICI6IiB3aXRoICJfIiBzbyB0aGF0IGZpbGUgY2FuIGJlIHdyaXR0ZW4gCiAgIHRpbWUgPSBzdHJyZXAoZGF0ZXN0cihub3csICdISDpNTTpTUzpGRkYnKSwgJzonLCAiXyIpOwoKICAgJSBHZW5lcmF0ZSBmaWxlIG5hbWUgdG8gaW5jbHVkZSBjdXJyZW50IGRhdGUgYW5kIHRpbWUgCiAgIGxpc3RGaWxlID0gc3RyY2F0KCJcb2RkYmFsbFByb2Nlc3NlZF8iLCB0b2RheSwgIl8iLCB0aW1lKTsKCiAgICUgR2VuZXJhdGUgZnVsbCBwYXRoIGluY2x1ZGluZyBmaWxlIG5hbWUKICAgc3VtbVBhdGhGdWxsID0gc3RyY2F0KHN1bW1QYXRoLCBsaXN0RmlsZSk7CgogICAlIFdyaXRlIHRhYmxlIHRvIHNwZWNpZmllZCBsb2NhdGlvbgogICB3cml0ZXRhYmxlKHByb2Nlc3NlZExpc3QsIHN1bW1QYXRoRnVsbCk7CiAgIGBgYAoKIyMgU3RvcC1TaWduYWwgUHJvY2Vzc2luZyBQaXBlbGluZSAKCiMgRVJQIFBDQSAoRVApIFRvb2xraXQgeyNlcHRQQ0F9CgojIyBSZWFkaW5nIFRleHQgRmlsZXMgaW50byBFUCBUb29sa2l0IHsjYXZlcmFnZX0KCjEuIE9wZW4gTUFUTEFCIHdpdGggIlJ1biBhcyBBZG1pbmlzdHJhdG9yIgoxLiBPcGVuIEVSUCBQQ0EgVG9vbGtpdCBpbiBNQVRMQUIKICAgIC0gVHlwZSBgZXBgIGluIGNvbW1hbmQgcHJvbXB0CjEuIENsaWNrIGBSZWFkYCB0byBpbXBvcnQgZmlsZXMKMS4gVXNlIHRoZSBmb2xsb3dpbmcgb3B0aW9ucwogICAgLSBGb3JtYXQgPSBgdGV4dCAoLnR4dClgCiAgICAtIFR5cGUgPSBgYXZlcmFnZWAKICAgIC0gTW9udCA9IGBBZHVsdCBIeWRyb2NlbCAxMjgtY2hhbm5lbCAxLjBgCjEuIFNlbGVjdCBgU2luZ2xlIEZpbGUgTW9kZWAuCiAgICAtIFNpbmdsZSBmaWxlIG1vZGUgd2lsbCB1c2UgdGhlIGZpbGVuYW1lIHRvIGFzc2lnbiB0aGUgdGFzayBjb25kaXRpb24gYW5kIHBhcnRpY2lwYW50IElEIGZvciBlYWNoIGZpbGUuCiAgICBUaHVzLCAqKml0IGlzIGNyaXRpY2FsIHRvIHVzZSBhIHN0YW5kYXJkIG5hbWluZyBjb252ZW50aW9uIHRvIG5hbWUgdGhlIGZpbGVzKiouCiAgICAgICAtIEZvciBleGFtcGxlLCBhbiBvZGRiYWxsIGZpbGUgY291bGQgYmUgbmFtZWQ6IGAxMDAxXzM2X29kZGJhbGxfcHJvY2Vzc2VkX0F2ZU92ZXJUcmlhbHNfdGd0Ky50eHRgCiAgICAgICAtIEEgRmlzaFNoYXJrcyBmaWxlIG1lYW53aGlsZSBjb3VsZCBiZSBuYW1lZDogYDEwMDRfMzZfb2RkYmFsbF9wcm9jZXNzZWRfQXZlT3ZlclRyaWFsc19jR28rKy50eHRgCiAgICAgICAtICpOb3RlOiBUaGUgZmlsZW5hbWUgZXhhbXBsZXMgYWJvdmUgcmVmbGVjdCB0aGUgYXV0b21hdGVkIG5hbWluZyBjb252ZW50aW9uIG9mIHRoZSBmaWxlcyBvdXRwdXR0ZWQgYnkgdGhlIEhBUFBFIHBpcGVsaW5lLioKICAgICAgICpJZiBhbm90aGVyIHByb2Nlc3NpbmcgcGlwZWxpbmUgaXMgdXNlZCBvciBpZiB0aGUgbmFtaW5nIGNvbnZlbnRpb25zIGJlY29tZSB1bnN0YW5kYXJkaXplZCwgaXQgaXMgKipjcnVjaWFsKiogdGhhdCBzdGFuZGFyZGl6YXRpb24gb2YgZmlsZW5hbWVzIGlzIGltcGxlbWVudGVkKgoxLiBJbiB0aGUgYFNpbmdsZSBGaWxlIE1vZGVgIG1lbnUgdXNlIHRoZSBgU3ViamVjdGAgZmllbGQgdG8gZGVub3RlIHdoaWNoIGNoYXJhY3RlcnMgaW4gdGhlIGZpbGVuYW1lIG5hbWUgd2lsbCBkZXRlcm1pbmUgdGhlIHBhcnRpY2lwYW50IElELgogICAgLSBGb3IgdGhlIGFib3ZlIGV4YW1wbGUgYDE6N2Agd291bGQgY29ycmVzcG9uZCB0byBgMTAwMV8zNmAgaW4gYSBmaWxlIGNhbGxlZCBgMTAwMV8zNl9vZGRiYWxsX3Byb2Nlc3NlZF9BdmVPdmVyVHJpYWxzX3RndCsudHh0YCAob3V0cHV0dGVkIGJ5IEhBUFBFKQoxLiBOZXh0LCBJbiB0aGUgYFNpbmdsZSBGaWxlIE1vZGVgIG1lbnUgdXNlIHRoZSBgQ2VsbGAgZmllbGQgdG8gZGVub3RlIHdoaWNoIGNoYXJhY3RlcnMgaW4gdGhlIGZpbGUgbmFtZSB3aWxsIGRldGVybWluZSB0aGUgdGFzayBjb25kaXRpb24uCiAgICAtIEZvciB0aGUgYmVsb3cgZXhhbXBsZSBgNDE6NDNgIHdvdWxkIGNvcnJlc3BvbmQgdG8gYGZycWAgb3IgYHRndGAgaW4gYSBmaWxlIGNhbGxlZCBgMTAwMV8zNl9vZGRiYWxsX3Byb2Nlc3NlZF9BdmVPdmVyVHJpYWxzX3RndCsudHh0YAogICAgLSBGb3IgRmlzaFNoYXJrcyBmaWxlcywgaXQgbWlnaHQgYmUgYDQ3OjQ5YCB0aGF0IGNvcnJlc3BvbmQgdG8gYGNnb2Agb3IgYGNuZ2AuCiAgICAtICFbaW1hZ2VdKGltYWdlcy9yZWFkVGV4dEZpbGUyMDI0LnBuZykKMS4gU2VsZWN0IGBSZWFkYC4KWW91IHdpbGwgYmUgYXNrZWQgdG8gbmFtZSB0aGUgYWdncmVnYXRlIGZpbGUgY3JlYXRlZCBieSBpbXBvcnRpbmcgYW5kIGNvbWJpbmluZyB0aGUgc2luZ2xlIGZpbGVzLgpVc2UgdGhlIGNvbnZlbnRpb24gInRhc2tfY29uZGl0aW9uX2FnZSIgdG8gbmFtZSB0aGUgZmlsZSAoZS5nLiwgYG9iX3RndF81NGApCjEuIEEgbmV3IHdpbmRvdyB3aWxsIG9wZW4gcHJvbXB0aW5nIHlvdSB0byBzZWxlY3QgdGhlIGZpbGVzIHlvdSB3aXNoIHRvIGltcG9ydC4KTmF2aWdhdGUgdG8gdGhlIGZvbGRlciBob3VzaW5nIHRoZSBkYXRhIHRvIGJlIGltcG9ydGVkIChlLmcuLCBgMyAtIEZpbGVzIGZvciBQQ0FcVGFyZ2V0YCkgYW5kIHVzZSBgQ3RybCArIEFgIHRvIHNlbGVjdCBhbGwgZmlsZXMgaW4gdGhhdCBmb2xkZXIuCkNsaWNrIGBPcGVuYCBvbmNlIGFsbCBkZXNpcmVkIGZpbGVzIGFyZSBzZWxlY3RlZAoxLiBTZWxlY3QgdGhlIGAyXzlBdmVyYWdlTmV0MTI4LmNlZGAgZmlsZSB3aGVuIHByb21wdGVkIGJ5IGFub3RoZXIgcG9wdXAuClRoaXMgZmlsZSBjb3JyZXNwb25kcyB0byB0aGUgZWxlY3Ryb2RlIHRlbXBsYXRlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGFydGljaXBhbnQgYWdlIHJhbmdlIGFuZCB0eXBlIG9mIG5ldCByZXByZXNlbnRlZCBpbiB0aGUgZGF0YQogICAtIEZvciBvdXIgc3R1ZHkgdXNpbmcgYSAxMjgtY2hhbm5lbCBuZXQgb24gY2hpbGRyZW4gYWdlZCAzLTcsIHRoZSBgMl85QXZlcmFnZU5ldDEyOC5jZWRgIHRlbXBsYXRlIGlzIG1vc3QgYXBwcm9wcmlhdGUgCiAgICFbaW1hZ2VdKGltYWdlcy9uZXRUZW1wbGF0ZUZpbGUucG5nKQoxLiBUaGUgbmV3IGZpbGUgd2lsbCBoYXZlIHRoZSBwYXJ0aWNpcGFudCBJRCBhbmQgd2lsbCBjb21iaW5lIHRoZSBjb25kaXRpb25zIGZvciBlYWNoIHBhcnRpY2lwYW50LgogICAgLSBTdWJqZWN0IE5hbWVzOiAKICAgICAgICAtICFbaW1hZ2VdKGltYWdlcy9zdWJqZWN0Q29tYmluZWROYW1lcy5wbmcpCiAgICAtIFRhc2sgQ29uZGl0aW9ucwogICAgICAgIC0gIVtpbWFnZV0oaW1hZ2VzL2NvbmRpdGlvbkNvbWJpbmVkTmFtZXMucG5nKQoKIyMgVXBkYXRlIEZpbGUgd2l0aCBFeHBlcmltZW50IEluZm9ybWF0aW9uCgoxLiBHbyB0byBgTWFpbmAgYW5kIGNsaWNrIGBFZGl0YAoxLiBDbGljayBvbiB0aGUgZmlsZSB5b3UgaW1wb3J0ZWQKMS4gSW4gYE92ZXJ2aWV3YCwgYWRkIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb246CiAgICAtIEV4cGVyaW1lbnQgTmFtZTogYE9kZGJhbGxgLCBgRmlzaFNoYXJrYCwgb3IgYFN0b3BTaWduYWxgCiAgICAtIFJlZmVyZW5jZSBUeXBlOiBjaGFuZ2UgdG8gYGF2ZXJhZ2UgcmVmZXJlbmNlYAogICAgLSBQcmVzdGltdWx1cyBwZXJpb2Q6IGNoYW5nZSB0byBgMjAwYAogICAgLSBOb21pbmFsIHNhbXBsaW5nIHJhdGU6IGNoYW5nZSB0byBgMTAwMGAKMS4gQ2xpY2sgYERvbmVgCjEuIEdvIHRvIGBNYWluYCBhbmQgY2xpY2sgYFNhdmVgCiAgICAtIFNhdmUgdGhlIGNvbWJpbmVkIGZpbGUgYXMgYW4gYC5lcHRgIGZpbGUgaW4gdGhlIGA0LUVQVCBBdmVyYWdlc2AgZm9sZGVyIHVzaW5nIHRoZSBmb2xsb3dpbmcgbmFtaW5nIGNvbnZlbnRpb246ICJ0YXNrX2NvbmRpdGlvbl9hZ2UiLgogICAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3ZXJlIHdvcmtpbmcgb24gdGhlIHRhcmdldCBjb25kaXRpb24gb2Ygb2RkYmFsbCBmb3IgYWxsIGFnZSBncm91cHMsIHlvdSB3b3VsZCBzYXZlIHRoZSBmaWxlIGFzIGBvYl90Z3RfYWxsYAoKIyMgR2VuZXJhdGluZyBHcmFuZCBBdmVyYWdlIFdhdmVmb3JtcwoKMS4gSWYgdGhlIEVQVCBhdmVyYWdlIGZpbGUgKGUuZy4sIGBvYl90Z3RfYWxsYCkgaXMgbm90IGFscmVhZHkgaW4gdGhlIHdvcmtpbmcgZW52aXJvbm1lbnQsIHJlYWQgaXQgaW4gdXNpbmcgdGhlIHN0ZXBzIGJlbG93CiAgIC0gR28gdG8gYFJlYWRgCiAgIC0gRm9ybWF0ID0gYEVQICguZXB0KWAKICAgLSBDbGljayBgUmVhZGAKICAgLSBOYXZpZ2F0ZSB0byB0aGUgYDQgLSBFUFQgQXZlcmFnZXNgIGZvbGRlciBhbmQgc2VsZWN0IGRlc2lyZWQgZmlsZShzKQogICAtIENsaWNrIGBPcGVuYCBpbiB0aGUgYnJvd3NlciB3aW5kb3cgdG8gcmVhZCB0aGUgZmlsZShzKQogICAtIENsaWNrIGBNYWluYCB0byByZXR1cm4gdG8gbWFpbiBtZW51CjEuIFNlbGVjdCBgRWRpdGAKMS4gV2hlbiB0aGUgZWRpdG9yIHdpbmRvdyBvcGVucywgbmF2aWdhdGUgdG8gdGhlIGBTdWJqZWN0c2AgcGFuZQoxLiBTZWxlY3QgYEFsbGAgZnJvbSBhbW9uZyB0aGUgbWFueSBvcHRpb25zIGFsb25nIHRoZSBsZWZ0aGFuZCBwYW5lIG9mIHRoZSBlZGl0b3IKICAgLSBUaGlzIHdpbGwgc2VsZWN0IGFsbCBvZiB0aGUgc3ViamVjdHMgaW5jbHVkZWQgaW4gdGhlIGZpbGUgYW5kIGFzc2lnbiB0aGVtIGEgd2VpZ2h0IG9mIDEKMS4gQ29uZmlybSB0aGF0IGFsbCBzdWJqZWN0cyBoYXZlIGJlZW4gc2VsZWN0ZWQgKGxvb2sgZm9yIGEgY2hlY2tlZCBib3ggaW4gdGhlIHN1YmplY3Qgcm93KSBhbmQgdGhhdCBhbGwgd2VpZ2h0cyBoYXZlIGJlZW4gc2V0IHRvIDEKMS4gQ2xpY2sgYEFkZGAKMS4gQSBuZXcgInN1YmplY3QiIHNob3VsZCBoYXZlIG5vdyBiZWVuIGFkZGVkIHRvIHRoZSBib3R0b20gb2YgdGhlIHN1YmplY3RzIGxpc3QKICAgLSBUaGlzIHN1YmplY3QgaXMgY2FsbGVkIGBnYXZlYCBhbmQgcmVwcmVzZW50cyB0aGUgZ3JhbmQgYXZlcmFnZSBhY3Jvc3MgYWxsIHN1YmplY3RzCjEuIENsaWNrIGBEb25lYCB0byBleGl0IHRoZSBlZGl0b3Igd2luZG93LCB0aGVuIGBNYWluYCB0byByZXR1cm4gdG8gdGhlIEVQIFRvb2xraXQgaG9tZQoKIyMgVGVtcG9yYWwgUENBIHsjdFBDQX0KCjEuIEdvIHRvIGBNYWluYCBhbmQgY2xpY2sgYFBDQWAKMS4gSW5wdXQgdGhlIGZvbGxvd2luZzoKICAgIC0gTW9kZTogYHRlbXBvcmFsYAogICAgLSBSb3RhdGlvbjogYHByb21heGAKICAgIC0gRmFjdG9yczogYDBgCiAgICAtIFRpdGxlOiB0UENBX2V4cGVyaW1lbnRuYW1lIChleGFtcGxlOiBgdFBDQV9vYl90Z3RfYWxsYCkKMS4gQ2xpY2sgdGhlIGFwcHJvcHJpYXRlIGZpbGUgKGUuZy4sIGBvYl90Z3RfYWxsYCkKMS4gRGV0ZXJtaW5lIGhvdyBtYW55IGZhY3RvcnMgdG8gcmV0YWluIHVzaW5nIHRoZSBzY3JlZSBwbG90IChrZWVwIHRoZSBudW1iZXIgb2YgZmFjdG9ycyB3aGVyZSB0aGUgYmx1ZSBsaW5lIGlzIGFib3ZlIHRoZSByZWQgbGluZSkKMS4gRGV0ZXJtaW5lIHRoZSBwZXJjZW50IHZhcmlhbmNlIGFjY291bnRlZCBmb3IgYnkgdGhlIG51bWJlciBvZiBmYWN0b3JzIHJldGFpbmVkIGJ5IGNoYW5naW5nIHRoZSAibWluaW11bSAlIGFnZSBhY2NvdW50ZWQgZm9yIGNyaXRlcmlvbiIuClJlY29yZCB0aGUgbnVtYmVyIG9mIGZhY3RvcnMgcmV0YWluZWQgYW5kICUgdmFyaWFuY2UgYWNjb3VudGVkIGZvciBieSB0aGF0IG51bWJlciBvZiBmYWN0b3JzLgoxLiBSZS1ydW4gdGhlIHRlbXBvcmFsIFBDQSB1c2luZyB0aGUgYWJvdmUgaW5wdXRzLCAqKmJ1dCBjaGFuZ2UgdGhlIG51bWJlciBvZiBmYWN0b3JzIHRvIHRoZSBudW1iZXIgb2YgZmFjdG9ycyByZXRhaW5lZCBmcm9tIHRoZSBhYm92ZSBzdGVwKioKMS4gUmV0dXJuIHRvIGBNYWluYCBhbmQgY2xpY2sgYFNhdmVgLiBTYXZlIHRoZSB0UENBIGZpbGUgaW4gdGhlIGA1LVBDQWAgZm9sZGVyCgojIyBTcGF0aWFsIFBDQQoKMS4gR28gdG8gYE1haW5gIGFuZCBjbGljayBgUENBYAoxLiBDaGFuZ2UgdGhlIFBDQSB0eXBlLCB1c2luZyB0aGUgZm9sbG93aW5nIGlucHV0czoKICAgIC0gTW9kZTogYHNwYXRpYWxgCiAgICAtIFJvdGF0aW9uOiBgaW5mb21heGAKICAgIC0gRmFjdG9yczogYDBgCiAgICAtIFRpdGxlOiBzUENBX2V4cGVyaW1lbnRuYW1lIChlLmcuLCBgc1BDQV9vYl90Z3RfYWxsYCkKMS4gQ2xpY2sgdGhlIGFwcHJvcHJpYXRlIGZpbGUgKGUuZy4sIGBvYl90Z3RfYWxsYCkKMS4gRGV0ZXJtaW5lIGhvdyBtYW55IGZhY3RvcnMgdG8gcmV0YWluIHVzaW5nIHRoZSBzY3JlZSBwbG90IChrZWVwIHRoZSBudW1iZXIgb2YgZmFjdG9ycyB3aGVyZSB0aGUgYmx1ZSBsaW5lIGlzIGFib3ZlIHRoZSByZWQgbGluZSkKMS4gRGV0ZXJtaW5lIHRoZSBwZXJjZW50IHZhcmlhbmNlIGFjY291bnRlZCBmb3IgYnkgdGhlIG51bWJlciBvZiBmYWN0b3JzIHJldGFpbmVkIGJ5IGNoYW5naW5nIHRoZSAibWluaW11bSAlIGFnZSBhY2NvdW50ZWQgZm9yIGNyaXRlcmlvbiIuClJlY29yZCB0aGUgbnVtYmVyIG9mIGZhY3RvcnMgcmV0YWluZWQgYW5kICUgdmFyaWFuY2UgYWNjb3VudGVkIGZvciBieSB0aGF0IG51bWJlciBvZiBmYWN0b3JzLgoxLiBSZS1ydW4gdGhlIHNwYXRpYWwgUENBIHVzaW5nIHRoZSBhYm92ZSBpbnB1dHMsICoqYnV0IGNoYW5nZSB0aGUgbnVtYmVyIG9mIGZhY3RvcnMgdG8gdGhlIG51bWJlciBvZiBmYWN0b3JzIHJldGFpbmVkIGZyb20gdGhlIGFib3ZlIHN0ZXAqKgoxLiBSZXR1cm4gdG8gYE1haW5gIGFuZCBjbGljayBgU2F2ZWAuClNhdmUgdGhlIHNQQ0EgZmlsZSBpbiB0aGUgYDUtUENBYCBmb2xkZXIKCiMjIFRlbXBvcm9zcGF0aWFsIFBDQQoKMS4gR28gdG8gYE1haW5gIGFuZCBjbGljayBgUENBYAoxLiBDaGFuZ2UgdGhlIFBDQSB0eXBlLCB1c2luZyB0aGUgZm9sbG93aW5nIGlucHV0czoKICAgIC0gTW9kZTogYHNwYXRpYWxgCiAgICAtIFJvdGF0aW9uOiBgaW5mb21heGAKICAgIC0gRmFjdG9yczogYDBgCiAgICAtIFRpdGxlOiB0c1BDQV9leHBlcmltZW50bmFtZSAoZS5nLiwgYHRzUENBX29iX3RndF9hbGxgKQoxLiBDbGljayB0aGUgYHRQQ0FgIGZpbGUgKGNyZWF0ZWQgaW4gdGhlIHByZXZpb3VzIHN0ZXApCjEuIERldGVybWluZSBob3cgbWFueSBmYWN0b3JzIHRvIHJldGFpbiB1c2luZyB0aGUgc2NyZWUgcGxvdCAoa2VlcCB0aGUgbnVtYmVyIG9mIGZhY3RvcnMgd2hlcmUgdGhlIGJsdWUgbGluZSBpcyBhYm92ZSB0aGUgcmVkIGxpbmUpCjEuIERldGVybWluZSB0aGUgcGVyY2VudCB2YXJpYW5jZSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBudW1iZXIgb2YgZmFjdG9ycyByZXRhaW5lZCBieSBjaGFuZ2luZyB0aGUgIm1pbmltdW0gJSBhZ2UgYWNjb3VudGVkIGZvciBjcml0ZXJpb24iLgpSZWNvcmQgdGhlIG51bWJlciBvZiBmYWN0b3JzIHJldGFpbmVkIGFuZCAlIHZhcmlhbmNlIGFjY291bnRlZCBmb3IgYnkgdGhhdCBudW1iZXIgb2YgZmFjdG9ycy4KMS4gUmUtcnVuIHRoZSBzcGF0aWFsIFBDQSB1c2luZyB0aGUgYWJvdmUgaW5wdXRzLCAqKmJ1dCBjaGFuZ2UgdGhlIG51bWJlciBvZiBmYWN0b3JzIHRvIHRoZSBudW1iZXIgb2YgZmFjdG9ycyByZXRhaW5lZCBmcm9tIHRoZSBhYm92ZSBzdGVwKioKMS4gUmV0dXJuIHRvIGBNYWluYCBhbmQgY2xpY2sgYFNhdmVgLgpTYXZlIHRoZSB0c1BDQSBmaWxlIGluIHRoZSBgNS1QQ0FgIGZvbGRlci4KCiMjIFBDQSBDb21wb25lbnQgU2VsZWN0aW9uIGFuZCBFeHRyYWN0aW9uIHsjZXh0cmFjdH0KCkhlcmUsIHRoZSBnb2FsIGlzIHRvIHNlbGVjdCB0aGUgUENBIGNvbXBvbmVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBFUlAgY29tcG9uZW50IG9mIGludGVyZXN0LCBhbmQgdGhlIGV4dHJhY3Rpb24gdGhhdCBzdXBwb3J0cyB0aGUgaW50ZW5kZWQgaW50ZXJwcmV0YWJpbGl0eSBvZiB0aGUgY29tcG9uZW50LgoKMS4gR28gdG8gYFZpZXdgIHRvIGJlZ2luIHRoZSBwcm9jZXNzIG9mIHNlbGVjdGluZyB0aGUgUENBIGNvbXBvbmVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBFUlAgb2YgaW50ZXJlc3QuCiAgICAtIEl0ZXJhdGl2ZWx5IHNlbGVjdCBhbmQgdmlldyBlYWNoIHRlbXBvcm9zcGF0aWFsIFBDQSBjb21wb25lbnQgdG8gaWRlbnRpZnkgdGhlIFBDQSBjb21wb25lbnQgKCJmYWN0b3IiKSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBFUlAgb2YgaW50ZXJlc3QgKGUuZy4sIE4yIG9yIFAzKS4KICAgIFNlbGVjdCB0aGUgdGVtcG9yb3NwYXRpYWwgUENBIGNvbXBvbmVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBFUlAgb2YgaW50ZXJlc3QgYmFzZWQgb24gdGhlIHRpbWluZywgc3BhdGlhbCBsb2NhdGlvbiwgbW9ycGhvbG9neSwgYW5kIChhcyByZWxldmFudCkgYW55IGNvbmRpdGlvbi0gb3IgYWdlLXJlbGF0ZWQgZGlmZmVyZW5jZXMgb2YgdGhlIGNvbXBvbmVudCBiYXNlZCBvbiBwcmlvciB3b3JrLgoxLiBHZW5lcmF0ZSB0c1BDQSBjb21wb25lbnRzLgpHbyB0byBgV2luZG93YCBhbmQgaW5wdXQgdGhlIGZvbGxvd2luZzoKICAgIC0gc2VsZWN0IHRoZSB0c1BDQSBmaWxlCiAgICAtIHNlbGVjdCBhbW9uZyBgbWVhbmAsIGBtYXhQZWFrYCwgb3Igb3RoZXIgb3B0aW9ucy4KICAgICAgKEFjY29yZGluZyB0byBKb2UgRGllbiksIHdoZW4gdXNpbmcgYW1wbGl0dWRlcyBmcm9tIFBDQSBjb21wb25lbnRzLCBpdCBkb2VzIG5vdCBtYXR0ZXIgd2hpY2ggb3B0aW9uIHlvdSBzZWxlY3TigJRhbGwgdGhlIGRpZmZlcmVudCBtZXRob2RzIHJlc3VsdCBpbiBjb21wYXJhYmxlICpwKi12YWx1ZXMgd2hlbiBkZWFsaW5nIHdpdGggUENBIGNvbXBvbmVudHMuCiAgICAgIFNvLCBzZWxlY3QgYSBtZXRob2QgdGhhdCBtYWtlcyBzZW5zZSBmb3IgdGhlIHN0b3J5IHlvdSB3YW50IHRvIHRlbGwuCiAgICAgIFRoZSBtZXRob2RzIHdpbGwgeWllbGQgZGlmZmVyZW50IHJlc3VsdHMgd2hlbiBkZWFsaW5nIHdpdGggdGhlIHJhdyB3YXZlZm9ybXMuCiAgICAtIHNlbGVjdCBgQXV0b1BDQWAgb3IgYFdpbmRvd2AgdG8gc2VsZWN0IGNoYW5uZWxzLgogICAgICBJZiB0aGUgcGVhayBhbXBsaXR1ZGUgaXMgd2hlcmUgeW91IGV4cGVjdCB0ZW1wb3JhbGx5IGFuZCBzcGF0aWFsbHksIHRoZW4gdXNlIHRoZSBhdXRvUENBIGZ1bmN0aW9uLCBhbmQgaWYgaXQgaXMgbm90LCB0aGVuIHdpbmRvdyB0byB3aGVyZSB5b3UgZXhwZWN0IGl0IHRvIGJlLgogICAgICBUaGlzIHdpbGwgYWxsb3cgeW91IHRvIHJlcG9ydCByZXN1bHRzIHRoYXQgYXJlIG1vcmUgaW50ZXJwcmV0YWJsZS4KICAgICAgQXMgSm9lIERpZW4gZGVzY3JpYmVkLCB0aGUgd2F5IHRoYXQgUENBIGRhdGEgYXJlIHN0b3JlZCBpbnRlcm5hbGx5IGluIHRoZSB0b29sa2l0IGFyZSBhcyBmYWN0b3Igc2NvcmVzIChpLmUuLCBjb21wb25lbnQgc2NvcmVzKS4KICAgICAgV2hlbiB5b3UgZXh0cmFjdCBhbXBsaXR1ZGVzIGZyb20gYSBQQ0EgY29tcG9uZW50LCB5b3UgYXJlIGV4dHJhY3RpbmcgdGhlIGZhY3RvciBzY29yZXMgbXVsdGlwbGllZCBieSBhIGNvbnN0YW50IChzb21lIHNjYWxpbmcgZmFjdG9yLCByZXByZXNlbnRpbmcgdGhlIGVsZWN0cm9kZSB3aGVyZSB5b3UgZXh0cmFjdCBpdCBmcm9tKS4KICAgICAgVGh1cywgYWNjb3JkaW5nIHRvIEpvZSBEaWVuLCB0aGUgKnAqLXZhbHVlcyBzaG91bGQgYmUgdGhlIHNhbWUgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHlvdSB1c2UgQXV0b1BDQSwgb3IgZXh0cmFjdCBmcm9tIGEgc2luZ2xlIGVsZWN0cm9kZSBvciBtdWx0aXBsZSBlbGVjdHJvZGVzIChpdCB3b3VsZCBiZSBnb29kIHRvIHZlcmlmeSB0aGlzKS4KICAgICAgV2hhdCBpcyBjaGFuZ2luZyBpcyBtZXJlbHkgdGhlIHNjYWxpbmcgZmFjdG9yIChpLmUuLCB0aGUgY29uc3RhbnQgdGhhdCBpcyBtdWx0aXBsaWVkIGJ5IGFsbCBmYWN0b3Igc2NvcmVzKS4KICAgICAgV2hlbiB5b3Ugc2VsZWN0IG11bHRpcGxlIGVsZWN0cm9kZXMsIGl0IGlzIGNvbXB1dGluZyB0aGUgUENBLWVzdGltYXRlZCBhbXBsaXR1ZGUgYXQgZWFjaCBlbGVjdHJvZGUgYW5kIHBlcmZvcm1pbmcgYSBzaW1wbGUgYXZlcmFnZSBhY3Jvc3MgdGhvc2UgZWxlY3Ryb2Rlcy4KICAgICAgVGhlIEF1dG9QQ0EgZXh0cmFjdHMgdGhlIFBDQS1lc3RpbWF0ZWQgYW1wbGl0dWRlIGF0IHRoZSBwZWFrIGNoYW5uZWwgYW5kIHRoZSBwZWFrIHRpbWVwb2ludC4KICAgICAgSWYgdGhlIHdhdmVmb3JtIGlzIG5lZ2F0aXZlLWdvaW5nIGF0IHRoZSBwZWFrIGNoYW5uZWwsIGFuZCB5b3UgYXJlIGludGVyZXN0ZWQgaW4gdGhlIHBvc2l0aXZlLWdvaW5nIGRpcG9sZSwgeW91IHdvdWxkIHNlbGVjdCB0aGUgcGVhayBwb3NpdGl2ZSBjaGFubmVsIHRvIGlkZW50aWZ5IHRoZSBQQ0EtZXN0aW1hdGVkIGFtcGxpdHVkZSBvZiB0aGUgcG9zaXRpdmUtZ29pbmcgd2F2ZWZvcm0gb24gdGhhdCBQQ0EgY29tcG9uZW50LgogICAgICBOZXZlcnRoZWxlc3MsIGV2ZW4gdGhvdWdoIHlvdSBhcmUgc2VsZWN0aW5nIHRoZSBQQ0EtZXN0aW1hdGVkIGFtcGxpdHVkZSBmb3IgYSBnaXZlbiBjaGFubmVsIGF0IGEgZ2l2ZW4gZWxlY3Ryb2RlLCB0aGVyZSBhcmUgbm93ICJ2aXJ0dWFsIGNoYW5uZWxzIjsgdGhlIGVzdGltYXRlcyBpbmNsdWRlIHRoZSBjb250cmlidXRpb25zIG9mIGFsbCBjaGFubmVscyBhbmQgYWxsIHRpbWVwb2ludHMgPHU+dG8gdGhlIGV4dGVudCB0aGF0PC91PiB0aGV5IGxvYWQgb250byB0aGUgUENBIGNvbXBvbmVudCBvZiBpbnRlcmVzdC4KICAgICAgVGh1cywgZXZlbiBpZiB5b3Ugc2VsZWN0IHRvIHdpbmRvdyBhIFBDQSBjb21wb25lbnQgZnJvbSBvbmx5IDEgY2hhbm5lbCBhdCAxIHRpbWVwb2ludCwgaXQgaXMgdXNpbmcgQUxMIGNoYW5uZWxzIGFuZCB0aW1lcG9pbnRzIGluIHRoZSBlc3RpbWF0aW9u4oCUdGhpcyBpcyBub3QgdGhlIGNhc2UgaWYgd2luZG93aW5nIHRoZSByYXcgRVJQIHdhdmVmb3Jtcy4KICAgIC0gU2F2ZSB0aGUgZmlsZXMgZ2VuZXJhdGVkIGZyb20gdGhlIEF1dG9QQ0EgaW4gdGhlIGA2IC0gUENBIENvbXBvbmVudHNgIGZvbGRlciB1c2luZyB0aGUgZm9sbG93aW5nIG5hbWluZyBjb252ZW50aW9uOiAiZXJwX3Rhc2tfY29uZGl0aW9uX2FnZV9jb21wb25lbnQiIChlLmcuLGBlcnBfb2JfdGd0X2FsbF9QM2ApLgoxLiBUbyB2aWV3IGFsbCBvZiB0aGUgdHNQQ0EgY29tcG9uZW50cywgY2xpY2sgYFZpZXdgIGFuZCBpbnB1dCB0aGUgZm9sbG93aW5nCiAgICAtIHNlbGVjdCB0aGUgYXBwcm9wcmlhdGUgZmlsZSAoZS5nLiwgYG9iX3RndF9hbGxgKQogICAgLSBzZWxlY3QgYGdhdmVgCiAgICAtIHNlbGVjdCBgbm9uZWAKICAgIC0gY2xpY2sgYFdhdmVzYAoxLiBJdCBpcyBnb29kIHByYWN0aWNlIHRvIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IGNvbXBvbmVudHMgYXJlIGNvbXBhcmFibGUgYWNyb3NzIGRpZmZlcmVudCBhZ2UgcmFuZ2VzCiAgICAtIFlvdSBjYW4gY2hlY2sgdGhpcyBpbiBvbmUgb2YgdHdvIHdheXM6CiAgICAgIC0gVmlzdWFsbHkgZXhhbWluZSBncmFuZCBhdmVyYWdlcyBiZXR3ZWVuIGFnZSByYW5nZXMKICAgICAgLSBBcHBseSB0aGUgUENBIGZyb20gb25lIGFnZSBncm91cCBhbmQgYXBwbHkgaXQgdG8gYW5vdGhlciBhZ2UgZ3JvdXAgYW5kIGV4YW1pbmUgd2hldGhlciB0aGUgcmVzdWx0cyBob2xkIHVwIHVzaW5nIGNyb3NzLXZhbGlkYXRpb24gaW4gRVBUb29sa2l0CjEuIEl0IGlzIGdlbmVyYWxseSB1c2VmdWwgdG8ga2VlcCB0cmFjayBvZiB0aGUgZXh0cmFjdGlvbiBwcm9jZXNzIGZvciBlYWNoIFBDQSBjb21wb25lbnQuCk91ciBjdXJyZW50IHByb2NlZHVyZSBmb3IgZG9pbmcgc28gaXMga2VlcGluZyBhIGBQQ0FfQ29tcG9uZW50SW5mby50eHRgIGZpbGUgaW4gdGhlIGA2LVBDQSBDb21wb25lbnRzYCBmb2xkZXIuCiAgICogUmVsZXZhbnQgaW5mb3JtYXRpb24gbWF5IGluY2x1ZGUgdGhlIHRpbWluZyB1c2VkIHRvIHdpbmRvdyBhIGNvbXBvbmVudCBhbmQgdGhlIGVsZWN0cm9kZXMgdGhhdCBsb2FkIG9udG8gdGhlIGNvbXBvbmVudCBvZiBpbnRlcmVzdCBhdCBhIGdpdmVuIHRocmVzaG9sZAoKIyMgSWRlbnRpZnlpbmcgRWxlY3Ryb2RlcyB0aGF0IExvYWQgT250byBQQ0EgQ29tcG9uZW50CgoxLiBHbyB0byBgV2luZG93YAoxLiBTZWxlY3QgdGhlIFBDQSBmaWxlIG9mIGludGVyZXN0IChlLmcuLCBgdHNQQ0Ffb2JfdGd0X2FsbGApCjEuIENsaWNrIHRoZSBgQ2hhbm5lbHNgIGJ1dHRvbiAoYWJvdXQgaGFsZndheSBkb3duIHRoZSBgV2luZG93YCB3aW5kb3cpCjEuIENsaWNrIGBGYWN0b3JgIAogICAtIEZyb20gdGhlIGRyb3Bkb3duLCBzZWxlY3QgdGhlIFBDQSBmaWxlIG9mIGludGVyZXN0IChlLmcuLCBgdHNQQ0Ffb2JfdGd0X2FsbGApCiAgIC0gRW50ZXIgdGhlIHRocmVzaG9sZCBpbiB0aGUgc3BhY2UgYmVsb3cgKGUuZy4sIDAuNSkKICAgICAgLSBUaGlzIHNldHMgdGhlIG1pbnVtdW0gZmFjdG9yIGxvYWRpbmcgdmFsdWUgZm9yIGFuIGVsZWN0cm9kZSB0byBiZSAiaW5jbHVkZWQiIGluIHRoZSBjb21wb25lbnQtcmVsYXRlZCBjbHVzdGVyCiAgICAtIERlcGVuZGluZyBvbiB3aGVudGhlciB5b3UgYXJlIGludGVyZXN0ZWQgaW4gcG9zaXRpdmUgb3IgbmVnYXRpdmUgZmFjdG9yIGxvYWRpbmdzLCBzZWxlY3QgdGhlIGFwcHJvcHJpYXRlIHNpZ24gKGArYCwgYC1gLCBvciBgKy8tYCkKICAgIC0gQSBwb3B1cCB3aW5kb3cgd2l0aCBQQ0EgZmFjdG9ycyB3aWxsIGFwcGVhci4KICAgIFNlbGVjdCB0aGUgY29tcG9uZW50KHMpIHlvdSB3aXNoIHRvIGlkZW50aWZ5IHNwYXRpYWxseSAoZS5nLiwgYFRGMDFTRjAxYCkKMS4gV2hlbiBwcm9tcHRlZCwgZ2l2ZSB0aGUgZWxlY3Ryb2RlIGNsdXN0ZXIgYSBuYW1lCjEuIFRoZSBjaGFubmVscyB0aGF0IGNoYW5nZSBjb2xvciBhcmUgdGhvc2Ugd2hpY2ggbG9hZCBvbnRvIHRoZSBzZWxlY3RlZCBjb21wb25lbnQgYXQgb3IgYWJvdmUgdGhlIHRocmVzaG9sZCB2YWx1ZQoKIyMgRXhwb3J0aW5nIEdyYW5kIEF2ZXJhZ2UgRGF0YQoKSWYgeW91IGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gdGhlIGdyYW5kIGF2ZXJhZ2UgZGF0YSBhbmQgbm90IGluZGl2aWR1YWwgc3ViamVjdHMsIHRoZXNlIGluc3RydWN0aW9ucyB3aWxsIGFsbG93IHlvdSB0byBleHBvcnQgYSAudHh0IGZpbGUgY29udGFpbmluZyBvbmx5IHRoZSBncmFuZCBhdmVyYWdlIGRhdGEuCgoxLiBGcm9tIEVQIFRvb2xraXQgaG9tZSAoYE1haW5gIHNjcmVlbiksIHNlbGVjdCBgRWRpdGAKMS4gU2VsZWN0IHRoZSAuZXB0IGF2ZXJhZ2VzIGZpbGUgKGUuZy4sIGBvYl90Z3RfYWxsYCkgdGhhdCBjb250YWlucyBhICJzdWJqZWN0IiByZXByZXNlbnRpbmcgdGhlIGdyYW5kIGF2ZXJhZ2UKICAgLSBJZiB0aGUgZmlsZSBkb2VzIE5PVCBjb250YWluIGEgZ3JhbmQgYXZlcmFnZSBzdWJqZWN0LCBmb2xsb3cgdGhlIHN0ZXBzIGluIHRoZSBhYm92ZSBzZWN0aW9uIHRvIGdlbmVyYXRlIGl0CjEuIFJlbmFtZSB0aGUgZmlsZSAKICAgLSBGb3IgZXhhbXBsZSwgYG9iX3RndF9hbGxgIGNvdWxkIGJlIHJlbmFtZWQgdG8gYG9iX3RndF9nYXZgCiAgIC0gUmVuYW1pbmcgdGhlIGZpbGUgd2lsbCBwcm9tcHQgRVAgVG9vbGtpdCB0byBhc2sgd2hldGhlciB5b3Ugd2FudCB0byBnZW5lcmF0ZSBhIG5ldyBmaWxlIHdpdGggdGhpcyBuZXcgbmFtZSwgb3Igb3ZlcndyaXRlIHRoZSBleGlzdGluZyBkYXRhZmlsZSBvbmNlIHlvdXIgY2hhbmdlcyBhcmUgY29tcGxldGUKMS4gU2VsZWN0IGBTdWJqZWN0c2AgZnJvbSB0aGUgb3B0aW9ucyBhdCB0aGUgdG9wIG9mIHRoZSBlZGl0b3Igd2luZG93CjEuIENsaWNrIGBBbGxgIGZyb20gYW1vbmcgdGhlIG9wdGlvbnMgb24gdGhlIGxlZnRoYW5kIHNpZGUgb2YgdGhlIGBTdWJqZWN0c2Agd2luZG93CiAgIC0gVGhpcyB3aWxsIHNlbGVjdCBhbGwgb2YgdGhlIHN1YmplY3RzCjEuIFNjcm9sbCB0byB0aGUgYm90dG9tIG9mIHRoZSBsaXN0IG9mIHN1YmplY3RzIGFuZCAqKmRlc2VsZWN0KiogdGhlIHN1YmplY3QgbGFiZWxlZCBgZ3JhbmQgYXZlcmFnZWAKICAgLSBFc3NlbnRpYWxseSwgdGhlIGdvYWwgaGVyZSBpcyB0byBjcmVhdGUgYSBkYXRhc2V0IHRoYXQgaW5jbHVkZXMgT05MWSB0aGUgZ3JhbmQgYXZlcmFnZSBpbmZvcm1hdGlvbiwgcmF0aGVyIHRoYW4gZWFjaCBpbmRpdmlkdWFsIHN1YmplY3QKMS4gT25jZSBldmVyeXRoaW5nIEVYQ0VQVCBmb3IgdGhlIGdyYW5kIGF2ZXJhZ2Ugc3ViamVjdCBpcyBzZWxlY3RlZCwgY2xpY2sgYERlbGV0ZWAgb24gdGhlIGxlZnRoYW5kIHNpZGUgb2YgdGhlIGVkaXRvciB3aW5kb3cKICAgLSBUaGlzIHdpbGwgcmVtb3ZlIHRoZSBpbmRpdmlkdWFsIHN1YmplY3QgZGF0YSBmcm9tIHRoZSBkYXRhc2V0IGFuZCBsZWF2ZSB0aGUgZ3JhbmQgYXZlcmFnZSBpbmZvcm1hdGlvbiAKMS4gQ2xpY2sgYERvbmVgCjEuIElmIHlvdSByZW5hbWVkIHRoZSBkYXRhZmlsZSwgRVAgVG9vbGtpdCBzaG91bGQgZ2VuZXJhdGUgYSBwb3B1cCBtZXNzYWdlIGFza2luZyB3aGV0aGVyIHlvdSB3b3VsZCBsaWtlIHRvIHJlbmFtZSB5b3VyIGRhdGFzZXQgT1IgZ2VuZXJhdGUgYSBuZXcgZGF0YXNldCB1c2luZyB0aGUgbmV3IG5hbWUgKGxlYXZpbmcgdGhlIG9yaWdpbmFsIGRhdGFzZXQgdW50b3VjaGVkKS4KRnJvbSB0aGUgb3B0aW9ucyBwcmVzZW50ZWQsIGNsaWNrIGBOZXdgIHRvIGdlbmVyYXRlIGEgbmV3IGZpbGUgYW5kIHByZXNlcnZlIHRoZSBvcmlnaW5hbAoxLiBUaGUgZWRpdG9yIHdpbmRvdyBzaG91bGQgY2xvc2UsIHJldHVybmluZyB5b3UgdG8gdGhlIEVQIFRvb2xraXQgcGFuZSB0aGF0IGFza3MgeW91IHRvIHNlbGVjdCBhIGRhdGFzZXQgdG8gZWRpdC4gCkZyb20gaGVyZSwgY2xpY2sgYE1haW5gIHRvIHJldHVybiB0byBFUCBUb29sa2l0ICJob21lIgoxLiBPbmNlIGluIHRoZSBtYWluIHdpbmRvdywgY2xpY2sgYFNhdmVgCiAgIC0gU2V0IHRoZSBzYXZlIGZvcm1hdCB0byBgVGV4dCAoLnR4dClgCiAgIC0gQ2xpY2sgdGhlIGdyYW5kIGF2ZXJhZ2UgZGF0YSAoZS5nLiwgYG9iX3RndF9nYXZgKSB0byBzYXZlIGl0CiAgIC0gQSBmaWxlIGV4cGxvcmVyIHdpbmRvdyBzaG91bGQgb3BlbiwgcHJvbXB0aW5nIHlvdSB0byBzZWxlY3QgdGhlIGFwcHJvcHJpYXRlIHNhdmUgbG9jYXRpb24gYW5kIGdpdmUgeW91ciBmaWxlIGEgbmFtZSAKCiMgR2VuZXJhdGluZyBFUlAgQ29tcG9zaXRlIERhdGFmaWxlcwoKMS4gU2F2ZSBhIGNvcHkgb2YgYWxsIGV4dHJhY3RlZCBQQ0EgY29tcG9uZW50IGZpbGVzIChlLmcuLCBgZXJwX29iX3RndF9hbGxfUDNgKSBpbiB0aGUgZm9sbG93aW5nIGxvY2F0aW9uIG9uIHRoZSBMYWIgRHJpdmU6IGBbLi4uXS9EYXRhL0xWMi9QQ0EgQ29tcG9uZW50c2AgdW5kZXIgdGhlIGFwcHJvcHJpYXRlIHRhc2sgKGkuZS4sIE9kZGJhbGwsIEZpc2hzaGFyaywgb3IgU3RvcCBTaWduYWwpCjEuIFVzZSB0aGUgZm9sbG93aW5nIFIgQ29kZSB0byBjb21iaW5lIGFsbCBjb21wb25lbnRzIGludG8gYSBzaW5nbGUgY29tcG9zaXRlcyBkYXRhZmlsZS4KVGhlIGZvbGxvd2luZyBleGFtcGxlIGlzIHRha2VuIGZyb20gdGhlIGBlcnBPZGRiYWxsLlJgIGNvbXBvc2l0ZSBzY3JpcHQgbG9jYXRlZCBpbiBgWy4uLl1EYXRhIFByb2Nlc3NpbmcvMy4gQ29tcG9zaXRlc2AgYW5kIGF2YWlsYWJsZSB2aWEgR2l0IFtoZXJlXShodHRwczovL3Jlc2VhcmNoLWdpdC51aW93YS5lZHUvUGV0ZXJzZW5MYWIvU1JTL1NSUy1EYXRhUHJvY2Vzc2luZy8tL2Jsb2IvbWFzdGVyLzMuJTIwQ29tcG9zaXRlcy9lcnBPZGRiYWxsLlIpLgpDb21wYXJhYmxlIHNjcmlwdHMgaGF2ZSBhbHNvIGJlZW4gY3JlYXRlZCBmb3IgRmlzaFNoYXJrIGFuZCBTdG9wIFNpZ25hbCB0YXNrcy4KICAgMS4gQ3JlYXRlIGEgbGlzdCBvZiBhbGwgUENBIGNvbXBvbmVudCBmaWxlcyBpbiB0aGUgc3BlY2lmaWVkIGRpcmVjdG9yeS4KICAgVGhpcyBsaXN0IHdpbGwgY29udGFpbiB0aGUgZnVsbCBmaWxlcGF0aHMgdG8gZWFjaCBjb21wb25lbnQgZmlsZSB3aGljaCBhcmUgdXNlZCB0byByZWFkIHRoZSBkYXRhIGludG8gUi4KCiAgICAgIGBgYHtyLCBldmFsID0gRkFMU0V9CiAgICAgIG9kZGJhbGxGaWxlUGF0aHMgPC0gbGlzdC5maWxlcygKICAgICAgIHBhdGggPSAiWjovU2hhcmVkIFNlcnZlci9TdHVkeSBGb2xkZXIvRGF0YS9MVjIvRVJQL1BDQSBDb21wb25lbnRzL09kZGJhbGwiLCAKICAgICAgIHBhdHRlcm4gPSAiKi50eHQiLAogICAgICAgcmVjdXJzaXZlID0gRkFMU0UsCiAgICAgICBmdWxsLm5hbWVzID0gVFJVRSkKICAgICAgYGBgCiAgIDEuIEdlbmVyYXRlIGEgbGlzdCBvZiB0aGUgbmFtZXMgb2YgZWFjaCBQQ0EgY29tcG9uZW50IGZpbGUgaW4gdGhlIHNwZWNpZmllZCBkaXJlY3RvcnkuCiAgIFRoaXMgbGlzdCB3aWxsIGJlIHVzZWQgdG8gcmVuYW1lIGNvbHVtbnMgaW4gdGhlIGZpbmFsIGNvbXBvc2l0ZSBkYXRhc2V0IGFjY29yZGluZyB0byB0aGUgbmFtZSBvZiB0aGUgY29tcG9uZW50IGZpbGUuCiAgIEZvciB0aGlzIHJlYXNvbiwgdGhlIG5hbWluZyBjb252ZW50aW9uIG9mIGVhY2ggY29tcG9uZW50IGZpbGVzIGlzIGNydWNpYWw7IHRoaXMgd2lsbCBkZXRlcm1pbmUgaG93IHRoZSBjb3JyZXNwb25kaW5nIGNvbHVtbiBvZiB0aGUgY29tcG9zaXRlIGRhdGFmaWxlIGlzIG5hbWVkLgoKICAgICAgYGBge3IsIGV2YWwgPSBGQUxTRX0KICAgICAgb2RkYmFsbEZpbGVzIDwtIGxpc3QuZmlsZXMoCiAgICAgICBwYXRoID0gIlo6L1NoYXJlZCBTZXJ2ZXIvU3R1ZHkgRm9sZGVyL0RhdGEvTFYyL0VSUC9QQ0EgQ29tcG9uZW50cy9PZGRiYWxsIiwKICAgICAgIHBhdHRlcm4gPSAiKi50eHQiLAogICAgICAgcmVjdXJzaXZlID0gRkFMU0UpCiAgICAgIGBgYAogICAxLiBSZWFkIGluIGVhY2ggY29tcG9uZW50IGZpbGUsIHNraXBwaW5nIHRoZSByb3dzIGNvbnRhaW5pbmcgc3VtbWFyeSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXh0cmFjdGVkIGNvbXBvbmVudCAodGhlIGZpcnN0IDcgcm93cyBpbiB0aGlzIGV4YW1wbGUpLgoKICAgICAgYGBge3IsIGV2YWwgPSBGQUxTRX0KICAgICAgb2RkYmFsbERhdGEgPC0gbGFwcGx5KG9kZGJhbGxGaWxlUGF0aHMsIGZ1bmN0aW9uKHgpIHJlYWRfZGVsaW0oeCwgZGVsaW0gPSAiXHQiLCBza2lwID0gNykpIAogICAgICBgYGAKCiAgIDEuICJDbGVhbiIgdGhlIGxpc3Qgb2YgY29tcG9uZW50IGZpbGUgbmFtZXMgYnkgcmVtb3ZpbmcgdGhlIGZpbGUgZXh0ZW5zaW9uIChpbiB0aGlzIGNhc2UsIGAudHh0YCkuCgogICAgICBgYGB7ciwgZXZhbCA9IEZBTFNFfQogICAgICBjb21wb25lbnROYW1lcyA8LSBvZGRiYWxsRmlsZXMgJT4lIHN0cl9yZW1vdmUoIi50eHQiKQogICAgICBgYGAKCiAgICAxLiBHaXZlIGBJRGAgdmFyaWFibGUgYSBwcm9wZXIgbmFtZS4KCiAgICAgICBgYGB7ciwgZXZhbCA9IEZBTFNFfQogICAgICAgb2RkYmFsbERhdGEgPC0gbGFwcGx5KG9kZGJhbGxEYXRhLCBmdW5jdGlvbih4KXsKICAgICAgICBuYW1lcyh4KVtsZW5ndGgobmFtZXMoeCkpXSA8LSAiSUQiCiAgICAgICAgcmV0dXJuKHgpCiAgICAgICAgfSkKICAgICAgIGBgYAogICAgMS4gQXQgdGhpcyBzdGFnZSwgdGhlIEVSUCBjb21wb25lbnQgZGF0YSBhcmUgbmVzdGVkIHdpdGhpbiBhIGxpc3Qgb2Ygc2VwYXJhdGUgZGF0YSBvYmplY3RzLgogICAgV2UgbXVzdCB0aGVyZWZvcmUgbWVyZ2UgdGhlbSBpbnRvIGEgc2luZ2xlIGRhdGFmcmFtZSBvYmplY3QuCgogICAgICAgYGBge3IsIGV2YWwgPSBGQUxTRX0KICAgICAgIG9kZGJhbGxEYXRhTWVyZ2VkIDwtIG9kZGJhbGxEYXRhICU+JQogICAgICAgICAgcmVkdWNlKGZ1bGxfam9pbiwgYnkgPSBjKCJJRCIpKQogICAgICAgYGBgCiAgICAxLiBPcmdhbml6ZSB0aGUgY29tYmluZWQgZGF0YS4KICAgIFRoZSBjb2RlIGJlbG93IHBlcmZvcm1zIHRoZSBmb2xsb3dpbmcgb3BlcmF0aW9ucyAoaW4gb3JkZXIgb2YgYXBwZWFyYW5jZSk6CiAgICAgICAqIENyZWF0ZSBgdGNpZGAgdmFyaWFibGUgYnkgZXh0cmFjdGluZyB0aGUgZmlyc3QgZm91ciBjaGFyYWN0ZXJzIG9mIGV4aXN0aW5nIGBJRGAgdmFyaWFibGUKICAgICAgICogQ3JlYXRlIGB3YXZlYCB2YXJpYWJsZSBieSBleHRyYWN0aW5nIHRoZSA2dGggYW5kIDd0aCBjaGFyYWN0ZXJzIG9mIGV4aXN0aW5nIGBJRGAgdmFyaWFibGUKICAgICAgICogUmUtb3JkZXIgdGhlIGRhdGEgc28gdGhhdCBgdGNpZGAgYW5kIGB3YXZlYCBhcHBlYXIgYXMgdGhlIGZpcnN0IHR3byBjb2x1bW5zIHdoaWxlIGFsbCBvdGhlciBjb2x1bW5zIHJldGFpbiB0aGVpciBvcmRlciBpbiB0aGUgZGF0YXNldAogICAgICAgKiBSZW1vdmUgdGhlIGBJRGAgdmFyaWFibGUgbm93IHRoYXQgaXQgaGFzIGJlZW4gc2VwYXJhdGVkIGludG8gYHRjaWRgIGFuZCBgd2F2ZWAKICAgICAgICogQ29udmVydCBhbGwgdmFsdWVzIHRvIG51bWVyaWMKCiAgICAgICBgYGB7ciwgZXZhbCA9IEZBTFNFfQogICAgICAgb2RkYmFsbERhdGFDbGVhbiA8LSBvZGRiYWxsRGF0YU1lcmdlZCAlPiUKICAgICAgICAgIG11dGF0ZSh0Y2lkID0gc3Vic3RyKElELCAxLCA0KSwKICAgICAgICAgICAgICAgICB3YXZlID0gc3Vic3RyKElELCA2LCA3KSkgJT4lCiAgICAgICAgICBzZWxlY3QodGNpZCwgd2F2ZSwgZXZlcnl0aGluZygpKSAlPiUKICAgICAgICAgIHNlbGVjdCgtSUQpICU+JSAKICAgICAgICAgIHR5cGVfY29udmVydCgpCiAgICAgICBgYGAKICAgIDEuIFVwZGF0ZSBjb2x1bW4gbmFtZXMgb2YgbWVyZ2VkIGRhdGEgYWNjb3JkaW5nIHRvIHRoZSBsaXN0IG9mIFBDQSBjb21wb25lbnQgZmlsZXMuCgogICAgICAgYGBge3IsIGV2YWwgPSBGQUxTRX0KICAgICAgIG5hbWVzKG9kZGJhbGxEYXRhQ2xlYW4pIDwtIGMoInRjaWQiLCAid2F2ZSIsIGNvbXBvbmVudE5hbWVzKQogICAgICAgYGBgCiAgICAxLiBTYXZlIGNvbXBvc2l0ZSBkYXRhIHRvIGRlc2lyZWQgbG9jYXRpb24uCgogICAgICAgYGBge3IsIGV2YWwgPSBGQUxTRX0KICAgICAgIHdyaXRlX2NzdihvZGRiYWxsRGF0YUNsZWFuLCBmaWxlID0gIlo6L1NoYXJlZCBTZXJ2ZXIvU3R1ZHkgRm9sZGVyL0RhdGEvUkVEQ2FwL0NvbXBvc2l0ZXMvZXJwT2RkYmFsbC5jc3YiKQogICAgICAgYGBgCgojIFZpc3VhbGl6YXRpb25zIGluIFIgCgojIyBSIENvZGUgZm9yIEdyYW5kIEF2ZXJhZ2UgV2F2ZWZvcm0gUGxvdAoKMS4gUmVhZCBpbiB0aGUgZ3JhbmQgYXZlcmFnZSB3YXZlZm9ybSBkYXRhIGV4cG9ydGVkIGZyb20gRVAgVG9vbGtpdC4KICAgLSBXZSBjdXJyZW50bHkgcHJvY2VzcyB0aGUgY29uZGl0aW9ucyB3aXRoaW4gYSBnaXZlbiB0YXNrIHNlcGFyYXRlbHksIHNvIGVhY2ggY29uZGl0aW9uIHNob3VsZCBoYXZlIGl0cyBvd24gZ3JhbmQgYXZlcmFnZSBmaWxlLgogICBgYGB7ciwgZXZhbCA9IEZBTFNFfQogICBvYlRndCA8LSByZWFkLnRhYmxlKCJWOi9TUlMtRVJQLU9kZGJhbGwvSGFyZC9BbGwvNCAtIEVQVCBBdmVyYWdlcy8yMDI0LTExLTA1L2dhdmUvb2JfdGd0X2dhdi50eHQiKQogICBvYkZycSA8LSByZWFkLnRhYmxlKCJWOi9TUlMtRVJQLU9kZGJhbGwvSGFyZC9BbGwvNCAtIEVQVCBBdmVyYWdlcy8yMDI0LTExLTA1L2dhdmUvb2JfZnJxX2dhdi50eHQiKQogICBgYGAKCjEuIENyZWF0ZSBhIHN1YnNldCBvZiBkYXRhIHRoYXQgb25seSBpbmNsdWRlcyB0aG9zZSBlbGVjdHJvZGVzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIGNsdXN0ZXJzIGlkZW50aWZpZWQgaW4gRVAgVG9vbGtpdC4KICAgLSBUaGUgZ3JhbmQgYXZlcmFnZSBkYXRhIGRvZXMgbm90IGhhdmUgcm93IG9yIGNvbHVtbiBsYWJlbHMsIGJ1dCB0aGUgY29sdW1ucyByZXByZXNlbnQgdGhlIEVFRyBuZXQgY2hhbm5lbHMgaW4gbnVtZXJpY2FsIG9yZGVyICgxLTEyOSkuCiAgIFdlIGNhbiB0aGVyZWZvcmUgdXNlIHRoZWlyIGNvbHVtbiBpbmRleCB2YWx1ZXMgdG8gc2VsZWN0IHRoZSBkZXNpcmVkIGVsZWN0cm9kZXM7IHNvLCB0aGUgbGlzdCBjb250YWluaW5nIHRoZSBjaGFubmVsIG51bWJlcnMgc2hvdWxkIGluY2x1ZGUgT05MWSBudW1iZXJzLgogICBUaGUgY29kZSB0aGF0IHNlbGVjdHMgdGhlc2UgY2hhbm5lbHMgb3V0IG9mIHRoZSBmdWxsIGRhdGFzZXQgd2lsbCByZWx5IG9uIG51bWVyaWNhbCBpbnB1dC4gIAogICBgYGB7ciwgZXZhbCA9IEZBTFNFfQogICAjIFNldCBlbGVjdHJvZGUgY2x1c3RlcnMKICAgb2JFbGVjdHJvZGVzIDwtIGMoNTgsIDU5LCA2NCwgNjUsIDY2LCA2NywgNjksIDcwLCA3MSwgNzIsIDczLCA3NCwgNzUsIDc2LCA3NywgODEsIDgyLCA4MywgODQsIDg5LCA4MCwgOTEsIDk1LCA5NiwgMTAxKQoKICAgIyBTdWJzZXQgdG8gZGVzaXJlZCBlbGVjdHJvZGVzCiAgIG9iVGd0X3N1YiA8LSBvYlRndFssIG9iRWxlY3Ryb2Rlc10KICAgb2JGcnFfc3ViIDwtIG9iRnJxWywgb2JFbGVjdHJvZGVzXQogICBgYGAKMS4gQ29tcHV0ZSBhdmVyYWdlcyBhbmQgY3JlYXRlIGxhYmVscyBmb3IgY29uZGl0aW9ucwogICAtIE9uY2UgdGhlIGRhdGEgaGF2ZSBiZWVuIHN1YnNldHRlZCBkb3duIHRvIGluY2x1ZGUgb25seSB0aGUgZWxlY3Ryb2RlIGNoYW5uZWxzIG9mIGludGVyZXN0LCBhbGwgdGhhdCByZW1haW5zIGlzIHRvIGNvbXB1dGUgdGhlIGF2ZXJhZ2UgYW1wbGl0dWRlIGFjcm9zcyBhbGwgb2YgdGhvc2UgY2hhbm5lbHMKICAgLSBBZGRpbmcgYSBjb25kaXRpb24gbGFiZWwgd2lsbCBhbGxvdyB1cyB0byBjb21iaW5lIHRoZSB0d28gY29uZGl0aW9uLXNwZWNpZmljIGRhdGFzZXRzIGludG8gb25lIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHZpc3VhbGl6YXRpb25zIAogICAgICAtIEZvciBlYXNlIG9mIHBsb3R0aW5nLCBuYW1lIHRoZSBjb25kaXRpb25zIHRoZSB3YXkgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGVtIHRvIGFwcGVhciBvbiB0aGUgZmlndXJlIChpLmUuLCAiVGFyZ2V0IiBpbnN0ZWFkIG9mICJ0Z3QiKQogICAKICAgYGBge3IsIGV2YWwgPSBGQUxTRX0KICAgIyBDb21wdXRlIGF2ZXJhZ2VzIAogICBvYlRndF9zdWIkYW1wbGl0dWRlIDwtIHJvd01lYW5zKG9iVGd0X3N1YikKICAgb2JGcnFfc3ViJGFtcGxpdHVkZSA8LSByb3dNZWFucyhvYkZycV9zdWIpCgogICAjIFJlbW92ZSByYXcgdmFsdWVzIGFuZCBhZGQgY29uZGl0aW9uIGxhYmVscwogICBvYlRndF9hbXBzIDwtIG9iVGd0X3N1YiAlPiUgc2VsZWN0KGFtcGxpdHVkZSkgJT4lIG11dGF0ZShjb25kaXRpb24gPSAiVGFyZ2V0IikKICAgb2JGcnFfYW1wcyA8LSBvYkZycV9zdWIgJT4lIHNlbGVjdChhbXBsaXR1ZGUpICU+JSBtdXRhdGUoY29uZGl0aW9uID0gIkZyZXF1ZW50IikKICAgYGBgCgoxLiBBZGQgdGltaW5nLXJlbGF0ZWQgaW5mb3JtYXRpb24gdG8gdGhlIGRhdGEKICAgLSBFUCBUb29sa2l0IGV4cG9ydHMgRVJQIGRhdGEgd2l0aG91dCB0aW1lc3RhbXBzLCBidXQgYXJyYW5nZXMgaXQgaW4gb3JkZXIgb2YgdGltaW5nCiAgIC0gV2UgY2FuIGNyZWF0ZSBhIHRlbXBsYXRlIHdpdGggdGhlIGFwcHJvcHJpYXRlIHRpbWVzdGFtcHMgYW5kIGFwcGVuZCB0aGlzIGNvbHVtbiB0byB0aGUgYW1wbGl0dWRlIGRhdGEKICAgYGBge3IsIGV2YWwgPSBGQUxTRX0KICAgIyBDcmVhdGUgdGVtcGxhdGUKICAgZXJwVGVtcGxhdGUgPC0gZGF0YS5mcmFtZSgKICAgICB0aW1lID0gLTE5OToxMDAwCiAgICkKCiAgICMgTWVyZ2UgdGVtcGxhdGUgd2l0aCBhbXBsaXR1ZGUgZGF0YQogICBvYlRndFRpbWVzIDwtIGNiaW5kKGVycFRlbXBsYXRlLCBvYlRndF9hbXBzKQogICBvYkZycVRpbWVzIDwtIGNiaW5kKGVycFRlbXBsYXRlLCBvYkZycV9hbXBzKQogICBgYGAKMS4gQ29tYmluZSBhbGwgY29uZGl0aW9ucyBpbnRvIGEgc2luZ2xlIGRhdGEgb2JqZWN0IHRvIGJlIHVzZWQgZm9yIHBsb3R0aW5nIAogICBgYGB7ciwgZXZhbCA9IEZBTFNFfQogICBvZGRiYWxsIDwtIHJiaW5kKG9iVGd0VGltZXMsIG9iRnJxVGltZXMpICU+JSAKICAgICAgICAgICAgICBzZWxlY3QodGltZSwgY29uZGl0aW9uLCBhbXBsaXR1ZGUpICU+JSAKICAgICAgICAgICAgICBhcnJhbmdlKHRpbWUpCiAgIGBgYAoKMS4gR2VuZXJhdGUgdGhlIHdhdmVmb3JtIGZpZ3VyZXMgCiAgIGBgYHtyLCBldmFsID0gRkFMU0V9CiAgIGdncGxvdCgKICAgICBkYXRhID0gb2RkYmFsbCwKICAgICBhZXMoCiAgICAgICB4ID0gdGltZSwKICAgICAgIHkgPSBhbXBsaXR1ZGUsCiAgICAgICBncm91cCA9IGNvbmRpdGlvbiwKICAgICAgIGNvbG9yID0gY29uZGl0aW9uCiAgICAgKQogICApICsKICAgICBnZW9tX2xpbmUobGluZXdpZHRoID0gMS41KSArCiAgICAgc2NhbGVfeF9jb250aW51b3VzKAogICAgICAgbmFtZSA9ICJUaW1lIFJlbGF0aXZlIHRvIFN0aW11bHVzIE9uc2V0IChtcykiLAogICAgICAgbGltaXRzID0gYygtMjAwLCAxMDAwKSwKICAgICAgIGJyZWFrcyA9IHNlcShmcm9tID0gLTIwMCwgdG8gPSAxMDAwLCBieSA9IDIwMCkpICsKICAgICBzY2FsZV95X2NvbnRpbnVvdXMoCiAgICAgICBuYW1lID0gIlZvbHRhZ2UgKG1pY3Jvdm9sdHMpIiwKICAgICAgIGxpbWl0cyA9IGMoLTQsIDEwKSwKICAgICAgIGJyZWFrcyA9IHNlcShmcm9tID0gLTEwLCB0byA9IDE1LCBieSA9IDIpKSArCiAgICAgc2NhbGVfY29sb3JfdmlyaWRpc19kKCkrCiAgICAgdGhlbWVfY2xhc3NpYyhiYXNlX3NpemUgPSAxOCkgKwogICAgIHRoZW1lKAogICAgICAgbGVnZW5kLnBvc2l0aW9uID0gYyguNywgLjkpLAogICAgICAgbGVnZW5kLnRpdGxlID0gZWxlbWVudF9ibGFuaygpKQogICBgYGAKCiMgQXBwZW5kaXggCgojIyBUcm91Ymxlc2hvb3RpbmcKMS4gUnVubmluZyBvdXQgb2Ygc3BhY2Ugb24gRVAgVG9vbGtpdD8gCllvdSBjYW4gbmF2aWdhdGUgdG8geW91ciBmb2xkZXIgKG1heWJlIHVuZGVyIERvY3VtZW50cy9NQVRMQUIvRVB3b3JrKSBhbmQgZGVsZXRlIGV2ZXJ5dGhpbmcgZXhjZXB0IGZvciBFUHByZWZzIHRvIHJlZnJlc2ggeW91ciB3b3Jrc3BhY2UuIApOT1RFOiBUaGlzIHdpbGwgZGVsZXRlIGV2ZXJ5dGhpbmcgc3RvcmVkIGluIEVQIFRvb2xraXQsIHNvIHJlbWVtYmVyIHRvIGJhY2sgdXAgZmlsZXMgdGhhdCB5b3UgbmVlZCB0byBzYXZlLgoxLiBJZiB5b3UgZ2V0IGFuIGVycm9yIG9yIGEgd2FybmluZyBmcm9tIEdpdCB3aGVuIHRyeWluZyB0byBjb21taXQgYW5kL29yIHB1c2ggRVJQIGZpbGVzIHVwIHRvIHRoZSByZXBvLCB5b3UgbWF5IG5lZWQgdG8gaW5pdGlhbGl6ZSBHaXQgTEZTLgpUaGUgaW5zdHJ1Y3Rpb25zIGZvciBpbml0aWFsaXppbmcgR2l0IExGUyBjYW4gYmUgZm91bmQgW2hlcmVdKGh0dHBzOi8vZGV2cHN5bGFiLmdpdGh1Yi5pby9EYXRhQW5hbHlzaXMvZ2l0Lmh0bWwjZ2l0TGZzKS4KICAgLSBUaGUgZmlsZXR5cGVzIHRoYXQgY29tbW9ubHkgY2F1c2Ugc3VjaCBlcnJvcnMgaW4gb3VyIGN1cnJlbnQgRVJQIHByb2Nlc3NpbmcgcGlwZWxpbmUgYXJlOgogICAgICAtIGAudHh0YCBmaWxlcwogICAgICAtIGAuZXB0YCBmaWxlcwogICAgICAtIGAuc2V0YCBmaWxlcwoKIyMgVG8tZG8KCi0gQmV0dGVyIGRlc2NyaWJlIHRoZSBtaXNzaW5nbmVzcyBmb3IgZmlsZXMKICAgICAtIFdlIG5lZWQgYSBzeXN0ZW1hdGljIHdheSB0byBpZGVudGlmeSBuZXcgd2F5cyB0byBwcm9jZXNzIHRoZSBtaXNzaW5nbmVzcwogICAgIC0gRmluZCBhIHdheSB0byBiZXN0IGRlc2NyaWJlIGFuZCByZXBvcnQgdGhlIHdheXMgb2YgbWlzc2luZ25lc3MKLSBHbyB0aHJvdWdoIHRoZSBtYXhtZW0gZWRpdHMgb24gdGhlIGNsZWFuX3Jhd0RhdGEgcXVlc3Rpb24uCldlIHdhbnQgYSBzdGFuZGFyZGl6ZWQgdmFsdWUgb24gdGhlIG1hY2hpbmVzCi0gTG9vayBhdCB0aGUgd2FybmluZyBtZXNzYWdlcyBmb3IgdGhlIGF1dG9tYXRpYyBzY3JpcHQgdXBkYXRlcwogICAgIC0gYXV0b21hdGljIGNsZWFuaW5nIG9mIGZpbGVzIHByb2JsZW1zCi0gSW50ZWdyYXRlIEVSUExBQiB3aXRoIG91ciBleGlzdGluZyBFRUdMYWIgRnVuY3Rpb25zIGluY2x1ZGluZzogCiAgICAtIEFkZGluZyBhbiBldmVudCBsaXN0OiAKICAgICAgICAgLSBDdXJyZW50bHksIHNvbWUgY29kZSBmb3IgdGhpcyBpcyB1cGRhdGVkIGluIHRoZSBzY3JpcHQgb24gdGhlIGxhYiBkcml2ZQogICAgICAgICAtIERvY3VtZW50YXRpb24gaXMgW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9sdWNrbGFiL2VycGxhYi93aWtpL0NyZWF0aW5nLWFuLUV2ZW50TGlzdDotRVJQTEFCLUZ1bmN0aW9uczotVHV0b3JpYWwpCiAgICAtIEZpZ3VyZSBvdXQgaG93IHRvIGF2ZXJhZ2UgZXBvY2hzIGFuZCBleHBvcnQgdG8gdGhlIEVQIFRvb2xraXQKIC0gRXZhbHVhdGUgdGhlIHNlbWktYXV0b21hdGVkIHBpcGVsaW5lcyBmcm9tOgogICAgLSBbRGVibmF0aCBldCBhbC4gKDIwMjApXShodHRwczovL29ubGluZWxpYnJhcnkud2lsZXkuY29tL2RvaS9mdWxsLzEwLjExMTEvcHN5cC4xMzU4MCkKICAgIC0gW0Rlc2phcmRpbnMgZXQgYWwuICgyMDIxKV0oaHR0cHM6Ly93d3cuc2NpZW5jZWRpcmVjdC5jb20vc2NpZW5jZS9hcnRpY2xlL3BpaS9TMDE2NTAyNzAyMDMwMzg0OCkKICAgIC0gW0ZsbyBldCBhbC4gKDIwMjIpXShodHRwczovL3d3dy5zY2llbmNlZGlyZWN0LmNvbS9zY2llbmNlL2FydGljbGUvcGlpL1MxODc4OTI5MzIyMDAwMjE0KQogICAgLSBbR2FiYXItRHVybmFtIGV0IGFsLiAoMjAxOCldKGh0dHBzOi8vd3d3LmZyb250aWVyc2luLm9yZy9hcnRpY2xlcy8xMC4zMzg5L2ZuaW5zLjIwMTguMDAwOTcvZnVsbCkKICAgIC0gW0hhcmVzaWduIGV0IGFsLiAoMjAyMSldKGh0dHBzOi8vd3d3LnNjaWVuY2VkaXJlY3QuY29tL3NjaWVuY2UvYXJ0aWNsZS9waWkvUzE4Nzg5MjkzMjEwMDExNDYpCiAgICAtIFtLdW1hcmF2ZWwgZXQgYWwuICgyMDIyKV0oaHR0cHM6Ly93d3cuc2NpZW5jZWRpcmVjdC5jb20vc2NpZW5jZS9hcnRpY2xlL3BpaS9TMTg3ODkyOTMyMjAwMDEyMykKCiMjIEVFR0xhYiBQcm9jZXNzaW5nIFN0ZXBzCgpodHRwczovL2VlZ2xhYi5vcmcvdHV0b3JpYWxzLwoKMS4gRmlsdGVyaW5nCjEuIEF2ZXJhZ2UgUmVmZXJlbmNpbmcKMS4gQXJ0aWZhY3QgUmVqZWN0aW9uCiAgICAxLiBBdXRvbWF0ZWQgYXJ0aWZhY3QgcmVqZWN0aW9uIChzYXZlIGludGVybWVkaWF0ZSBmaWxlKQogICAgMS4gTWFudWFsIHNlbGVjdGlvbiBvZiBiYWQgY2hhbm5lbHMKICAgIDEuIE1hbnVhbCBzZWxlY3Rpb24gb2YgYmFkIHRpbWUgcGVyaW9kcyAoc2F2ZSBpbnRlcm1lZGlhdGUgZmlsZSkKICAgIDEuIFJlbW92YWwgb2YgbWFudWFsbHkgc2VsZWN0ZWQgYmFkIGNoYW5uZWxzCiAgICAxLiBSZW1vdmFsIG9mIG1hbnVhbGx5IHNlbGVjdGVkIGJhZCB0aW1lIHBlcmlvZHMgKHNhdmUgaW50ZXJtZWRpYXRlIGZpbGUpCiAgICAxLiBbSW5kZXBlbmRlbnQgQ29tcG9uZW50IEFuYWx5c2lzXSgjaWNhKSAoSUNBKQogICAgICAgIDEuIFJ1biBJQ0EKICAgICAgICAxLiBBdXRvbWF0ZWQgcmVtb3ZhbCBvZiBiYWQgSUNBIGNvbXBvbmVudHMKICAgICAgICAxLiBSZS1ydW4gSUNBIChzYXZlIGludGVybWVkaWF0ZSBmaWxlKQogICAgICAgIDEuIE1hbnVhbCBzZWxlY3Rpb24gb2YgYmFkIElDQSBjb21wb25lbnRzIChzYXZlIGludGVybWVkaWF0ZSBmaWxlKQogICAgICAgIDEuIFJlbW92YWwgb2YgbWFudWFsbHkgc2VsZWN0ZWQgYmFkIElDQSBjb21wb25lbnRzCjEuIEludGVycG9sYXRpb24gb2YgQmFkIENoYW5uZWxzCjEuIEF2ZXJhZ2UgUmVmZXJlbmNpbmcKMS4gU2VnbWVudGF0aW9uCjEuIEJhc2VsaW5lIENvcnJlY3Rpb24gKHNhdmUgZmluYWwgZmlsZSkKCiMjIEVFR0xBQgoKIyMjIEluc3RhbGwgUGx1Z2lucwoKTUZGTWF0bGFiSU8gcGx1Z2luCgojIyMgSW1wb3J0IERhdGEKCkZpbGUg4oaSIEltcG9ydCBEYXRhIOKGkiBVc2luZyBFRUdMQUIgZnVuY3Rpb25zIGFuZCBwbHVnaW5zIOKGkiBJbXBvcnQgTWFnc3RpbS9FR0kgLm1mZiBmaWxlCgpgYGBtYXRsYWIKRUVHID0gcG9wX21mZmltcG9ydCh7J1xcXFxsYy1ycy1zdG9yZTI0LmhwYy51aW93YS5lZHVcXGxzc19pdHBldGVyc2VuXFxMYWJcXFN0dWRpZXNcXFNjaG9vbCBSZWFkaW5lc3MgU3R1ZHlcXERhdGFcXExWMlxcRVJQXFxPZGRiYWxsXFwwLVJhdyBEYXRhIChtZmYpXFwxNjEzXzkwX29kZGJhbGwubWZmJ30seydjb2RlJ30sMCwwKTsKCltBTExFRUcgRUVHIENVUlJFTlRTRVRdID0gcG9wX25ld3NldChBTExFRUcsIEVFRywgMSwnb3ZlcndyaXRlJywnb24nLCdndWknLCdvZmYnKTsKYGBgCgpTZWxlY3QgYC5tZmZgIGZpbGUocykKCkV2ZW50IHR5cGUgZmllbGQgKG1heSBzZWxlY3QgbXVsdGlwbGUpOiBgY29kZWAKCiMjIyBGaWx0ZXIgRGF0YQoKRmlsdGVyIOKGkiBCYXNpYyBGSVIgRmlsdGVyCgowLjEgLS0gMzAgSHoKCnNhdmUgYXMgbmV3IG5hbWUKCmBgYG1hdGxhYgpFRUcgPSBwb3BfZWVnZmlsdG5ldyhFRUcsICdsb2N1dG9mZicsMC4xLCdoaWN1dG9mZicsMzAsJ3Bsb3RmcmVxeicsMSk7CmBgYAoKIyMjIEF2ZXJhZ2UgUmVmZXJlbmNpbmcKClRvb2xzIOKGkiBSZS1yZWZlcmVuY2UgdGhlIGRhdGEg4oaSIENvbXB1dGUgYXZlcmFnZSByZWZlcmVuY2UKCmBgYG1hdGxhYgpFRUcgPSBlZWdfY2hlY2tzZXQoIEVFRyApOwpFRUcgPSBwb3BfcmVyZWYoIEVFRywgW10pOwpbQUxMRUVHIEVFRyBDVVJSRU5UU0VUXSA9IHBvcF9uZXdzZXQoQUxMRUVHLCBFRUcsIDEsJ3NldG5hbWUnLCcxNjEzXzkwX29kZGJhbGxfZmlsX3JlZicsJ292ZXJ3cml0ZScsJ29uJywnZ3VpJywnb2ZmJyk7IAplZWdsYWIgcmVkcmF3OwpgYGAKCiMjIyBBcnRpZmFjdCBSZWplY3Rpb24KCiMjIyMgQXV0b21hdGVkIEFydGlmYWN0IFJlamVjdGlvbgoKVG9vbHMg4oaSIFJlamVjdCBkYXRhIHVzaW5nIENsZWFuIFJhd2RhdGEgYW5kIEFTUgoKYGBgbWF0bGFiCkVFRyA9IGVlZ19jaGVja3NldCggRUVHICk7CkVFRyA9IHBvcF9jbGVhbl9yYXdkYXRhKEVFRywgJ0ZsYXRsaW5lQ3JpdGVyaW9uJyw1LCdDaGFubmVsQ3JpdGVyaW9uJywwLjgsJ0xpbmVOb2lzZUNyaXRlcmlvbicsNCwnSGlnaHBhc3MnLCdvZmYnLCdCdXJzdENyaXRlcmlvbicsMjAsJ1dpbmRvd0NyaXRlcmlvbicsMC4yNSwnQnVyc3RSZWplY3Rpb24nLCdvbicsJ0Rpc3RhbmNlJywnRXVjbGlkaWFuJywnV2luZG93Q3JpdGVyaW9uVG9sZXJhbmNlcycsWy1JbmYgN10gKTsKW0FMTEVFRyBFRUcgQ1VSUkVOVFNFVF0gPSBwb3BfbmV3c2V0KEFMTEVFRywgRUVHLCAxLCdndWknLCdvZmYnKTsgCmVlZ2xhYiByZWRyYXc7CmBgYAoKQ3VycmVudGx5LCB3ZSBydW4gaW50byBhIGJ1ZyB0aGF0IHlpZWxkcyB0aGUgZm9sbG93aW5nIGVycm9yOgoKYGBgCk5vdCBlbm91Z2ggbWVtb3J5LCBUaGlzIGlzIG5vdCBhIGJ1ZyAoRXJyb3Igb2NjdXJyZWQgaW4gZnVuY3Rpb24gYXNyX3Byb2Nlc3MoKSBhdCBsaW5lIDEzMikKYGBgCgpBcyBhIHdvcmthcm91bmQsIHR5cGUgdGhlIGZvbGxvd2luZyBjb2RlIGluIE1BVExBQiB0byBlZGl0IHRoZSBmdW5jdGlvbjoKCmBgYG1hdGxhYgplZGl0IGNsZWFuX2FydGlmYWN0cwpgYGAKClRoZW4sIGNoYW5nZSB0aGUgbnVtYmVyIGluIHRoZSBmb2xsb3dpbmcgbGluZSB0byBhIGxhcmdlciBudW1iZXIgKGUuZy4sIDI1NikgYW5kIGNsaWNrIHNhdmU6CgpgYGBtYXRsYWIKeydtYXhfbWVtJywnTWF4TWVtJ30sIDI1NiwgLi4uCmBgYAoKIyMjIyBTZWxlY3Rpb24gb2YgQmFkIENoYW5uZWxzCgpWaWV3IGRhdGEgdG8gaWRlbnRpZnkgYmFkIGNoYW5uZWxzIHRvIHJlamVjdC4KCkVkaXQg4oaSIFNlbGVjdCBkYXRhCgpTcGVjaWZ5IGNoYW5uZWxzIHRvIHJlamVjdAoKU3BlY2lmeSAib24gLT4gcmVtb3ZlIHRoZXNlIgoKYGBgbWF0bGFiCkVFRyA9IGVlZ19jaGVja3NldCggRUVHICk7CkVFRyA9IHBvcF9zZWxlY3QoIEVFRywgJ25vY2hhbm5lbCcseydFNDQnLCdFNTYnLCdFNTcnLCdFMTEzJ30pOwpbQUxMRUVHIEVFRyBDVVJSRU5UU0VUXSA9IHBvcF9uZXdzZXQoQUxMRUVHLCBFRUcsIDEsJ3NldG5hbWUnLCcxNjEzXzkwX29kZGJhbGxfZmlsX3JlZl9jaG4nLCdvdmVyd3JpdGUnLCdvbicsJ2d1aScsJ29mZicpOyAKZWVnbGFiIHJlZHJhdzsKYGBgCgojIyMjIFNlbGVjdGlvbiBvZiBCYWQgVGltZSBQZXJpb2RzCgpQbG90IOKGkiBDaGFubmVsIGRhdGEgKHNjcm9sbCkKCkNoYW5nZSB2b2x0YWdlIHNjYWxlIHRvIDUwCgpTZXR0aW5ncyDihpIgVGltZSByYW5nZSB0byBkaXNwbGF5CgpDaGFuZ2UgdG8gMTAgc2Vjb25kcwoKU2V0dGluZ3Mg4oaSIE51bWJlciBvZiBjaGFubmVscyB0byBkaXNwbGF5CgpDaGFuZ2UgdG8gbnVtYmVyIG9mIGNoYW5uZWxzIHRvIHZpZXcgYXQgb25lIHRpbWUgKGUuZy4sIDY0KQoKVG8gZXJhc2UgYSBzZWxlY3RlZCBwb3J0aW9uIG9mIHRoZSBkYXRhLCBmaXJzdCBkcmFnIHRoZSBtb3VzZSAoaG9sZGluZyBkb3duIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbikgaG9yaXpvbnRhbGx5IGFjcm9zcyB0aGUgdGltZSByZWdpb24gb2YgaW50ZXJlc3QgdG8gbWFyayBpdCBmb3IgcmVqZWN0aW9uLgpUbyBkZXNlbGVjdCBhIHBvcnRpb24gb2YgdGhlIGRhdGEsIHNpbXBseSBjbGljayBvbiB0aGUgc2VsZWN0ZWQgcmVnaW9uLgoKQWZ0ZXIgbWFya2luZyBzb21lIHBvcnRpb25zIG9mIHRoZSBkYXRhIGZvciByZWplY3Rpb24sIHByZXNzIFJFSkVDVCBhbmQgYSBuZXcgZGF0YSBzZXQgd2lsbCBiZSBjcmVhdGVkIHdpdGggdGhlIHJlamVjdGVkIGRhdGEgb21pdHRlZC4KQSBuZXcgZGF0YXNldCB3aWxsIGJlIGNyZWF0ZWQgd2l0aCB0aGUgbWFya2VkIHJlZ2lvbnMgcmVtb3ZlZC4KWW91ciBnb2FsIGlzIHRvIHJlamVjdCBub24tc3RlcmVvdHlwaWMgYXJ0aWZhY3RzLgpEbyBub3QgcmVqZWN0IGJsaW5rcy9zYWNjYWRlcywgYmVjYXVzZSBbaW5kZXBlbmRlbnQgY29tcG9uZW50IGFuYWx5c2lzXSgjaWNhKSB3aWxsIHJlbW92ZSB0aG9zZS4KCkNsaWNraW5nICJTdGFjayIgc3RhY2tzIGFsbCBlbGVjdHJvZGVzIG9uIHRvcCBvZiBlYWNoIG90aGVyIHRvIG1vcmUgZWFzaWx5IGlkZW50aWZ5IG5vaXN5IGRhdGEuCgpDbGljayAiUkVKRUNUIiB0byByZW1vdmUgdGhlIGJhZCB0aW1lIHBlcmlvZHMgZnJvbSB0aGUgZGF0YSBmaWxlLgoKIyMjIyBJbmRlcGVuZGVudCBDb21wb25lbnQgQW5hbHlzaXMgeyNpY2F9CgpodHRwczovL2VlZ2xhYi5vcmcvdHV0b3JpYWxzLzA2X1JlamVjdEFydGlmYWN0cy9SdW5JQ0EuaHRtbCAoYXJjaGl2ZWQgYXQgaHR0cHM6Ly9wZXJtYS5jYy9BRVU5LUdCM0IpCgpodHRwczovL3NvY2lhbHNjaS5saWJyZXRleHRzLm9yZy9Cb29rc2hlbHZlcy9Qc3ljaG9sb2d5L0Jvb2slM0FfQXBwbGllZF9FdmVudC1SZWxhdGVkX1BvdGVudGlhbF9EYXRhX0FuYWx5c2lzXyhMdWNrKS8xNCUzQV9BcHBlbmRpeF8zJTNBX0V4YW1wbGVfUHJvY2Vzc2luZ19QaXBlbGluZSAoYXJjaGl2ZWQgYXQgaHR0cHM6Ly9wZXJtYS5jYy85UVlRLUJORkUpCgpUaGUgY29tcG9uZW50IG9yZGVyIHJldHVybmVkIGJ5IGBydW5pY2EubWAgaXMgaW4gZGVjcmVhc2luZyBvcmRlciBvZiB0aGUgRUVHIHZhcmlhbmNlIGFjY291bnRlZCBmb3IgYnkgZWFjaCBjb21wb25lbnQuCgpUb29scyDihpIgRGVjb21wb3NlIGRhdGEgYnkgSUNBCgpgYGBtYXRsYWIKRUVHID0gZWVnX2NoZWNrc2V0KCBFRUcgKTsKRUVHID0gcG9wX3J1bmljYShFRUcsICdpY2F0eXBlJywgJ3J1bmljYScsICdleHRlbmRlZCcsMSwnaW50ZXJydXB0Jywnb24nKTsKW0FMTEVFRyBFRUddID0gZWVnX3N0b3JlKEFMTEVFRywgRUVHLCBDVVJSRU5UU0VUKTsKZWVnbGFiIHJlZHJhdzsKYGBgCgpQbG90IOKGkiBDb21wb25lbnQgbWFwcyDihpIgMkQKClZpc3VhbGx5IGlkZW50aWZ5IGluZGVwZW5kZW50IGNvbXBvbmVudHMgdG8gcmVtb3ZlCgpUb29scyDihpIgSW5zcGVjdC9sYWJlbCBjb21wb25lbnRzIGJ5IG1hcAoKRXhhbXBsZSBJQ0EgQXJ0aWZhY3QgQ29tcG9uZW50cwoKIVtJQ0EgRXllIEJsaW5rIEFydGlmYWN0XShpbWFnZXMvSUNBX0V5ZUJsaW5rLnBuZykKIVtJQ0EgTGF0ZXJhbCBFeWUgTW92ZW1lbnQgQXJ0aWZhY3RdKGltYWdlcy9JQ0FfTGF0ZXJhbEV5ZU1vdmVtZW50LnBuZykKIVtJQ0EgTXVzY2xlIEFydGlmYWN0XShpbWFnZXMvSUNBX011c2NsZUFydGlmYWN0LnBuZykKIVtJQ0EgQ2FyZGlhYyBBcnRpZmFjdF0oaW1hZ2VzL0lDQV9DYXJkaWFjQXJ0aWZhY3QucG5nKQohW0lDQSBCYWQgQ2hhbm5lbF0oaW1hZ2VzL0lDQV9CYWRDaGFubmVsLnBuZykKCkV4YW1wbGUgSUNBIEJyYWluIENvbXBvbmVudHMKIVtJQ0EgQnJhaW4gQWN0aXZpdHkgRXhhbXBsZSAxXShpbWFnZXMvSUNBX0JyYWluQWN0aXZpdHlFeDEucG5nKQohW0lDQSBCcmFpbiBBY3Rpdml0eSBFeGFtcGxlIDJdKGltYWdlcy9JQ0FfQnJhaW5BY3Rpdml0eUV4Mi5wbmcpCiFbSUNBIEJyYWluIEFjdGl2aXR5IEV4YW1wbGUgM10oaW1hZ2VzL0lDQV9CcmFpbkFjdGl2aXR5RXgzLnBuZykKCk92ZXJ2aWV3IG9mIElDQSBDb21wb25lbnRzCiFbSUNBIE92ZXJ2aWV3XShpbWFnZXMvSUNBX092ZXJ2aWV3LnBuZykKClRvZ2dsZSB0aGUgIkFjY2VwdCIgYnV0dG9uIHRvIHJlamVjdCBhbiBpbmRlcGVuZGVudCBjb21wb25lbnQsIHByZXNzICJPSyIgdG8gc3BlY2lmeSBpdCBmb3IgcmVqZWN0aW9uCgpBdXRvbWF0ZWQgZGV0ZWN0aW9uIG9mIGFydGlmYWN0dWFsIElDQSBjb21wb25lbnRzOgoKaHR0cHM6Ly9lZWdsYWIub3JnL3R1dG9yaWFscy8wNl9SZWplY3RBcnRpZmFjdHMvUnVuSUNBLmh0bWwjYXV0b21hdGVkLWRldGVjdGlvbi1vZi1hcnRpZmFjdHVhbC1pY2EtY29tcG9uZW50cyAoYXJjaGl2ZWQgYXQgaHR0cHM6Ly9wZXJtYS5jYy81UlE3LTlXQlQpCgpgYGBtYXRsYWIKRUVHID0gZWVnX2NoZWNrc2V0KCBFRUcgKTsKRUVHID0gcG9wX2ljbGFiZWwoRUVHLCAnZGVmYXVsdCcpOwpbQUxMRUVHIEVFR10gPSBlZWdfc3RvcmUoQUxMRUVHLCBFRUcsIENVUlJFTlRTRVQpOwpFRUcgPSBlZWdfY2hlY2tzZXQoIEVFRyApOwpFRUcgPSBwb3BfaWNmbGFnKEVFRywgW05hTiBOYU47MC45IDE7MC45IDE7TmFOIE5hTjtOYU4gTmFOO05hTiBOYU47TmFOIE5hTl0pOwpbQUxMRUVHIEVFR10gPSBlZWdfc3RvcmUoQUxMRUVHLCBFRUcsIENVUlJFTlRTRVQpOwplZWdsYWIgcmVkcmF3OwpgYGAKClRoZXJlIGFyZSBzaXggY2F0ZWdvcmllcyBvZiBjb21wb25lbnRzOiBCcmFpbiwgTXVzY2xlLCBFeWUsIEhlYXJ0LCBMaW5lIE5vaXNlLCBDaGFubmVsIE5vaXNlLCBhbmQgT3RoZXIKCk91ciBnb2FsIGlzIHRvIGtlZXAgdGhlIGJyYWluIGNvbXBvbmVudHMgYW5kIHRvIHJlbW92ZSBldmVyeXRoaW5nIGVsc2UgKGkuZS4sIGFydGlmYWN0cykuCgpUb29scyDihpIgQ2xhc3NpZnkgY29tcG9uZW50cyB1c2luZyBJQ0xhYmVsIOKGkiBMYWJlbCBjb21wb25lbnRzCgpUb29scyDihpIgQ2xhc3NpZnkgY29tcG9uZW50cyB1c2luZyBJQ0xhYmVsIOKGkiBGbGFnIGNvbXBvbmVudHMgYXMgYXJ0aWZhY3RzCgpTdWJzdHJhY3RpbmcgcmVqZWN0ZWQgSUNBIGNvbXBvbmVudHM6CgpodHRwczovL2VlZ2xhYi5vcmcvdHV0b3JpYWxzLzA2X1JlamVjdEFydGlmYWN0cy9SdW5JQ0EuaHRtbCNzdWJ0cmFjdGluZy1pY2EtY29tcG9uZW50cy1mcm9tLWRhdGEgKGFyY2hpdmVkIGF0IGh0dHBzOi8vcGVybWEuY2MvSFZINC1aNFNBKQoKVG9vbHMg4oaSIFJlbW92ZSBjb21wb25lbnRzCgpgYGBtYXRsYWIKRUVHID0gcG9wX3N1YmNvbXAoIEVFRywgWzEgICAgMiAgICA2ICAgIDcgICAxMCAgIDEzICAgMjEgICAyNCAgIDI2ICAgMzEgICAzMiAgIDMzICAgMzYgICA0MyAgIDQ0ICAgNTEgICA1NCAgIDU1ICAgNTkgICA2MSAgIDY3ICAgNjggICA3NCAgIDgzICAgOTAgICA5MSAgIDkzICAgOTkgIDEwMyAgMTEyICAxMTMgIDExNiAgMTE4ICAxMjFdLCAwKTsKW0FMTEVFRyBFRUcgQ1VSUkVOVFNFVF0gPSBwb3BfbmV3c2V0KEFMTEVFRywgRUVHLCA2LCdndWknLCdvZmYnKTsgCmVlZ2xhYiByZWRyYXc7CmBgYAoKIyMjIEludGVycG9sYXRlIEJhZCBDaGFubmVscwoKaHR0cHM6Ly9zY2NuLnVjc2QuZWR1L3BpcGVybWFpbC9lZWdsYWJsaXN0LzIwMTYvMDExMTk5Lmh0bWwgKGFyY2hpdmVkIGF0IGh0dHBzOi8vcGVybWEuY2MvOTdOSC04TEFSKQoKVG8gaW50ZXJwb2xhdGUgY2hhbm5lbHMgeW91IHdvdWxkIGxvYWQgdXAgb25lIGZpbGUgdGhhdCBoYXMgb25seSB0aGUgZ29vZCBjaGFubmVscywgdGhlbiBsb2FkIHVwIGEgc2Vjb25kIGZpbGUgdGhhdCBoYXMgdGhlIGZ1bGwgY2hhbm5lbCBsaXN0LCBhbmQgdGhlbiBydW4gdGhlIGNoYW5uZWwgaW50ZXJwb2xhdGlvbiBmdW5jdGlvbiBmcm9tIHRoZSBlZWdsYWIgZ3VpLgoKVG9vbHMg4oaSIEludGVycG9sYXRlIEVsZWN0cm9kZXMg4oaSIFVzZSBhbGwgY2hhbm5lbHMgKG9yIHNwZWNpZmljIGNoYW5uZWxzPykgb2Ygb3RoZXIgZGF0YXNldAoKVXNpbmcgYWxsIGNoYW5uZWxzIG9mIG90aGVyIGRhdGFzZXQ6CgoqKkltcG9ydGFudCBOb3RlOioqIEludGVycG9sYXRpbmcgZmlsZXMgd2lsbCByZS1yZWZlcmVuY2UgdGhlIGRhdGEuCkF2ZXJhZ2UgcmVmZXJlbmNlIHRoZSBkYXRhIGFmdGVyIGludGVycG9sYXRpbmcgY2hhbm5lbHMuCgpgYGBtYXRsYWIKRUVHID0gZWVnX2NoZWNrc2V0KCBFRUcgKTsKRUVHID0gcG9wX2ludGVycChFRUcsIEFMTEVFRygzKS5jaGFubG9jcywgJ3NwaGVyaWNhbCcpOwpbQUxMRUVHIEVFRyBDVVJSRU5UU0VUXSA9IHBvcF9uZXdzZXQoQUxMRUVHLCBFRUcsIDQsJ2d1aScsJ29mZicpOyAKZWVnbGFiIHJlZHJhdzsKYGBgCgpVc2luZyBzcGVjaWZpYyBjaGFubmVscyBvZiBvdGhlciBkYXRhc2V0OgoKYGBgbWF0bGFiCkVFRyA9IGVlZ19jaGVja3NldCggRUVHICk7CkVFRyA9IHBvcF9pbnRlcnAoRUVHLCBBTExFRUcoMykuY2hhbmxvY3MoWzQ0ICAgNTYgICA1NyAgMTEzXSksICdzcGhlcmljYWwnKTsKW0FMTEVFRyBFRUcgQ1VSUkVOVFNFVF0gPSBwb3BfbmV3c2V0KEFMTEVFRywgRUVHLCAxLCdndWknLCdvZmYnKTsgCmVlZ2xhYiByZWRyYXc7CmBgYAoKUmVtb3ZlZCBjaGFubmVsczoKCmBgYG1hdGxhYgpFRUcgPSBlZWdfY2hlY2tzZXQoIEVFRyApOwpFRUcgPSBwb3BfaW50ZXJwKEVFRywgRUVHLmNoYW5pbmZvLm5vZGF0Y2hhbnMoWzQ0ICA1NiAgNTcgIDExM10pLCAnc3BoZXJpY2FsJyk7CltBTExFRUcgRUVHIENVUlJFTlRTRVRdID0gcG9wX25ld3NldChBTExFRUcsIEVFRywgMywnZ3VpJywnb2ZmJyk7IApFRUcgPSBlZWdfY2hlY2tzZXQoIEVFRyApOwplZWdsYWIgcmVkcmF3OwpgYGAKCkRhdGEgY2hhbm5lbHM6CgpgYGBtYXRsYWIKRUVHID0gZWVnX2NoZWNrc2V0KCBFRUcgKTsKRUVHID0gcG9wX2ludGVycChFRUcsIFs0NCAgNTYgIDU3ICAxMTNdLCAnc3BoZXJpY2FsJyk7CltBTExFRUcgRUVHIENVUlJFTlRTRVRdID0gcG9wX25ld3NldChBTExFRUcsIEVFRywgMSwnZ3VpJywnb2ZmJyk7IAplZWdsYWIgcmVkcmF3OwpgYGAKCiMjIyBBdmVyYWdlIFJlZmVyZW5jaW5nCgpUb29scyDihpIgUmUtcmVmZXJlbmNlIHRoZSBkYXRhIOKGkiBDb21wdXRlIGF2ZXJhZ2UgcmVmZXJlbmNlCgpgYGBtYXRsYWIKRUVHID0gZWVnX2NoZWNrc2V0KCBFRUcgKTsKRUVHID0gcG9wX3JlcmVmKCBFRUcsIFtdKTsKW0FMTEVFRyBFRUcgQ1VSUkVOVFNFVF0gPSBwb3BfbmV3c2V0KEFMTEVFRywgRUVHLCAxLCdzZXRuYW1lJywnMTYxM185MF9vZGRiYWxsX2ZpbF9yZWYnLCdvdmVyd3JpdGUnLCdvbicsJ2d1aScsJ29mZicpOyAKZWVnbGFiIHJlZHJhdzsKYGBgCgojIyMgU2VnbWVudGF0aW9uCgpUb29scyDihpIgRXh0cmFjdCBFcG9jaHMKCmBgYG1hdGxhYgpFRUcgPSBlZWdfY2hlY2tzZXQoIEVFRyApOwpFRUcgPSBwb3BfZXBvY2goIEVFRywgeyAgJ2ZycSsnICAndGd0KycgIH0sIFstMC4yICAgICAgICAgICAxXSwgJ25ld25hbWUnLCAnMTYxM185MF9vZGRiYWxsX2ZpbF9yZWYgZXBvY2hzJywgJ2Vwb2NoaW5mbycsICd5ZXMnKTsKW0FMTEVFRyBFRUcgQ1VSUkVOVFNFVF0gPSBwb3BfbmV3c2V0KEFMTEVFRywgRUVHLCAxLCdvdmVyd3JpdGUnLCdvbicsJ2d1aScsJ29mZicpOyAKYGBgCgojIyMgQmFzZWxpbmUgQ29ycmVjdGlvbgoKYGBgbWF0bGFiCkVFRyA9IGVlZ19jaGVja3NldCggRUVHICk7CkVFRyA9IHBvcF9ybWJhc2UoIEVFRywgWy0yMDAgMF0gLFtdKTsKW0FMTEVFRyBFRUcgQ1VSUkVOVFNFVF0gPSBwb3BfbmV3c2V0KEFMTEVFRywgRUVHLCAxLCdvdmVyd3JpdGUnLCdvbicsJ2d1aScsJ29mZicpOyAKZWVnbGFiIHJlZHJhdzsKYGBgCgojIyBBdXRvbWF0aWMgU2NyaXB0IGV4YW1wbGUgCgpgYGBtYXRsYWIKJSBTdGFydGluZyBFRUcgTGFiIApbQUxMRUVHIEVFRyBDVVJSRU5UU0VUIEFMTENPTV0gPSBlZWdsYWI7CgolJSBIZWxwZnVsIGRvY3VtZW50YXRpb24gaXMgbG9jYXRlZCBoZXJlCiUgaHR0cHM6Ly9lZWdsYWIub3JnL3R1dG9yaWFscy8xMV9TY3JpcHRpbmcvVXNpbmdfRUVHTEFCX2hpc3RvcnkuaHRtbCAoYXJjaGl2ZWQgYXQgaHR0cHM6Ly9wZXJtYS5jYy9ZNjg3LTVHS0UpCiUgaHR0cHM6Ly9lZWdsYWIub3JnL3R1dG9yaWFscy9Db25jZXB0c0d1aWRlL0RhdGFfU3RydWN0dXJlcy5odG1sIChhcmNoaXZlZCBhdCBodHRwczovL3Blcm1hLmNjLzVGMzktNVMzMikKCiVMb2FkaW5nIGluIHRoZSBEYXRhc2V0CkVFRyA9IHBvcF9tZmZpbXBvcnQoeydSOlxcTGFiXFxTdHVkaWVzXFxTY2hvb2wgUmVhZGluZXNzIFN0dWR5XFxEYXRhXFxMVjJcXEVSUFxcT2RkYmFsbFxcMC1SYXcgRGF0YSAobWZmKVxcMTYxM185MF9vZGRiYWxsLm1mZid9LHsnY29kZSd9LDAsMCk7CkVFRy5zZXRuYW1lPSdyYXcnOwpFRUcgPSBlZWdfY2hlY2tzZXQoIEVFRyApOwolU3RvcmluZyB0aGUgY3VycmVudCBkYXRhc2V0CltBTExFRUcsIEVFR10gPSBlZWdfc3RvcmUoIEFMTEVFRywgRUVHLCAxKTsKJSByZWZyZXNoaW5nIHRoZSBncmFwaGljYWwgaW50ZXJmYWNlCmVlZ2xhYiByZWRyYXc7CgolRmlsdGVyIHRoZSBkYXRhCkVFRyA9IHBvcF9lZWdmaWx0bmV3KEFMTEVFRygxKSwgJ2xvY3V0b2ZmJywwLjEsJ2hpY3V0b2ZmJywzMCwncGxvdGZyZXF6JywxKTsKJVNhdmUgdGhlIEZpbHRlcmVkIGRhdGFzZXQgCiVBTExFRUcgRUVHIENVUlJFTlRTRVQgc2VlbXMgdG8ganVzdCBiZSBhIG5hbWUgZm9yIGFsbCBvZiB0aGUgY3VycmVudCBkYXRhCiVzZXRzIAolcG9wX25ld3NldCBzZWVtcyB0byBzYXZlIHRoZSBkYXRhc2V0IGluIGJvdGggbWVtb3J5IGFuZCBpbiB0aGUgdG9vbGtpdApbQUxMRUVHLCBFRUcsIENVUlJFTlRTRVRdID0gcG9wX25ld3NldChBTExFRUcsIEVFRywgMiwnc2V0bmFtZScsJ2ZpbCcsJ3NhdmVuZXcnLCdSOlxcTGFiXFxTdHVkaWVzXFxTY2hvb2wgUmVhZGluZXNzIFN0dWR5XFxEYXRhXFxMVjJcXEVSUFxcT2RkYmFsbFxcTUFUTEFCXFwxLUZpbHRlcmluZyAoZmlsKVxcdGNpZF93YXZlLnNldCcsJ2d1aScsJ29mZicpOyAKZWVnbGFiIHJlZHJhdzsKCiUgQXZlcmFnZSByZWZlcmVuY2luZwolRUVHID0gZWVnX2NoZWNrc2V0KCBFRUcgKTsKRUVHID0gcG9wX3JlcmVmKCBBTExFRUcoMiksIFtdKTsKW0FMTEVFRyBFRUcgQ1VSUkVOVFNFVF0gPSBwb3BfbmV3c2V0KEFMTEVFRywgRUVHLCAzLCdzZXRuYW1lJywnQXZnIFJlZicsJ3NhdmVuZXcnLCdSOlxcTGFiXFxTdHVkaWVzXFxTY2hvb2wgUmVhZGluZXNzIFN0dWR5XFxEYXRhXFxMVjJcXEVSUFxcT2RkYmFsbFxcTUFUTEFCXFw5LUF2ZXJhZ2UgUmVmZXJlbmNlIChyZWYpXFx0Y2lkX3dhdmVfYXZnLnNldCcsJ2d1aScsJ29mZicpOwplZWdsYWIgcmVkcmF3OwoKJSBSZWplY3RpbmcgdGhlIGFydGlmYWN0cwolIHRlc3RpbmcgYnVtcGluZyB0aGUgCkVFRyA9IHBvcF9jbGVhbl9yYXdkYXRhKEFMTEVFRygzKSwgJ0ZsYXRsaW5lQ3JpdGVyaW9uJyw1LCdDaGFubmVsQ3JpdGVyaW9uJywwLjgsJ0xpbmVOb2lzZUNyaXRlcmlvbicsNCwnSGlnaHBhc3MnLCdvZmYnLCdCdXJzdENyaXRlcmlvbicsMzAsJ1dpbmRvd0NyaXRlcmlvbicsMC4yNSwnQnVyc3RSZWplY3Rpb24nLCdvbicsJ0Rpc3RhbmNlJywnRXVjbGlkaWFuJywnV2luZG93Q3JpdGVyaW9uVG9sZXJhbmNlcycsWy1JbmYgN10gKTsKJVNhdmluZyBjbGVhbmVkIGRhdGFzZXQKW0FMTEVFRyBFRUcgQ1VSUkVOVFNFVF0gPSBwb3BfbmV3c2V0KEFMTEVFRywgRUVHLCA0LCdzZXRuYW1lJywnY2xlYW4gZGF0YScsJ3NhdmVuZXcnLCdSOlxcTGFiXFxTdHVkaWVzXFxTY2hvb2wgUmVhZGluZXNzIFN0dWR5XFxEYXRhXFxMVjJcXEVSUFxcT2RkYmFsbFxcTUFUTEFCXFwxMC1DbGVhbiBBcnRpZmljYXRzIChjbGVhbilcXHRjaWRfd2F2ZV9jbGVhbi5zZXQnLCdndWknLCdvZmYnKTsgCmVlZ2xhYiByZWRyYXc7CgolIFBsYWNlaG9sZGVyIHRvIG1hbnVhbGx5IHJlbW92ZSBiYWQgY2hhbm5lbHMKCgolIElDQSBjb21wb25lbnRzCkVFRyA9IHBvcF9ydW5pY2EoQUxMRUVHKDQpLCAnaWNhdHlwZScsICdydW5pY2EnLCAnZXh0ZW5kZWQnLCAxLCdpbnRlcnJ1cHQnLCdvbicpOwpbQUxMRUVHIEVFRyBDVVJSRU5UU0VUXSA9IHBvcF9uZXdzZXQoQUxMRUVHLCBFRUcsIDUsJ3NldG5hbWUnLCdJQ0EgdGVzdCcsJ3NhdmVuZXcnLCdSOlxcTGFiXFxTdHVkaWVzXFxTY2hvb2wgUmVhZGluZXNzIFN0dWR5XFxEYXRhXFxMVjJcXEVSUFxcT2RkYmFsbFxcTUFUTEFCXFwxMS1JQ0FcXHRjaWRfd2F2ZV9JQ0Euc2V0JywnZ3VpJywnb2ZmJyk7IAplZWdsYWIgcmVkcmF3OwoKJU1hbnVhbGx5IHJlamVjdCBJQ0EgY29tcG9uZW50cwpFRUcgPSBwb3Bfc3ViY29tcCggRUVHLCBbMSAgICAyICAgIDYgICAgNyAgIDEwICAgMTMgICAyMSAgIDI0ICAgMjYgICAzMSAgIDMyICAgMzMgICAzNiAgIDQzICAgNDQgICA1MSAgIDU0ICAgNTUgICA1OSAgIDYxICAgNjcgICA2OCAgIDc0ICAgODMgICA5MCAgIDkxICAgOTMgICA5OSAgMTAzICAxMTIgIDExMyAgMTE2ICAxMTggIDEyMV0sIDApOwpbQUxMRUVHIEVFRyBDVVJSRU5UU0VUXSA9IHBvcF9uZXdzZXQoQUxMRUVHLCBFRUcsIDYsJ2d1aScsJ29mZicpOyAKZWVnbGFiIHJlZHJhdzsKCiUgUGxhY2UgaG9sZGVyIHRvIHJlbWluZCB0byBtYW51YWxseSByZW1vdmUgdGhlIGNoYW5uZWxzIHRoYXQgd2Ugd291bGQKJSBsaWtlIHRvIHJlamVjdAolIHRha2luZyB0aGUgRUVHIGNoYW5uZWwgbG9jayBvZiB0aGUgZmlyc3QgKHJhdykgZGF0YXNldApFRUcgPSBlZWdfY2hlY2tzZXQoIEVFRyApOwpFRUcgPSBwb3BfaW50ZXJwKEFMTEVFRyg1KSwgQUxMRUVHKDEpLmNoYW5sb2NzLCAnc3BoZXJpY2FsJyk7CltBTExFRUcgRUVHIENVUlJFTlRTRVRdID0gcG9wX25ld3NldChBTExFRUcsIEVFRywgNiwnc2V0bmFtZScsJ0ludGVycG9sYXRlZCcsJ3NhdmVuZXcnLCdSOlxcTGFiXFxTdHVkaWVzXFxTY2hvb2wgUmVhZGluZXNzIFN0dWR5XFxEYXRhXFxMVjJcXEVSUFxcT2RkYmFsbFxcTUFUTEFCXFwxMi1JbnRlcnBvbGF0ZVxcdGNpZF93YXZlX0ludGVycG9sYXRlLnNldCcsJ2d1aScsJ29mZicpOyAKZWVnbGFiIHJlZHJhdzsKCiUgU2VnbWVudGluZyB0aGUgRGF0YQpFRUcgPSBlZWdfY2hlY2tzZXQoIEVFRyApOwpFRUcgPSBwb3BfZXBvY2goIEFMTEVFRyg2KSwgeyAgJ2ZycSsnICAndGd0KycgIH0sIFstMC4yIDFdLCAnbmV3bmFtZScsICd0Y2lkX3dhdmVfc2VnbWVudGVkJywgJ2Vwb2NoaW5mbycsICd5ZXMnKTsKW0FMTEVFRyBFRUcgQ1VSUkVOVFNFVF0gPSBwb3BfbmV3c2V0KEFMTEVFRywgRUVHLCA3LCdzZXRuYW1lJywnU2VnbWVudGVkJywnc2F2ZW5ldycsJ1I6XFxMYWJcXFN0dWRpZXNcXFNjaG9vbCBSZWFkaW5lc3MgU3R1ZHlcXERhdGFcXExWMlxcRVJQXFxPZGRiYWxsXFxNQVRMQUJcXDEzLVNlZ21lbnRcXHRjaWRfd2F2ZV9TZWdtZW50LnNldCcsJ2d1aScsJ29mZicpOyAKZWVnbGFiIHJlZHJhdzsKCiUgQmFzZWxpbmUgQ29ycmVjdGluZyB0aGUgRGF0YQpFRUcgPSBlZWdfY2hlY2tzZXQoIEVFRyApOwpFRUcgPSBwb3Bfcm1iYXNlKCBBTExFRUcoNyksIFstMjAwIDBdICxbXSk7CltBTExFRUcgRUVHIENVUlJFTlRTRVRdID0gcG9wX25ld3NldChBTExFRUcsIEVFRywgOCwnc2V0bmFtZScsJ0Jhc2VsaW5lIENvcnJlY3QnLCdzYXZlbmV3JywnUjpcXExhYlxcU3R1ZGllc1xcU2Nob29sIFJlYWRpbmVzcyBTdHVkeVxcRGF0YVxcTFYyXFxFUlBcXE9kZGJhbGxcXE1BVExBQlxcMTQtQmFzZWxpbmUtQ29ycmVjdFxcdGNpZF93YXZlX2Jhc2VsaW5lLWNvcnJlY3Quc2V0JywnZ3VpJywnb2ZmJyk7IAplZWdsYWIgcmVkcmF3OwoKYGBgCgojIyBBdXRvbWF0aWMgc2NyaXB0IHRoYXQgbG9vcHMgZmlsZXMKCiMjIyBXYXJuaW5nIG1lc3NhZ2VzIHdpdGggc2NyaXB0CgpXYXJuaW5nIG1lc3NhZ2VzIGFwcGVhcmVkIHdoZW4gdXNpbmcgdGhlIGF1dG9tYXRpYyBjbGVhbmluZyBvZiBkYXRhLgpXZSBtYXkgaGF2ZSB0byBzZW5kIGEgZGF0YXNldCB0byBzb21lb25lIHNvIHRoZXkgY2FuIGNoZWNrIG9uIGl0LgpTb21lIGRvY3VtZW50YXRpb24gaXMgZm91bmQgaGVyZToKCi0gaHR0cHM6Ly9zY2NuLnVjc2QuZWR1L3BpcGVybWFpbC9lZWdsYWJsaXN0LzIwMjEvMDE2MjIyLmh0bWwgKGFyY2hpdmVkIGF0IGh0dHBzOi8vcGVybWEuY2MvOVNERy1OR1hEKQotIGh0dHBzOi8vc2Njbi51Y3NkLmVkdS93aWtpL0VFR0xBQl9idWcxOTcxIChhcmNoaXZlZCBhdCBodHRwczovL3Blcm1hLmNjL0g3UEEtVFBUWikKCiMjIyBGaWx0ZXJpbmcsIGF2ZXJhZ2UgcmVmZXJlbmNpbmcsIGFuZCBhdXRvbWF0aWNhbGx5IGNsZWFuaW5nIHRoZSBkYXRhLgoKVGhpcyBzY3JpcHQgYmF0Y2ggcmVhZHMgaW4gZmlsZXMsIGZpbHRlcnMgdGhlbSwgYXZlcmFnZSByZWZlcmVuY2VzLCBhbmQgYXV0b21hdGljYWxseSBjbGVhbnMgdGhlbS4KQWZ0ZXIgdGhhdCwgdGhpcyBzY3JpcHQgcmVhZHMgaW4gdGhlIGNsZWFuZWQgZmlsZXMgZm9yIG1hbnVhbGx5IHByb2Nlc3NpbmcgdG8gcmVtb3ZlIGJhZCB0aW1lIHBlcmlvZHMgYW5kIGJhZCBjaGFubmVscwoKYGBgbWF0bGFiCiUxMC8yMC8yMiBXb3JraW5nIHNjcmlwdCB0aGF0IHJlYWRzIGV2ZXJ5dGhpbmcgaW50byBtYXRsYWIKCgolJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlCiVMb2NhdGlvbiBvZiBSYXcgb2RkYmFsbCBmaWxlcwpyYXdPZGRiYWxsRmlsZXMgPSAnXFxsYy1ycy1zdG9yZTI0LmhwYy51aW93YS5lZHVcbHNzX2l0cGV0ZXJzZW5cTGFiXFN0dWRpZXNcU2Nob29sIFJlYWRpbmVzcyBTdHVkeVxEYXRhXExWMlxFUlBcT2RkYmFsbFxNQVRMQUJcMC1SYXdcJzsKJUxvY2F0aW9uIG9mIHBhdGggdG8gc2F2ZSBjbGVhbmVkIGZpbGVzCmNsZWFuQXV0b1BhdGggPSAnXFxsYy1ycy1zdG9yZTI0LmhwYy51aW93YS5lZHVcbHNzX2l0cGV0ZXJzZW5cTGFiXFN0dWRpZXNcU2Nob29sIFJlYWRpbmVzcyBTdHVkeVxEYXRhXExWMlxFUlBcT2RkYmFsbFxNQVRMQUJcMTAtQ2xlYW4gQXJ0aWZpY2F0cyAoY2xlYW4pXCc7CgolYWxsIG9kZGJhbGwgZmlsZXMgaW4gdGhlIGRpcmVjdG9yeSB0byBiZSBwcm9jZXNzZWQKZmlsZXNJbkRpcmVjdG9yeSA9IGRpcihmdWxsZmlsZShyYXdPZGRiYWxsRmlsZXMsICcqLm1mZicpKTsgJVJlYWRpbmcgdGhlIGZpbGVzIGluIHRoZSBkaXJlY3RvcnkKCiVMaXN0aW5nIHRoZSBudW1iZXIgb2Ygc3ViamVjdHMgZm9yIHRoZSBudW1iZXIgb2YgdGltZXMgdG8gbG9vcApudW1iZXJPZlN1YmplY3QgPSBoZWlnaHQoZmlsZXNJbkRpcmVjdG9yeSk7CgolTmFtZXMgb2YgYWxsIHRoZSBmaWxlcyBpbiB0aGUgZGlyZWN0b3J5Cmxpc3RPZlN1YmplY3RzPXtmaWxlc0luRGlyZWN0b3J5Lm5hbWV9OyAKCiVzcGxpdHRpbmcgdGhlIGZpbGVuYW1lIHVwCmZpbGVuYW1lU3BsaXQgPSByZWdleHAobGlzdE9mU3ViamVjdHMsICdfJywgJ3NwbGl0Jyk7ICAKaWQgPSBjZWxsZnVuKEAoeCkgeHsxfSxmaWxlbmFtZVNwbGl0LCd1bicsMCk7ICAlZ2V0dGluZyB0aGUgaWQncwp3YXZlID0gY2VsbGZ1bihAKHgpIHh7Mn0sZmlsZW5hbWVTcGxpdCwndW4nLDApOyAlZ2V0dGluZyB0aGUgd2F2ZXMKCgoKW0FMTEVFRyBFRUcgQ1VSUkVOVFNFVCBBTExDT01dID0gZWVnbGFiOwoKZm9yIGk9MTpudW1iZXJPZlN1YmplY3QKCiAgICAlJSUlIEltcG9ydGluZyBEYXRhCiAgICBwYXRoID0gW3Jhd09kZGJhbGxGaWxlcyxmaWxlc0luRGlyZWN0b3J5KGkpLm5hbWVdOwogICAgdGNpZCA9IGNoYXIoc3RyY2F0KGlkKGkpLCdfJywgd2F2ZShpKSkpOyAlY29tYmluaW5nIHRoZSBUQ0lEIGFuZCB3YXZlCgogICAgRUVHID0gcG9wX21mZmltcG9ydCh7cGF0aH0seydjb2RlJ30sMCwwKTsKICAgICUgU2F2aW5nIHRoZSBkYXRhIGluIG1lbW9yeQogICBbQUxMRUVHIEVFRyBDVVJSRU5UU0VUXSA9IHBvcF9uZXdzZXQoQUxMRUVHLCBFRUcsIGksJ3NldG5hbWUnLCB0Y2lkLCdndWknLCdvZmYnKTsKCiAgICAlIEZpbHRlcmluZyB0aGUgZGF0YQogICAgRUVHID0gcG9wX2VlZ2ZpbHRuZXcoQUxMRUVHKGkpLCAnbG9jdXRvZmYnLDAuMSwnaGljdXRvZmYnLDMwLCdwbG90ZnJlcXonLDEpOwogICAgW0FMTEVFRyBFRUcgQ1VSUkVOVFNFVF0gPSBwb3BfbmV3c2V0KEFMTEVFRywgRUVHLCBpLCdvdmVyd3JpdGUnLCdvbicsJ2d1aScsJ29mZicpOwogICAgCiAgICAlIEF2ZXJhZ2UgUmVmZXJlbmNpbmcKICAgIEVFRyA9IHBvcF9yZXJlZiggQUxMRUVHKGkpLCBbXSk7CiAgICBbQUxMRUVHIEVFRyBDVVJSRU5UU0VUXSA9IHBvcF9uZXdzZXQoQUxMRUVHLCBFRUcsIGksJ292ZXJ3cml0ZScsJ29uJywnZ3VpJywnb2ZmJyk7CgogICAgJSBUaGV5IHN0cm9uZ2x5IGFkdmlzZSBpbXBvcnRpbmcgY2hhbm5lbCBsb2NhdGlvbnMgYmVmb3JlIHVzaW5nIHRoaXMKICAgICUgZnVuY3Rpb24uCiAgICAlQ2xlYW5pbmcgdGhlIERhdGEKICAgIEVFRyA9IHBvcF9jbGVhbl9yYXdkYXRhKEFMTEVFRyhpKSwgJ0ZsYXRsaW5lQ3JpdGVyaW9uJyw1LCdDaGFubmVsQ3JpdGVyaW9uJywwLjgsJ0xpbmVOb2lzZUNyaXRlcmlvbicsNCwnSGlnaHBhc3MnLCdvZmYnLCdCdXJzdENyaXRlcmlvbicsMzAsJ1dpbmRvd0NyaXRlcmlvbicsMC4yNSwnQnVyc3RSZWplY3Rpb24nLCdvbicsJ0Rpc3RhbmNlJywnRXVjbGlkaWFuJywnV2luZG93Q3JpdGVyaW9uVG9sZXJhbmNlcycsWy1JbmYgN10pOwogICAgbmFtZUNsZWFuID0gW3RjaWQsJ19hdXRvQ2xlYW4uc2V0J107CiAgICBzYXZlUGF0aENsZWFuID0gW2NsZWFuQXV0b1BhdGgsbmFtZUNsZWFuXTsKICAgIFtBTExFRUcgRUVHIENVUlJFTlRTRVRdID0gcG9wX25ld3NldChBTExFRUcsIEVFRywgaSwnc2V0bmFtZScsIG5hbWVDbGVhbiwgJ3NhdmVuZXcnLCBzYXZlUGF0aENsZWFuLCAnZ3VpJywnb2ZmJywgJ292ZXJ3cml0ZScsICdvbicpOwoKCmVuZAplZWdsYWIgcmVkcmF3OgoKJSUgUmVhZGluZyBpbiBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgZGF0YXNldHMKCiUlJSUlJSUlJSUlJSUlCiUgQ2xlYXIgRGF0YSBiZWNhc3VlIHRvIG92ZXJ3cml0ZSBhbnl0aGluZyBpbiBtZW1vcnkKJSUlJSUlJSUlJSUlJSUKQUxMRUVHID0gW107CkVFRyA9IFtdOwoKJSBBZGRpbmcgdGhlIHBhdGggZm9yIGNsZWFuZWQgZmlsZXMKY2xlYW5BdXRvUGF0aCA9ICdcXGxjLXJzLXN0b3JlMjQuaHBjLnVpb3dhLmVkdVxsc3NfaXRwZXRlcnNlblxMYWJcU3R1ZGllc1xTY2hvb2wgUmVhZGluZXNzIFN0dWR5XERhdGFcTFYyXEVSUFxPZGRiYWxsXE1BVExBQlwxMC1DbGVhbiBBcnRpZmljYXRzIChjbGVhbilcJzsKCiVTdGFydGluZyBFRUdMQUIKW0FMTEVFRyBFRUcgQ1VSUkVOVFNFVCBBTExDT01dID0gZWVnbGFiOwoKCiVMb2NhdGlvbiBvZiBjbGVhbmVkIG9kZGJhbGwgZGF0YQpmaWxlc0luRGlyZWN0b3J5Q2xlYW4gPSBkaXIoZnVsbGZpbGUoY2xlYW5BdXRvUGF0aCwgJyouc2V0JykpOyAlUmVhZGluZyB0aGUgZmlsZXMgaW4gdGhlIGRpcmVjdG9yeQoKCiVMaXN0aW5nIHRoZSBudW1iZXIgb2Ygc3ViamVjdHMgZm9yIHRoZSBudW1iZXIgb2YgdGltZXMgdG8gbG9vcApudW1iZXJPZlN1YmplY3RDbGVhbiA9IGhlaWdodChmaWxlc0luRGlyZWN0b3J5Q2xlYW4pOwoKJU5hbWVzIG9mIGFsbCB0aGUgZmlsZXMgaW4gdGhlIGRpcmVjdG9yeQpsaXN0T2ZTdWJqZWN0c0NsZWFuID0ge2ZpbGVzSW5EaXJlY3RvcnlDbGVhbi5uYW1lfTsgCgolc3BsaXR0aW5nIHRoZSBmaWxlbmFtZSB1cApmaWxlbmFtZVNwbGl0Q2xlYW4gPSByZWdleHAobGlzdE9mU3ViamVjdHNDbGVhbiwgJ18nLCAnc3BsaXQnKTsgIAppZCA9IGNlbGxmdW4oQCh4KSB4ezF9LGZpbGVuYW1lU3BsaXRDbGVhbiwndW4nLDApOyAgJWdldHRpbmcgdGhlIGlkJ3MKd2F2ZSA9IGNlbGxmdW4oQCh4KSB4ezJ9LGZpbGVuYW1lU3BsaXRDbGVhbiwndW4nLDApOyAlZ2V0dGluZyB0aGUgd2F2ZXMKCgpmb3IgaT0xOm51bWJlck9mU3ViamVjdENsZWFuCgogICAgJSUlJSBJbXBvcnRpbmcgRGF0YQogICAgdGNpZENsZWFuID0gY2hhcihzdHJjYXQoaWQoaSksJ18nLCB3YXZlKGkpLCAnX2F1dG9DbGVhbi5zZXQnKSk7ICVjb21iaW5pbmcgdGhlIFRDSUQgYW5kIHdhdmUgdG8gbmFtZSB0aGUgZmlsZQogICAgRUVHID0gcG9wX2xvYWRzZXQoJ2ZpbGVuYW1lJywgdGNpZENsZWFuLCAnZmlsZXBhdGgnLCBjbGVhbkF1dG9QYXRoKTsgCiAgICBbQUxMRUVHIEVFRyBDVVJSRU5UU0VUXSA9IHBvcF9uZXdzZXQoQUxMRUVHLCBFRUcsIGksJ3NldG5hbWUnLCB0Y2lkQ2xlYW4sJ2d1aScsJ29mZicpOwoKZW5kCmVlZ2xhYiByZWRyYXc7CmBgYAoKIyMjIFJlbW92aW5nIGJhZCB0aW1lIHBlcmlvZHMgYW5kIGNoYW5uZWxzCgoxLiBJbiB0aGUgbm93IG9wZW4gRUVHTEFCIGludGVyZmFjZSwgc2VsZWN0IGEgZGF0YXNldC4KR28gdG8gYFRvb2xzYCA+IGBJbnNwZWN0L3JlamVjdCBkYXRhIGJ5IGV5ZWAgCgohW3Zpc3VhbGx5IHJlamVjdCBhcnRpZmFjdHNdKGltYWdlcy92aXN1YWxfcmVqZWN0X2FydGlmYWN0cy5wbmcpCgoxLiBHbyB0aHJvdWdoIHRoZSByYXcgc2lnbmFsIGFuZCBtYW51YWxseSByZWplY3QgYmFkIHRpbWUgcGVyaW9kcwoKIVt2aXN1YWxseSByZWplY3QgYXJ0aWZhY3RzXShpbWFnZXMvcmVqZWN0X3RpbWVfcGVyaW9kcy5wbmcpCgoxLiBTZWxlY3QgYFJFSkVDVGAgYW5kIG92ZXJ3cml0ZSB0aGUgZmlsZSBpbiBtZW1vcnkKICAgLSBzZWxlY3QgYE92ZXJ3cml0ZSBpdCBpbiBtZW1vcnkgKHNldD15ZXM7IHVuc2V0PWNyZWF0ZSBhIG5ldyBkYXRhc2V0KWAKMS4gVmlzdWFsbHkgaW5zcGVjdCB0aGUgZGF0YSBhbmQgc2VsZWN0IGFueSBiYWQgY2hhbm5lbHMsIGFuZCB3cml0ZSB0aGVtIGRvd24KMS4gTmV4dCwgbWFudWFsbHkgcmVqZWN0IHRoZSBjaGFubmVscyBieSBzZWxlY3RpbmcgYEVkaXRgIHRoZW4gYFNlbGVjdCBEYXRhYAoKIVt2aXN1YWxseSByZWplY3QgYXJ0aWZhY3RzXShpbWFnZXMvZHJvcF9jaGFubmVscy5wbmcpCgoxLiBNYW51YWxseSBlbnRlciB0aGUgY2hhbm5lbHMgdG8gYmUgcmVtb3ZlZCBpbiB0aGUgYENoYW5uZWwgcmFuZ2VgIGZpZWxkIGFuZCBzZWxlY3QgdGhlIGNoZWNrYm94IHVuZGVyIGBvbi0+cmVtb3ZlIHRoZXNlYCBhbmQgc2VsZWN0IGBPa2AKMS4gU2F2ZSB0aGUgZmlsZSBhcyBgdGNpZF93YXZlX21hbnVhbENsZWFuLnNldGAgaW4gdGhlIGZvbGxvd2luZyBkcml2ZSBwYXRoIAogICAgLSBgXFxsYy1ycy1zdG9yZTI0LmhwYy51aW93YS5lZHVcbHNzX2l0cGV0ZXJzZW5cTGFiXFN0dWRpZXNcU2Nob29sIFJlYWRpbmVzcyBTdHVkeVxEYXRhXExWMlxFUlBcT2RkYmFsbFxNQVRMQUJcMTEtTWFudWFsbHkgQ2xlYW5lZGAKICAgIC0gVGhpcyBzY3JlZW5zaG90IHJlcHJlc2VudHMgcmVtb3ZpbmcgY2hhbm5lbHMgYDIzIDU2IDU3IDk3YAohW3Zpc3VhbGx5IHJlamVjdCBhcnRpZmFjdHNdKGltYWdlcy9yZW1vdmVfY2hhbm5lbHNfc3BlY2lmaWMucG5nKQoxLiBSZXBlYXQgc3RlcCBmb3IgZWFjaCBjbGVhbmVkIGRhdGFzZXQKCiMjIyBSdW5uaW5nIHRoZSBJQ0EKClRoaXMgc2NyaXB0IHJ1bnMgdGhlIElDQS4KV2UnbGwgd2FudCB0byB0aGluayBhYm91dCBob3cgdG8gYXV0b21hdGljYWxseSByZWplY3QgdGhlIGNvbXBvbmVudHMgaGVyZS4KT25jZSB0aGlzIHJ1bnMsIHNlZSB0aGUgW0lDQSBzZWN0aW9uXSgjaWNhKSB0byByZWplY3QgY29tcG9uZW50cy4KVG9vbHMg4oaSIEluc3BlY3QvbGFiZWwgY29tcG9uZW50cyBieSBtYXAgaXMgaG93IHRvIHJlamVjdCBjb21wb25lbnRzLgoKYGBgbWF0bGFiCiUgUnVubmluZyB0aGUgSUNBCgolJSBSZWFkaW5nIGluIHRoZSBtYW51YWxseSBjbGVhbmVkIGRhdGFzZXRzCgolJSUlJSUlJSUlJSUlJQolIENsZWFyIERhdGEgYmVjYXN1ZSB0byBvdmVyd3JpdGUgYW55dGhpbmcgaW4gbWVtb3J5CiUlJSUlJSUlJSUlJSUlCkFMTEVFRyA9IFtdOwpFRUcgPSBbXTsKCiUgQWRkaW5nIHRoZSBwYXRoIGZvciBjbGVhbmVkIGZpbGVzCm1hbnVhbENsZWFuUGF0aCA9ICdcXGxjLXJzLXN0b3JlMjQuaHBjLnVpb3dhLmVkdVxsc3NfaXRwZXRlcnNlblxMYWJcU3R1ZGllc1xTY2hvb2wgUmVhZGluZXNzIFN0dWR5XERhdGFcTFYyXEVSUFxPZGRiYWxsXE1BVExBQlwxMS1NYW51YWxseSBDbGVhbmVkXCc7CgolU3RhcnRpbmcgRUVHTEFCCltBTExFRUcgRUVHIENVUlJFTlRTRVQgQUxMQ09NXSA9IGVlZ2xhYjsKCgolTG9jYXRpb24gb2YgY2xlYW5lZCBvZGRiYWxsIGRhdGEKZmlsZXNJbkRpcmVjdG9yeU1hbnVhbENsZWFuID0gZGlyKGZ1bGxmaWxlKG1hbnVhbENsZWFuUGF0aCwgJyouc2V0JykpOyAlUmVhZGluZyB0aGUgZmlsZXMgaW4gdGhlIGRpcmVjdG9yeQoKCiVMaXN0aW5nIHRoZSBudW1iZXIgb2Ygc3ViamVjdHMgZm9yIHRoZSBudW1iZXIgb2YgdGltZXMgdG8gbG9vcApudW1iZXJPZlN1YmplY3RNYW51YWxDbGVhbiA9IGhlaWdodChmaWxlc0luRGlyZWN0b3J5TWFudWFsQ2xlYW4pOwoKJU5hbWVzIG9mIGFsbCB0aGUgZmlsZXMgaW4gdGhlIGRpcmVjdG9yeQpsaXN0T2ZTdWJqZWN0c01hbnVhbENsZWFuID0ge2ZpbGVzSW5EaXJlY3RvcnlNYW51YWxDbGVhbi5uYW1lfTsgCgolc3BsaXR0aW5nIHRoZSBmaWxlbmFtZSB1cApmaWxlbmFtZVNwbGl0TWFudWFsQ2xlYW4gPSByZWdleHAobGlzdE9mU3ViamVjdHNNYW51YWxDbGVhbiwgJ18nLCAnc3BsaXQnKTsgIAppZCA9IGNlbGxmdW4oQCh4KSB4ezF9LGZpbGVuYW1lU3BsaXRNYW51YWxDbGVhbiwndW4nLDApOyAgJWdldHRpbmcgdGhlIGlkJ3MKd2F2ZSA9IGNlbGxmdW4oQCh4KSB4ezJ9LGZpbGVuYW1lU3BsaXRNYW51YWxDbGVhbiwndW4nLDApOyAlZ2V0dGluZyB0aGUgd2F2ZXMKCgpmb3IgaT0xOm51bWJlck9mU3ViamVjdE1hbnVhbENsZWFuCgogICAgJSUlJSBJbXBvcnRpbmcgRGF0YQogICAgdGNpZENsZWFuID0gY2hhcihzdHJjYXQoaWQoaSksJ18nLCB3YXZlKGkpLCAnX21hbnVhbENsZWFuLnNldCcpKTsgJWNvbWJpbmluZyB0aGUgVENJRCBhbmQgd2F2ZSB0byBuYW1lIHRoZSBmaWxlCiAgICBFRUcgPSBwb3BfbG9hZHNldCgnZmlsZW5hbWUnLCB0Y2lkQ2xlYW4sICdmaWxlcGF0aCcsIG1hbnVhbENsZWFuUGF0aCk7IAogICAgW0FMTEVFRyBFRUcgQ1VSUkVOVFNFVF0gPSBwb3BfbmV3c2V0KEFMTEVFRywgRUVHLCBpLCdzZXRuYW1lJywgdGNpZENsZWFuLCdndWknLCdvZmYnKTsKCiAgICAlJSUgUnVubmluZyB0aGUgSUNBCiAgICBFRUcgPSBlZWdfY2hlY2tzZXQoIEVFRyApOwogICAgRUVHID0gcG9wX3J1bmljYShFRUcsICdpY2F0eXBlJywgJ3J1bmljYScsICdleHRlbmRlZCcsMSwnaW50ZXJydXB0Jywnb24nKTsKICAgIFtBTExFRUcgRUVHXSA9IGVlZ19zdG9yZShBTExFRUcsIEVFRywgQ1VSUkVOVFNFVCk7CiAgICBlZWdsYWIgcmVkcmF3OwoKZW5kCmVlZ2xhYiByZWRyYXc7CmBgYAoKIyMgTm90ZXMKCiMjIyBNb3VudC9DYXAgVHlwZQoKT3B0aW9ucyB0aGF0IHNheSAiQXZlcmFnZU5ldDEyOCIgYXJlIHN1aXRhYmxlIGZvciBvdXIgMTI4IGNoYW5uZWwgY2FwIHdoZW4gc2VsZWN0aW5nIHRoZSB0ZW1wbGF0ZSBvcHRpb24gd2hlbiByZWFkaW5nIGluIHRleHQgZmlsZXMuClRoZXNlIGFyZSBhZ2Utbm9ybWVkIGNvb3JkaW5hdGVzIHByb3ZpZGVkIGJ5IEVHSS4KU28sICIyXzkiIGlzIGFnZS1ub3JtZWQgZm9yIDIgdG8gOSB5ZWFyIG9sZHMu</div>
<script type="text/javascript" src="includes/external-links.js"></script>

<br>
<hr>
<br>

<!-- Add lab logo -->
<p style="text-align: center;">
    <a href="https://developmental-psychopathology.lab.uiowa.edu" target="_blank">
        <img alt="Developmental Psychopathology Lab" src="images/formalLogo.png" width="60%">
    </a>
</p>

<br>
<hr>
<br>

<!-- Add icon library -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<!-- Add font awesome icons -->
<p style="text-align: center;">
    <a href="https://github.com/DevPsyLab" target="_blank" class="fa fa-github fa-fw fa-3x"></a>
    <a href="https://twitter.com/devpsylab" target="_blank" class="fa fa-twitter fa-fw fa-3x"></a>
    <a href="https://www.facebook.com/DevPsyLab" target="_blank" class="fa fa-facebook fa-fw fa-3x"></a>
	<a href="https://www.instagram.com/dev_psy_lab" target="_blank" class="fa fa-instagram fa-fw fa-3x"></a>
</p>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("eegERP.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3,h4",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
